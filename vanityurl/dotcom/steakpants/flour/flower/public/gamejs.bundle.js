(function(){function r(e,n,t){function o(i,f){if(!n[i]){if(!e[i]){var c="function"==typeof require&&require;if(!f&&c)return c(i,!0);if(u)return u(i,!0);var a=new Error("Cannot find module '"+i+"'");throw a.code="MODULE_NOT_FOUND",a}var p=n[i]={exports:{}};e[i][0].call(p.exports,function(r){var n=e[i][1][r];return o(n||r)},p,p.exports,r,e,n,t)}return n[i].exports}for(var u="function"==typeof require&&require,i=0;i<t.length;i++)o(t[i]);return o}return r})()({1:[function(require,module,exports){
var utils = require('./utils');
var gamejs = require('gamejs');
var engine = require('./engine');

var Animation=exports.Animation=function(pars){
    /*
    pars:
    filename, duration, repeat

    */
    this.filename=pars.filename;
    this.age=0;
    this.duration=pars.duration;
    this.type='animation';
 
    this.finished=false;
    this.repeat=pars.repeat ? true : false;
    
    this.resize_from=0;
    this.resize_to=0;
    this.resize_age=0;
    this.resize_duration=0;
    
    this.onFinish = function(){};
    
    this.restart = function(){
        this.age = 0;
    };
    
    this.resize = function(from, to, duration){
    	this.resize_from = from;
    	this.resize_to = to;
    	this.resize_duration = duration;
    	this.resize_age = 0;
    };

    this.update = function(msDuration) {
        this.age += msDuration;
        if(this.resize_age < this.resize_duration)
            this.resize_age += msDuration;
        if(this.age > this.duration) {
            this.onFinish();
            if(this.repeat) {
                this.restart();
            } else {
                this.finished = true;
            }
        }
    };



    this.draw = function(renderer, position){
        var frames = renderer.cache.getAnimationFrameCount(this.filename);
        var sz = null;
        if(this.resize_age < this.resize_duration){
            sz = this.resize_from+parseInt((this.resize_to - this.resize_from) * (this.resize_age / this.resize_duration));
        }    
        renderer.drawAnimation(this.filename, position, Math.min(parseInt(this.age / (this.duration / frames)), frames - 1), sz);
    };
    return this;
};

var AnimationObject = exports.AnimationObject = function(pars){
    AnimationObject.superConstructor.apply(this, [pars]);
    this.add_tag('animation_object');
    this.anim = new Animation(pars);
    this.position = pars.position;
    this.world = pars.world;
    this.duration = pars.duration;

    this.follow_obj = pars.follow_obj;
    if(pars.resize){
    	this.anim.resize(pars.resize.from, pars.resize.to, pars.resize.duration);
    }
};

gamejs.utils.objects.extend(AnimationObject, engine.Object);

engine.register_class(AnimationObject);

AnimationObject.prototype.update = function(msDuration){
    this.anim.update(msDuration);
    if(this.anim.finished){
        this.world.destroy(this);
    }
};

AnimationObject.prototype.draw = function(renderer){
    var position = this.follow_obj ? this.follow_obj.get_position() : this.position;
    this.anim.draw(renderer, position);
};

exports.animations={'small_explosion':{'filename':'explosion_small.png',
                                        'duration':500},
                    'smoke':{'filename':'smoke.png',
                            'duration':300},
                    'explosion':{'filename':'explosion.png',
                                 'duration':1000},
                    'explosion2':{'filename':'explosion2.png',
                    			  'duration':1000},
                    'shockwave':{'filename':'sw.png',
                                'duration':200,
                                'resize':{'from':40, 
                                		  'to':200, 
                                		  'duration':200}},
                    'heal':{'filename':'heal.png',
                            'duration':500},
                    'fire':{'filename':'fire64.png',
                    		'duration':500},
                    'shield':{'filename':'forcefield.png',
                    		'duration':2000}
                    };

},{"./engine":9,"./utils":33,"gamejs":37}],2:[function(require,module,exports){
var names=exports.names=['Bob', 'The Dominator', 'Desert Penguin', 'Smiley'];
var car_descriptions=require('./car_descriptions');
exports.generateBotCarDescr=function(){
    var cartypes=[];
    for(var key in car_descriptions) cartypes.push(key);
    var ct=cartypes[Math.floor(Math.random()*(cartypes.length))];
    var weapons=['Machinegun', 'MissileLauncher'];
    var wp=weapons[Math.floor(Math.random()*(weapons.length))];
    var retv={'type':ct,
                'front_weapon':{'type':wp,
                                'ammo_upgrades':0,
                                'damage_upgrades':0},
                'util':null,
                'rear_weapon':null,
                'acc_upgrades':0,
                'speed_upgrades':0,
                'armor_upgrades':0};
    
    return retv;
};

//LEAGUE 1

exports.CatLady={'type':'Sandbug',
                    'name':'Cat Lady',
                    'front_weapon':{'type':'Machinegun',
                                    'ammo_upgrades':0,
                                    'damage_upgrades':0},
                    'util':null,
                    'rear_weapon':{'type':'MineLauncher',
                                    'ammo_upgrades':0,
                                    'damage_upgrades':0},
                    'acc_upgrades':0,
                    'speed_upgrades':0,
                    'armor_upgrades':0};
                    
                    
exports.Bob={'type':'Hillbilly',
                    'name':'Bob',
                    'front_weapon':{'type':'MissileLauncher',
                                    'ammo_upgrades':1,
                                    'damage_upgrades':1},
                    'util':null,
                    'rear_weapon':null,
                    'acc_upgrades':2,
                    'speed_upgrades':0,
                    'armor_upgrades':0};
                    
                    
exports.Dominator={'type':'Sandbug',
                      'name':'The Dominator',
                      'front_weapon':{'type':'Machinegun',
                                    'ammo_upgrades':3,
                                    'damage_upgrades':0},
                    'util':null,
                    'rear_weapon':null,
                    'acc_upgrades':0,
                    'speed_upgrades':0,
                    'armor_upgrades':2};
                    
//LEAGUE 2             
exports.HotShot={'type':'Racer',
                    'name':'HotShot',
                    'front_weapon':{'type':'Machinegun',
                                    'ammo_upgrades':5,
                                    'damage_upgrades':3},
                    'util':{'type':'Shockwave',
                                    'ammo_upgrades':0,
                                    'damage_upgrades':0},
                    'rear_weapon':null,
                    'acc_upgrades':0,
                    'speed_upgrades':0,
                    'armor_upgrades':0};
                    
                    
exports.TheDude={'type':'Hillbilly',
                    'name':'The Dude',
                    'front_weapon':{'type':'HomingMissiles',
                                    'ammo_upgrades':1,
                                    'damage_upgrades':1},
                    'util':null,
                    'rear_weapon':{'type':'Oil',
                                    'ammo_upgrades':1,
                                    'damage_upgrades':1},
                    'acc_upgrades':2,
                    'speed_upgrades':2,
                    'armor_upgrades':0};
                    
                    
exports.Ratman={'type':'Bandit',
                      'name':'Ratman',
                      'front_weapon':{'type':'PlasmaCannon',
                                    'ammo_upgrades':2,
                                    'damage_upgrades':0},
                    'util':{'type':'RepairKit',
                                    'ammo_upgrades':2,
                                    'damage_upgrades':0},
                    'rear_weapon':null,
                    'acc_upgrades':0,
                    'speed_upgrades':2,
                    'armor_upgrades':2};
                    

//league three

exports.Bulldog = {'type':'Brawler',
				   'name':'Brawler',
				   'front_weapon':{'type':'MissileLauncher',
				   				   'ammo_upgrades':4,
				   				   'damage_upgrades':3},
				   'util':{'type':'NOS',
				   		   'ammo_upgrades':1,
				   		   'damage_upgrades':0},
				   	'rear_weapon':{'type':'Oil',
                                    'ammo_upgrades':1,
                                    'damage_upgrades':1},
				   	'acc_upgrades':2,
				   	'speed_upgrades':1,
				   	'armor_upgrades':2};
				   	
exports.JC={'type':'Bandit',
              'name':'JC',
              'front_weapon':{'type':'Machinegun',
                                'ammo_upgrades':2,
                                'damage_upgrades':3},
	           'util':{'type':'Shield',
	                    'ammo_upgrades':0,
	                    'damage_upgrades':0},
	           'rear_weapon':{'type':'Napalm',
	                          'ammo_upgrades':2,
	                          'damage_upgrades':1},
	           'acc_upgrades':0,
	           'speed_upgrades':3,
	           'armor_upgrades':1};
	           
exports.PainKid={'type':'Racer',
	                'name':'Pain Kid',
	                'front_weapon':{'type':'Machinegun',
	                                'ammo_upgrades':5,
	                                'damage_upgrades':3},
	                'util':{'type':'Shockwave',
	                                'ammo_upgrades':1,
	                                'damage_upgrades':0},
	                'rear_weapon':{'type':'MineLauncher',
	                                'ammo_upgrades':2,
	                                'damage_upgrades':4},
	                'acc_upgrades':0,
	                'speed_upgrades':2,
	                'armor_upgrades':2};
                    	           
                    
				   	
				

},{"./car_descriptions":4}],3:[function(require,module,exports){
var gamejs = require('gamejs');
var animation = require('./animation');
var utils = require('./utils');
var engine = require('./engine');
var vec=utils.vec;
var arr=utils.arr;

var EFFECT_NO_GRIP = exports.EFFECT_NO_GRIP = 'no_grip';
var EFFECT_ENGINE = exports.EFFECT_ENGINE = 'engine';
var EFFECT_INVULNERABLE = exports.EFFECT_INVULNERABLE = 'invulnerable';

var Buff = exports.Buff=function(pars){
    Buff.superConstructor.apply(this, [pars]);
    this.age = 0;
    this.duration = pars.duration ? pars.duration : null;
    this.effect = pars.effect;
    this.value = pars.value;
    this.object = pars.object;
    this.object.buffs.push(this);
};

gamejs.utils.objects.extend(Buff, engine.Object);

Buff.prototype.update = function(msDuration){
    this.age += msDuration;
    if(this.age > this.duration){
        this.world.destroy(this);
    }
};

Buff.prototype.die = function(){
    for(var i=0; i < this.object.buffs.length; i++) {
        if(this.object.buffs[i].id == this.id) {
            this.object.buffs.splice(i, 1);
            break;
        }
    }
};

Buff.prototype.process_hit = function(damage, owner){
	//return false to not register hit
	return true;
};

var EngineBuff = exports.EngineBuff=function(pars){
    pars.effect = EFFECT_ENGINE;
    EngineBuff.superConstructor.apply(this, [pars]);
};
gamejs.utils.objects.extend(EngineBuff, Buff);
engine.register_class(EngineBuff);

var SlipDebuff = exports.SlipDebuff=function(pars){
    pars.effect = EFFECT_NO_GRIP;
    SlipDebuff.superConstructor.apply(this, [pars]);
};

gamejs.utils.objects.extend(SlipDebuff, Buff);
engine.register_class(SlipDebuff);

var InvulnerabilityBuff = exports.InvulnerabilityBuff = function(pars){
	pars.effect = EFFECT_INVULNERABLE;
	pars.duration=1;
	this.hits_left = 3;
	InvulnerabilityBuff.superConstructor.apply(this, [pars]);
	this.animation = new animation.Animation({'filename':'forcefield.png',
											  'duration':1000,
											  'repeat':true});
};

gamejs.utils.objects.extend(InvulnerabilityBuff, Buff);
engine.register_class(InvulnerabilityBuff);

InvulnerabilityBuff.prototype.update = function(msDuration){
	this.animation.update(msDuration);
};

InvulnerabilityBuff.prototype.process_hit = function(damage, owner){
	this.hits_left--;
	if(this.hits_left == 0){
		this.world.destroy(this);
	}
	return false;
};

InvulnerabilityBuff.prototype.draw = function(renderer){
	this.animation.draw(renderer, this.object.get_position());
};

},{"./animation":1,"./engine":9,"./utils":33,"gamejs":37}],4:[function(require,module,exports){
/*car:
 
    width             - width in meters
    height            - height in meters
    filenames          - sprite file name
    power             -engine power in newtons
    max_steer_angle   -max steering angle, degrees
    max_speed         -max speed, km/h
    wheels      -front wheel definitions: [[-1, -1.2], [1, -1.2]] 
    weapon1           -first weapon
    weapon2           -second weapon
    health            -max health
*/

/*
  wheel:
  x
  y
  revolving
  powered
*/

/*
 this.player_car=new cars.Car({'width':2,
                                    'height':4,
                                    'filename':'yellow_car.png',
                                    'world':this.world,
                                    'position':[car_positions[1].x+1, car_positions[1].y+2],
                                    'angle':car_positions[1].angle,
                                    'power':90,
                                    'max_steer_angle':20,
                                    'max_speed':150,
                                    'front_wheels':[[-1, -1.2], [1, -1.2]],
                                    'back_wheels':[[-1, 1.1], [1, 1.2]],
                                    'weapon1':new weapons.Machinegun({}),
                                    'weapon2':new weapons.MineLauncher({}),
                                    'health':100});
 
*/


exports.Bandit={'width':1.7,
                'height':3.5,
                'id':'Bandit',
                'name':'Bandit',
                'description':'Small but agile',
                'filenames':['bandit_yellow.png', 'bandit_green.png', 'bandit_blue.png', 'bandit_red.png'],
                'art_filename':'bandit_big.png',
                'power':105,
                'max_speed':110,
                'max_steer_angle':17,
                'health':80,
                
                'power_upgrade':6,
                'speed_upgrade':4,
                'armor_upgrade':20,
                'upgrade_price':600,
                
                'speed_stars':1,
                'acceleration_stars':4,
                'armor_stars':1,
                'handling_stars':4,
                
                'price':3000,
                
                'main_weapon':'Machinegun',
                'wheels':[{'x':-0.85, 'y':-1, 'width':0.4, 'length':0.8, 'revolving':true, 'powered':true, 'filename':'wheel.png'},
                          {'x':0.85, 'y':-1, 'width':0.4, 'length':0.8, 'revolving':true, 'powered':true, 'filename':'wheel.png'},
                          {'x':-0.85, 'y':1.1, 'width':0.4, 'length':0.8, 'revolving':false, 'powered':false, 'filename':'wheel.png'},
                          {'x':0.85, 'y':1.1, 'width':0.4, 'length':0.8, 'revolving':false, 'powered':false, 'filename':'wheel.png'}]
                };
                
exports.Sandbug={'id':'Sandbug',
                'width':1.8,
                'height':4,
                'name':'Sandbug',
                'description':'A basic, low budget car',
                'filenames':['sandbug_yellow.png', 'sandbug_green.png', 'sandbug_blue.png', 'sandbug_red.png'],
               'art_filename':'sandbug_big.png',
               'power':75,
               'max_steer_angle':15,
               'max_speed':100,
               'health':100,
               
               'power_upgrade':7,
               'speed_upgrade':4,
               'armor_upgrade':20,
               'upgrade_price':300,
               
               'speed_stars':1,
               'acceleration_stars':1,
               'armor_stars':2,
               'handling_stars':2,
               
               'price':1000,
               'wheels':[{'x':-0.9, 'y':-1.2, 'width':0.4, 'length':0.8, 'revolving':true, 'powered':true, 'filename':'wheel.png'},
                          {'x':0.9, 'y':-1.2, 'width':0.4, 'length':0.8, 'revolving':true, 'powered':true, 'filename':'wheel.png'},
                          {'x':-0.9, 'y':1.2, 'width':0.4, 'length':0.8, 'revolving':false, 'powered':false, 'filename':'wheel.png'},
                          {'x':0.9, 'y':1.2, 'width':0.4, 'length':0.8, 'revolving':false, 'powered':false, 'filename':'wheel.png'}]
                };
               
exports.Thunderbolt = {'width':2.1,
                       'height':4.5,
                       'id':'Thunderbolt',
                       'name':'Thunderbolt',
                       'description':'A powerful muscle car',
                       'filenames':['thunderbolt_yellow.png', 'thunderbolt_green.png', 'thunderbolt_blue.png', 'thunderbolt_red.png'],
                       'art_filename':'thunderbolt_big.png',
                       'power':140,
                       'max_steer_angle':13,
                       'max_speed':135,
                       'health':140,
                       
                       'power_upgrade':9,
                       'speed_upgrade':5,
                       'armor_upgrade':25,
                       'upgrade_price':1200,
                       
                       'speed_stars':4,
                       'acceleration_stars':4,
                       'armor_stars':3,
                       'handling_stars':1,
                       
                       'price':7000,
                       
                       'wheels':[{'x':-1, 'y':-1.4, 'width':0.4, 'length':0.8, 'revolving':true, 'powered':true, 'filename':'wheel.png'},
		                          {'x':1, 'y':-1.4, 'width':0.4, 'length':0.8, 'revolving':true, 'powered':true, 'filename':'wheel.png'},
		                          {'x':-1, 'y':1.4, 'width':0.4, 'length':0.8, 'revolving':false, 'powered':false, 'filename':'wheel.png'},
		                          {'x':1, 'y':1.4, 'width':0.4, 'length':0.8, 'revolving':false, 'powered':false, 'filename':'wheel.png'}]
                       
                       }  ;             
                
                
exports.Racer={'width':2,
                'id':'Racer',
                'name':'Racer',
                'description':'A well rounded racing car',
               'height':4,
               'filenames':['racer_yellow.png', 'racer_green.png', 'racer_blue.png', 'racer_red.png'],
               'art_filename':'racer_big.png',
                'power':90,
                'max_steer_angle':16,
                'max_speed':125,
                'health':100,
                
                'power_upgrade':7,
                'speed_upgrade':4,
                'armor_upgrade':20,
                'upgrade_price':600,
                
                'speed_stars':3,
                'acceleration_stars':2,
                'armor_stars':2,
                'handling_stars':3,
                
                'price':4500,
                
                'wheels':[{'x':-0.9, 'y':-1.2, 'width':0.4, 'length':0.8, 'revolving':true, 'powered':true, 'filename':'wheel.png'},
                          {'x':0.9, 'y':-1.2, 'width':0.4, 'length':0.8, 'revolving':true, 'powered':true, 'filename':'wheel.png'},
                          {'x':-0.9, 'y':1.2, 'width':0.4, 'length':0.8, 'revolving':false, 'powered':false, 'filename':'wheel.png'},
                          {'x':0.9, 'y':1.2, 'width':0.4, 'length':0.8, 'revolving':false, 'powered':false, 'filename':'wheel.png'}]
                
            };
            
exports.Hillbilly={'width':2.4,
                'height':5,
                'id':'Hillbilly',
                'name':'Hillbilly',
                'description':'Sturdy, lots of space in the back',
                'filenames':['samaritan_yellow.png', 'samaritan_green.png', 'samaritan_blue.png', 'samaritan_red.png'],
                'art_filename':'samaritan_big.png',
                'power':120,
                'max_steer_angle':16,
                'max_speed':115,
                'health':140,
                
                'power_upgrade':10,
                'speed_upgrade':4,
                'armor_upgrade':25,
                'upgrade_price':600,
                
                'speed_stars':2,
                'armor_stars':3,
                'acceleration_stars':1,
                'handling_stars':2,
                
                'price':4000,
                
                'wheels':[{'x':-1, 'y':-1.7, 'width':0.6, 'length':1.2, 'revolving':true, 'powered':true, 'filename':'big_wheel.png'},
                          {'x':1, 'y':-1.7, 'width':0.6, 'length':1.2, 'revolving':true, 'powered':true, 'filename':'big_wheel.png'},
                          {'x':-0.9, 'y':1.6, 'width':0.6, 'length':1.2, 'revolving':false, 'powered':false, 'filename':'big_wheel.png'},
                          {'x':0.9, 'y':1.6, 'width':0.6, 'length':1.2, 'revolving':false, 'powered':false, 'filename':'big_wheel.png'}]
                };
            
            
exports.Brawler={'width':3,
                'height':6,
                'id':'Brawler',
                'name':'Brawler',
                'description':'Heavily armored combat SUV',
                'filenames':['brawler_yellow.png', 'brawler_green.png', 'brawler_blue.png', 'brawler_red.png'],
                'art_filename':'brawler_big.png',
                'power':150,
                'max_steer_angle':16,
                'max_speed':120,
                'health':180,
                
                'power_upgrade':12,
                'speed_upgrade':4,
                'armor_upgrade':30,
                'upgrade_price':600,
                
                'speed_stars':3,
                'armor_stars':4,
                'acceleration_stars':1,
                'handling_stars':1,
                
                'price':6000,
                
                'main_weapon':'MissileLauncher',
                'wheels':[{'x':-1.25, 'y':-2, 'width':0.6, 'length':1.2, 'revolving':true, 'powered':true, 'filename':'big_wheel.png'},
                          {'x':1.25, 'y':-2, 'width':0.6, 'length':1.2, 'revolving':true, 'powered':true, 'filename':'big_wheel.png'},
                          {'x':-1.25, 'y':2.1, 'width':0.6, 'length':1.2, 'revolving':false, 'powered':false, 'filename':'big_wheel.png'},
                          {'x':1.25, 'y':2.1, 'width':0.6, 'length':1.2, 'revolving':false, 'powered':false, 'filename':'big_wheel.png'}]
                };
},{}],5:[function(require,module,exports){
var gamejs = require('gamejs');
var utils = require('./utils');
var sounds = require('./sounds');
var buffs=require('./buffs');
var car_descriptions = require('./car_descriptions');
var combatracer=require('./combatracer');
var weapons = require('./weapons');
var weapon_descriptions = require('./weapon_descriptions');
var engine = require('./engine');
var settings = require('./settings');
var box2d = engine.box2d;
var vec=utils.vec;
var arr=utils.arr;

var vectors = gamejs.utils.vectors;
var math = gamejs.utils.math;
radians=math.radians;
degrees=math.degrees;

var animation=require('./animation');

var STEER_NONE=exports.STEER_NONE=0;
var STEER_RIGHT=exports.STEER_RIGHT=1;
var STEER_LEFT=exports.STEER_LEFT=2;

var ACC_NONE=exports.ACC_NONE=0;
var ACC_ACCELERATE=exports.ACC_ACCELERATE=1;
var ACC_BRAKE=exports.ACC_BRAKE=2;

var Wheel = exports.Wheel = function(pars){
    this.car = pars.car;
    this.local_position = pars.position;
    
    var par_list = [    
                        ['revolving', false],
                        ['powered', false]
                   ];
               
    engine.utils.process_parameters(pars, par_list);
    
    pars.position = this.car.get_world_point(this.local_position);
    pars.angle = this.car.get_angle();
    pars.sensor = true;
    Wheel.superConstructor.apply(this, [pars]);
    this.prev_position = this.position;
    this.add_tag('wheel');
    
    //create joint to connect wheel to body
    if(this.parameters.revolving){
        var jointdef = new box2d.b2RevoluteJointDef();
        jointdef.Initialize(this.car.body, this.body, this.body.GetWorldCenter());
        jointdef.enableMotor = false;
        jointdef.referenceAngle = 0;
    }else{
        var jointdef = new box2d.b2PrismaticJointDef();
        jointdef.Initialize(this.car.body, this.body, this.body.GetWorldCenter(), vec([1, 0]));
        jointdef.enableLimit = true;
        jointdef.lowerTranslation = jointdef.upperTranslation = jointdef.referenceAngle=0;
    }
    this.world.b2world.CreateJoint(jointdef);
};

gamejs.utils.objects.extend(Wheel, engine.Entity);


Wheel.prototype.reset_angle = function() {
    this.set_angle(this.car.get_angle());
};

Wheel.prototype.set_relative_angle = function(angle) {
    this.set_angle(this.car.get_angle()+angle);
};

Wheel.prototype.get_world_position=function() {
    return this.car.get_world_point(this.local_position);
};

Wheel.prototype.draw = function(renderer) {
    renderer.drawCar(this.parameters.filename, 
                    this.car.get_world_point(this.local_position), 
                    this.get_angle());
    if(this.alive){
        if(this.prev_position && 
          (gamejs.utils.vectors.angle(this.get_linear_velocity(), 
                                      this.get_world_vector([0, -1])) > gamejs.utils.math.radians(20))){
            var ps = settings.get('PHYS_SCALE');
            var pp = this.prev_position;
            var  p= this.position;
            var a1 = [-this.parameters.size[0] / 2, 0];
            var a2 = [this.parameters.size[0] / 2, 0];
            var angle = radians(this.get_angle());
            a1 = gamejs.utils.vectors.rotate(a1, angle);
            a2 = gamejs.utils.vectors.rotate(a2, angle);
            var points=[[(a1[0]+pp[0])*ps, (a1[1]+pp[1])*ps],
                        [(a1[0]+p[0])*ps, (a1[1]+p[1])*ps],
                        [(a2[0]+p[0])*ps, (a2[1]+p[1])*ps],
                        [(a2[0]+pp[0])*ps, (a2[1]+pp[1])*ps]];
            gamejs.draw.polygon(renderer.background, '#282828', points)
        };
       
        this.prev_position = this.position;
   }
};

Wheel.prototype.get_local_velocity = function(){
    return this.get_local_vector(this.car.get_linear_velocity(this.local_position));
};

Wheel.prototype.get_kill_velocity_vector = function(){
    var velocity = this.get_linear_velocity();
    var sideways_axis = this.get_direction_vector();
    var dotprod = vectors.dot(velocity, sideways_axis);
    return vectors.multiply(sideways_axis, dotprod);
};

Wheel.prototype.kill_sideways_velocity = function(){
    var kv = this.get_kill_velocity_vector();
    this.k_velocity = kv;
    this.set_linear_velocity(kv);
};

Wheel.prototype.die = function(){
    this.alive = false;
    this.set_linear_velocity([0, 0]);
    this.prev_position = null;
};

Wheel.prototype.get_local_angle=function(){   
    var retv= math.normaliseDegrees(this.get_angle()-this.car.get_angle());
    if(retv > 180) retv -= 360;
    return retv;
};

Wheel.prototype.respawn = function(){
    this.alive = true;
};


var Car = exports.Car = function(parameters){
    /*
    pars is object with keys:

    width             - width in meters
    height            - height in meters
    filename          - sprite file name
    world             - world object
    position          -[x, y]  position in world
    angle             -start angle in degrees
    power             -engine power in newtons
    max_steer_angle   -max steering angle, degrees
    max_speed         -max speed, km/h
    wheels            -wheel definitins: {'x', 'y', 'rotart', 'powered'}
    front_weapon           -first weapon
    rear_weapon           -second weapon
    util
    health            -max health
    alias             -player alias
    car_type
    speed_upgrades
    armor_upgrades
    acc_upgrades

    */
    this.descr = car_descriptions[parameters.car_type];
   
    parameters.size = [this.descr.width, this.descr.height];
   
    var par_list = [    
                        ['filename',        ''],
                        'car_type',
                        ['mod_speed',       0],
                        ['engine_sound',    false],
                        ['turn_msec',       200],
                        ['front_weapon',    null],
                        ['rear_weapon',     null],
                        ['util',            null],
                        ['alias',           ''],
                        ['speed_upgrades',  0],
                        ['armor_upgrades',  0],
                        ['acc_upgrades',    0]
                   ];
               
    engine.utils.process_parameters(parameters, par_list);
    
    this.health = this.max_health =  parameters.max_health = this.descr.health + parameters.armor_upgrades * this.descr.armor_upgrade;
    this.max_speed = this.descr.max_speed + parameters.speed_upgrades * this.descr.speed_upgrade;
    
    Car.superConstructor.apply(this, [parameters]);
    
    var carpos = this.world.get_objects_by_tag('car').length;
    this.filename = this.descr.filenames[carpos % this.descr.filenames.length];

    this.add_tag('car');
    this.active = true;
    
    this.alias = this.parameters.alias;
    this.next_checkpoint_no = 1;
    this.lap = 0;
    this.time_to_respawn = 0;
    this.respawn_location = this.position;
    this.respawn_angle = 0;
    this.respawn_time = 2000;
    this.kills = 0;
    this.deaths = 0;

    //WEAPONS
    this.front_weapon = null;
    this.rear_weapon = null;
    this.util = null;
    
    if(this.parameters.front_weapon){
        var pars = utils.copy(this.parameters.front_weapon, {});
        pars.car = this;
        pars.slot = 'front_weapon';
        pars.world = this.world;
        this.world.create(weapons[weapon_descriptions[pars.type].launcher], pars);
    }
    if(this.parameters.rear_weapon){
        var pars = utils.copy(this.parameters.rear_weapon, {});
        pars.car = this;
        pars.world = this.world;
        pars.slot = 'rear_weapon';
        this.world.create(weapons[weapon_descriptions[pars.type].launcher], pars);
    }
    if(this.parameters.util) {
        var pars = utils.copy(this.parameters.util, {});
        pars.car = this;
        pars.world = this.world;
        pars.slot = 'util';
        this.world.create(weapons[weapon_descriptions[pars.type].launcher], pars);
    }

    //ACTIONS
    this.fire_front_weapon = false;
    this.fire_rear_weapon = false;
    this.fire_util = false;
    this.accelerate = ACC_NONE;
    this.steer = STEER_NONE;

    //PHYSICAL
    this.max_steer_angle = this.descr.max_steer_angle;
    this.power = this.descr.power + this.parameters.acc_upgrades * this.descr.power_upgrade;
    this.max_speed = this.descr.max_speed + this.parameters.speed_upgrades * this.descr.speed_upgrade;
    this.turn_msec = this.parameters.turn_msec;
    this.local_engine_pos = [0, -(this.parameters.height/2)];
    this.cur_wheel_angle = 0;
    this.mod_speed = this.parameters.mod_speed;
    

    //ANIM
    this.smoke_cd = 0;
    
    //initialize wheels
    this.wheels=[]
    var wheeldef, i;
    this.descr.wheels.forEach(function(wheeldef){
        wheeldef = utils.copy(wheeldef, {});
        wheeldef.position = [wheeldef.x, wheeldef.y];
        wheeldef.size = [wheeldef.width, wheeldef.length];
        wheeldef.car = this;
        wheeldef.world = this.world;
        this.wheels.push( new Wheel(wheeldef) );
    }, this);
};   

gamejs.utils.objects.extend(Car, engine.Entity);

engine.register_class(Car);

Car.prototype.impact = function(obj, cpoint, direction){
    if(obj.has_tag('car')){
        this.world.play_sound('thud.wav', this.get_position());
    }
};

Car.prototype.cross_finish_line = function(){
    if(this.front_weapon) this.front_weapon.reload();
    if(this.rear_weapon) this.rear_weapon.reload();
    if(this.util) this.util.reload();
};
    
Car.prototype.get_power = function(){
    var power = this.power;
    this.buffs.forEach(function(buff){
        if(buff.effect == buffs.EFFECT_ENGINE){          
            power += buff.value;
        }
    }, this);
    return parseInt(power);
};

Car.prototype.get_max_speed = function(){
    var max_speed=this.max_speed;
    this.buffs.forEach(function(buff){
        if(buff.effect == buffs.EFFECT_ENGINE){
            max_speed += buff.value;
        }
    }, this);
    return parseInt(max_speed + this.mod_speed);
};

Car.prototype.update_checkpoint = function(){
      var cp = this.world.checkpoints[this.next_checkpoint_no];
      var pos = this.get_position();
      if(pos[0] >= cp.pt1[0] && pos[0] <= cp.pt2[0] && pos[1] >= cp.pt1[1] && pos[1] <= cp.pt2[1]){
          if(this.next_checkpoint_no == 1){
             this.lap++;
             this.cross_finish_line();
          }
    
          if(this.next_checkpoint_no == this.world.max_checkpoint){
             this.next_checkpoint_no = 1;
          }
          else{
             this.next_checkpoint_no++;
          }
    
      }
};

Car.prototype.get_race_position = function(){
        var pos = this.world.objects_by_tag['car'].length;
        var i, c;
        //check each car in the race
        for(i = 0; i < this.world.objects_by_tag['car'].length; i++){
            c = this.world.objects_by_tag['car'][i];
            if(!(c === this)){
                //if this cars lap is greater, it is ahead
                if( this.lap > c.lap ){
                    pos--;
                //if this cars lap is equal, but checkpoint is greater, it is ahead
                }else if(this.lap == c.lap && ((this.next_checkpoint_no > c.next_checkpoint_no) || (this.next_checkpoint_no == 1 && c.next_checkpoint_no != 1))){
                    pos--;
                //if this cars lap and checkpoint are equal, but distance to checkpoint is less, it is ahead
                }else if((this.lap == c.lap)&&
                         (this.next_checkpoint_no==c.next_checkpoint_no) &&
                         (vectors.distance(this.alive ? this.get_position() : this.respawn_location, this.world.checkpoints[this.next_checkpoint_no].center) <
                          vectors.distance(c.alive ? c.get_position() : c.respawn_location, this.world.checkpoints[c.next_checkpoint_no].center)) ){
                    pos--;
                }
            }
        }
        return pos;
};

Car.prototype.get_powered_wheels = function(){
    var retv=[];
    this.wheels.forEach(function(wheel){
        if(wheel.parameters.powered) retv.push(wheel);
    });        
    return retv;
};

Car.prototype.get_revolving_wheels = function(){
    var retv = [];
    this.wheels.forEach(function(wheel){
        if(wheel.parameters.revolving) retv.push(wheel);
    });
    return retv;
};

Car.prototype.get_speed_KMH = function(){
    var velocity = this.get_linear_velocity();
    var len=vectors.len(velocity);
    return (len/1000)*3600;
};

Car.prototype.draw = function(renderer){
    if(this.alive && this.active){
        this.wheels.forEach(function(wheel){
            wheel.draw(renderer);
        });
        var bp = this.get_position();
        renderer.drawCar(this.filename, bp, this.get_angle());

        //only draw alias on multiplayer games
        //if(this.alias){
        //    renderer.drawText(this.alias, 'alias', renderer.getScreenPoint([bp[0]-this.width, bp[1]-this.height]));
        //}
    }
};

Car.prototype.teleport=function(position, angle){
    angle= angle ? angle : this.get_angle();
    this.set_position(position);
    this.set_angle(angle);
    this.wheels.forEach(function(wheel){
        wheel.set_position(this.get_world_point(wheel.local_position));
    }, this);
};

Car.prototype.die=function(){
    this.alive = false;
    this.deaths += 1;
    this.time_to_respawn = this.respawn_time;
    this.respawn_location = this.get_position();
    this.world.spawn_animation('explosion', this.get_position());
    this.world.play_sound('explosion.wav', this.get_position());
    this.respawn_angle = this.get_angle();
    this.teleport([0, 0]);
    this.set_linear_velocity([0, 0]);
    this.wheels.forEach(function(wheel){ wheel.die();});
    this.clear_buffs();
};

Car.prototype.respawn = function(){
    this.alive = true;
    this.wheels.forEach(function(wheel){wheel.respawn();});
    this.teleport(this.respawn_location, this.respawn_angle);
    this.health = this.max_health;
};

Car.prototype.kill=function(car){
    this.kills += 1;
};

Car.prototype.apply_damage = function(damage, owner){
	for(var i=0; i< this.buffs.length; i++){
        if(!this.buffs[i].process_hit(damage, owner)) return;
    }
    
    if(this.alive){
        this.health = Math.min(this.health-damage, this.max_health);
        if(this.health <= 0){
            this.die();
            if(owner) owner.kill(this);
        }
    }
};

Car.prototype.update=function(msDuration){
    if(this.active){
        if(this.alive){
            if(this.alive) this.update_alive(msDuration);
        }
        else{
            this.time_to_respawn-=msDuration;
            if(this.time_to_respawn<=0){
                this.respawn();
            }
        }
    }
};

Car.prototype.update_alive = function(msDuration){
    this.update_checkpoint();
    var steer = this.steer;
    var acceleration = this.accelerate;
    var speed = this.get_speed_KMH();
    var local_velocity = this.get_local_vector(this.get_linear_velocity());
    var max_speed = this.get_max_speed();
    
    //go slower backwards
    max_speed = (local_velocity[1] > 0 ? 0.5 * max_speed : max_speed);

    //kill sideways velocity
    if(!this.has_effect(buffs.EFFECT_NO_GRIP)){
        this.wheels.forEach(function(wheel){wheel.kill_sideways_velocity();});
    }

    //SET STEER
    //need to calculate maximum allowed steer angle first
    var max_wheel_angle = this.max_steer_angle;
    //for speed < 100 it is increased, up to 40. This enables the car to make tighter turns at lower speeds
        if(speed<100){
            max_wheel_angle = max_wheel_angle+ (40-max_wheel_angle) * (1 - speed / 100);
        }      
   

    //TURN WHEELS
    var incr = (this.max_steer_angle / this.turn_msec) * msDuration
    var wheels = this.get_revolving_wheels();
    var angle;
    for( i = 0; i < wheels.length; i++) {
        wheel = wheels[i];
        if(steer == STEER_RIGHT) {
            this.cur_wheel_angle = Math.min(Math.max(this.cur_wheel_angle, 0) + incr, max_wheel_angle)
            wheel.set_relative_angle(this.cur_wheel_angle);
        } else if(steer == STEER_LEFT) {
            this.cur_wheel_angle = Math.max(Math.min(this.cur_wheel_angle, 0) - incr, -max_wheel_angle)
            wheel.set_relative_angle(this.cur_wheel_angle);
        } else {
            this.cur_wheel_angle = 0;
            wheel.reset_angle();
        }
    }

    //apply engine force
    var base_vect;
    if((acceleration == ACC_ACCELERATE) && (speed < max_speed)) base_vect = [0, -1];
    else if(acceleration == ACC_BRAKE){
        //braking, lotsa force
        if(this.get_local_velocity()[1] < 0) base_vect = [0, 1.2];
        //reversing, less force
        else base_vect = [0, 0.7];
    }
    else base_vect = [0, 0];
    var fvect = vectors.multiply(base_vect, this.get_power());

    this.get_powered_wheels().forEach(function(wheel){
       wheel.apply_force(fvect, [0, 0]);
    }, this);
    
    //if going very slow, stop - to prevend sliding
    if( (this.get_speed_KMH() < 4) && (acceleration == ACC_NONE)){
        this.set_speed(0);
    }

    //fire weapons
    if(this.front_weapon){
        this.front_weapon.update(msDuration);
        if(this.fire_front_weapon)this.front_weapon._fire();
    }

    if(this.rear_weapon){
        this.rear_weapon.update(msDuration);
        if(this.fire_rear_weapon)this.rear_weapon._fire();
    }
    
    if(this.util){
        this.util.update(msDuration);
        if(this.fire_util)this.util._fire();
    }

    //spawn smoke if health <40
    if(this.health <= 40){
        if(this.smoke_cd <= 0){
            this.world.spawn_animation('smoke', this.get_world_point([0, -1.5]));
            this.smoke_cd = 100;
        }else{
            this.smoke_cd -= msDuration;
        }
    }else this.smoke_cd = 0;
};

Car.prototype.initialize_shape = function(){
    // make the front of the car pointy, so it slides of walls
    var shape = new box2d.b2PolygonShape();
    var w=this.descr.width / 2;
    var h=this.descr.height / 2;
    shape.SetAsArray([vec(w,h),
                    vec(-w,h),
                    vec(-w, -h),
                    vec(0, -h-0.5),
                    vec(w, -h)]);
    return shape;
};

Car.prototype.get_buff = function(effect){
    for(var i = 0; i < this.buffs.length; i++){
        if(this.buffs[i].effect == effect){
            return this.buffs[i];
        }
    }
    return null;
};
    
Car.prototype.has_effect = function(effect){
    for(var i=0; i<this.buffs.length; i++){
        if(this.buffs[i].effect == effect){
            return true;
        }
    }
    return false;
};
    
Car.prototype.clear_buffs = function(){
    this.buffs.forEach(function(buff){
        this.world.destroy(buff);
    }, this);
};

exports.get_car_parameters=function(position, angle, carpars, alias, engine_sound){
  
    var retv = {
        'car_type' : carpars.type,
        'position' : position,
        'angle' : angle,
        'alias' : alias,
        'handling_upgrades' : carpars.handling_upgrades ? carpars.handling_upgrades : 0,
        'engine_sound' : engine_sound,
        'acc_upgrades' : carpars.acc_upgrades,
        'speed_upgrades' : carpars.speed_upgrades,
        'armor_upgrades' : carpars.armor_upgrades,
        'front_weapon' : carpars.front_weapon ? utils.copy(carpars.front_weapon, {}) : null,
        'util' : carpars.util ? utils.copy(carpars.util, {}) : null,
        'rear_weapon' : carpars.rear_weapon ? utils.copy(carpars.rear_weapon, {}) : null
    };

    return retv;
};

},{"./animation":1,"./buffs":3,"./car_descriptions":4,"./combatracer":6,"./engine":9,"./settings":28,"./sounds":30,"./utils":33,"./weapon_descriptions":34,"./weapons":35,"gamejs":37}],6:[function(require,module,exports){
var gamejs = require('gamejs');
var renderer = require('./renderer');
var utils = require('./utils');
var fonts = gamejs.font;
var levels=require('./levels');
var resources = require('./resources');
var weapons=require('./weapons');
var ui=require('./ui');
var uiscenes=require('./uiscenes');
var settings=require('./settings');
var gamescenes=require('./gamescenes');
var sounds=require('./sounds');
var editor=require('./editor');
var garage=require('./garage');
var engine = require('./engine');



var getDefCarDescr=exports.getDefCarDescr=function(car){
    return {'type':car ? car : 'Sandbug',
            'front_weapon':{'type':'Machinegun',
                            'ammo_upgrades':0,
                            'damage_upgrades':0},
            'util':null,
            'rear_weapon':{'type':'MineLauncher',
                            'ammo_upgrades':0,
                            'damage_upgrades':0},
            'acc_upgrades':0,
            'speed_upgrades':0,
            'armor_upgrades':0}
}

exports.image_filenames = [];
exports.sound_filenames = [];

exports.get_preload_list = function(){
    var retv=new Array();
    var i;
    for(i=0;i<resources.cars.length;i++){
        retv[retv.length]='images/cars/'+resources.cars[i];
    }
    for(i=0;i<resources.tiles.length;i++){
        retv[retv.length]='images/tiles/'+resources.tiles[i];
    }
    for(i=0;i<resources.props.length;i++){
        retv[retv.length]='images/props/'+resources.props[i];
    }
    for(i=0;i<resources.animations.length;i++){
        retv[retv.length]='images/animations/'+resources.animations[i];
    }
    for(i=0;i<resources['statics'].length;i++){
        retv[retv.length]='images/static/'+resources['statics'][i];
    }
    for(i=0;i<resources.ui.length;i++){
        retv[retv.length]='images/ui/'+resources.ui[i];
    }
    
    resources.decals.forEach(function(filename){
        retv.push('images/decals/'+filename); 
    });
    
    exports.image_filenames = retv;
    retv = new Array();
    
    if(settings.get('SOUND')){
        resources.sound_fx.forEach(function(filename){
           retv.push('sounds/fx/'+filename); 
        });
        
        //resources.sound_engine.forEach(function(filename){
         //  retv.push('sounds/engine/'+filename); 
        //});
        
        exports.sound_filenames = retv;
    }
    
    
    return exports.image_filenames.concat(exports.sound_filenames);
};

var Director=exports.Director= function Director (display) {
    var onAir = false;
    var activeScene = null;
    this.display=display;
    var last_t;
 
 
    function tick_logic(msDuration){
        if (activeScene && activeScene.update) activeScene.update(msDuration);
    }
 
    function tick_render(msDuration){
        if (activeScene && activeScene.draw) activeScene.draw(display, msDuration);
    }

  
    this.start = function(scene) {
       onAir = true;
       this.replaceScene(scene);
       return;
    };
 
    this.replaceScene = function(scene) {
        if(activeScene && activeScene.destroy) activeScene.destroy(); 
        activeScene = scene;
    };
 
    this.getScene = function() {
       return activeScene;
    };
    
    gamejs.onTick(function(msDuration){
        tick_logic(msDuration);
        tick_render(msDuration);
    });
    gamejs.onEvent(function(evt) {
        if(activeScene && activeScene.handleEvent) activeScene.handleEvent(evt);
    });
     
    
    return this;
};


var Communicator=exports.Communicator=function(game){
    this.game=game;
    this.socket;
    this.next_transaction_id=1;
    this.messages=[];
    this.status='closed';
    

    this.queueMessage=function(cmd, payload){
        /*
        message payload is returned as first argument,
        arg as second payload
        */
        this.messages[this.messages.length]=[cmd, payload ? payload : {}];
        this.send();
    };

    this.send=function(){
        if(this.status=='open'){
            for(var i=0;i<this.messages.length;i++){
                var msg={'cmd':this.messages[i][0],
                         'uid':this.game.player.uid,
                         'payload':this.messages[i][1]};
                msg=JSON.stringify(msg);
                //gamejs.log('sending ', msg);
                this.socket.send(msg);
               // console.log('sent '+msg);
            }
            this.messages=[];
        }else if (this.status=='closed'){
            this.connect();
        }else{
            throw new Error('unknown network status');
        }
    };

    this.connect=function(){
        gamejs.log('Connecting...');
        this.socket = new WebSocket(settings.get('SERVER'), 'banditracer');
        this.status='connecting';
        var self=this;
        this.socket.onopen = function() {self.onopen();};
        this.socket.onmessage = function(m) {self.onmessage(m);};
        this.socket.onclose = function() {self.onclose();};
        this.socket.onerror = function() {self.onerror();};
    };

    this.onopen=function(){
        gamejs.log('Connection established!');
        this.status='open';
        this.send();
    };

    this.onmessage=function(m){
       // console.log('recv '+m.data);
        m=JSON.parse(m.data);
        this.game.director.getScene().handleMessage(m.cmd, m.payload);
    };

    this.onclose=function(){
        this.status='closed';
        console.log(this.error ? 'socket closed on error ' : 'socket closed!');
        this.game.aquainted=false;
        this.game.showTitle();
        this.game.player.uid=null;
        this.game.title_scene.alert(this.error ? 'Socket error, connection closed.' : 'Server closed the connection!');
        this.error=false;
    };

    this.error=false;

    this.onerror=function(){
        this.socket.close();
        this.error=true;
    };
};

exports.init = function() {
    exports.game=new Game();
    return exports.game;
};

var Game = exports.Game = function(){
    this.director=null;
    this.cache=renderer.init();
    if(settings.get('SOUND')){
        engine.initialize_sounds(exports.sound_filenames);
        sounds.init();
    } 
    ui.init();
    this.socket=null;
    this.tried_loading=false;
    this.player={'alias':'Player',
                 'uid':null,
                 'singleplayer':{
                    'balance':settings.get('STARTING_BALANCE'),
                    'difficulty':2,
                    'car':getDefCarDescr(),
                    'league':settings.get('STARTING_LEAGUE'),
                    'completed':false,
                    'completed_tracks':[]
                    }
                };

    this.communicator=null;
    this.acquainted=false; //receved a player id from server?

    this.getCommunicator = function(){
         if(!this.communicator)this.communicator=new Communicator(this);
         return this.communicator;
    };

    this.start = function(display){
        this.display=display;
        this.director=new Director(display);
        this.title_scene=new uiscenes.TitleScene(this, this.cache);
        this.director.start(this.title_scene);
        //this.playLevel(levels.drycircuit, false, true);
    };

    this.showEndGameScene=function(position){
         this.director.replaceScene(new uiscenes.EndRaceScene(this, this.cache, position));
    };

    this.showTitle=function(){
       this.director.replaceScene(this.title_scene);
    };
    
    this.showCongratulations=function(){
        this.director.replaceScene(new uiscenes.CongratulationsScene());
    };

    this.createLobby=function(){
         this.director.replaceScene(new uiscenes.CreateLobbyScene(this, this.cache));
    };

    this.showLobbyList=function(){
         this.director.replaceScene(new uiscenes.JoinLobbyScene(this, this.cache));
    };
    
    this.returnTo=function(){
        if(this.return_to){
            if(this.return_to=='editor'){
                this.return_to='';
                this.showEditor();
                return;
            }
            else if(this.return_to=='singleplayer'){
                this.return_to='';
                this.singleplayer();
                return;
            }
        
        }
        this.showTitle();
        return;
    };

    this.showSPGameOver=function(table, win, scene){
        this.director.replaceScene(new uiscenes.SPGameOverScene(table, win, scene));
    };
    
    this.showEditor=function(){
        if(!this.editor_scene)this.editor_scene= new editor.EditorScene()
        this.director.replaceScene(this.editor_scene);  
    };

    this.joinLobby=function(lobby_id){
        this.director.replaceScene(new uiscenes.LobbyScene(this, this.cache, lobby_id));
    };
    
    this.singleplayer=function(){
         this.director.replaceScene(new uiscenes.SinglePlayerScene(this, this.cache));
    };
    
    this.showGarage=function(player_data){
        this.director.replaceScene(new garage.GarageScene(player_data));
    };
    
    this.showCarDealer=function(player_data){
        this.director.replaceScene(new garage.BuyCarScene(player_data));
    };
    
    //singleplayer garage
    this.showSPGarage=function(){
        this.director.replaceScene(new garage.GarageScene(this.player.singleplayer));
    };

    this.playMultiplayer=function(level){
        this.level_scene=new gamescenes.MultiplayerLevelScene(this, level, this.cache);
        this.director.replaceScene(this.level_scene);
    };

    this.playLevel=function(level, ai_test, return_to){
         this.level_scene=new gamescenes.SingleplayerLevelScene(level, ai_test);
         this.return_to=return_to;
         this.director.replaceScene(new uiscenes.ControlsSplash(this, this.cache, this.level_scene));
    };
    
    this.cacheCarSprites=function(level){
        this.cache.cacheCarSprite('wheel.png');
        this.cache.cacheCarSprite('big_wheel.png');
        level.controllers.forEach(function(controller){
            var car = controller.car;
            this.cache.cacheCarSprite(car.filename);
            ([car.front_weapon, car.rear_weapon, car.util]).forEach(function(weapon){
                if(weapon && weapon.pars.preload){
                    weapon.pars.preload.forEach(function(filename){
                        this.cache.cacheCarSprite(filename);
                    }, this);
                }
            }, this);
        }, this);
    };
    
    this.haveSave=function(){
        if(utils.supports_html5_storage()){
            if(localStorage.getItem('banditracer_save')) return true;
        }
        return false;
    };
    
    this.load=function(){
        if(utils.supports_html5_storage() && localStorage.getItem('banditracer_save')){
            var data = JSON.parse(localStorage.getItem('banditracer_save'));
            this.player.alias = data.alias;
            this.player.singleplayer = data.singleplayer;
            if(!this.player.singleplayer.difficulty)this.player.singleplayer.difficulty = 2;
            return true;
        }
        return false;
    };
    
    this.save=function(){
        if(utils.supports_html5_storage()){
            var data=JSON.stringify({'alias':this.player.alias,
                             'singleplayer':this.player.singleplayer});
            localStorage.setItem('banditracer_save', data);
            return true;
        }
        return false;
    };
};

},{"./editor":8,"./engine":9,"./gamescenes":19,"./garage":20,"./levels":22,"./renderer":26,"./resources":27,"./settings":28,"./sounds":30,"./ui":31,"./uiscenes":32,"./utils":33,"./weapons":35,"gamejs":37}],7:[function(require,module,exports){
var gamejs=require('gamejs');
var vectors=gamejs.utils.vectors;
var utils=require('./utils');
var combatracer=require('./combatracer');
var vec=utils.vec;
var arr=utils.arr;

var vectors = gamejs.utils.vectors;
var math = gamejs.utils.math;
radians=math.radians;
degrees=math.degrees;

var STEER_NONE=exports.STEER_NONE=0;
var STEER_RIGHT=exports.STEER_RIGHT=1;
var STEER_LEFT=exports.STEER_LEFT=2;

var ACC_NONE=exports.ACC_NONE=0;
var ACC_ACCELERATE=exports.ACC_ACCELERATE=1;
var ACC_BRAKE=exports.ACC_BRAKE=2;

var DIFFICULTY={1:{'FIRE_CHANCE':0.20,
                   'MAX_SPEED_BUFF':0,
                   'MAX_SPEED_DEBUFF':30},
             	2:{'FIRE_CHANCE':0.5,
                   'MAX_SPEED_BUFF':10,
                   'MAX_SPEED_DEBUFF':25},
                3:{'FIRE_CHANCE':0.6,
                   'MAX_SPEED_BUFF':20,
                   'MAX_SPEED_DEBUFF':10},
                4:{'FIRE_CHANCE':0.6,
                   'MAX_SPEED_BUFF':20,
                   'MAX_SPEED_DEBUFF':10}}

exports.AIController=function(car, world, scene){
    car.max_steer_angle = car.max_steer_angle*1.1;
    car.turn_msec=50;
    this.difficulty=DIFFICULTY[combatracer.game.player.singleplayer.difficulty];
    this.scene = scene;
    this.car = car;
    this.world = world;
    this.cur_wp = 1;
    this.ceasfire = false;
    this.ceasfire_cur_cooldown = 0;
    this.ceasfire_cooldown = 1000;
    
    this.stationary=0; //how many seconds is this car stationary?
    
    this.update=function(keys_down, ms){
        if(!this.car.alive)return;
         this.car.accelerate=ACC_ACCELERATE;
        var wp = this.world.ai_waypoints[this.cur_wp];
        var nwp = this.world.ai_waypoints[this.cur_wp < this.world.max_waypoint ? this.cur_wp + 1 : 1];

        var speed=this.car.get_speed_KMH();

        //cheats
        var player_pos = this.scene.player_car.get_race_position();
        var mypos = this.car.get_race_position();

        //if player is ahead, gradually increase speed to up to extra 10 km/h
        if(player_pos < mypos){
            if(car.mod_speed < this.difficulty.MAX_SPEED_BUFF){
                car.mod_speed += 5*(ms/1000);
            }
        }else if(player_pos > mypos){
            //if car is ahead, gradually decrease speed down to -25 km/h
            if(car.mod_speed > -this.difficulty.MAX_SPEED_DEBUFF){
                car.mod_speed -= 5 * (ms / 1000);
            }
        }

        //if car speed is below 6 km/h for 3 seconds, most likely it is stuck. teleport it to next waypoint
        if(speed < 6){
            if(this.car.alive){
                this.stationary += ms;
                if(this.stationary > 3000){
                    this.car.teleport([wp.x, wp.y]);
                    this.stationary=0;
                }
            }else {this.stationary=0;}
        }
        else this.stationary=0;

        var carpos = this.car.get_position();
        var lp = this.car.get_local_point([wp.x, wp.y]);
        var len=vectors.distance(carpos, [wp.x, wp.y]);
        var len2=vectors.distance(carpos, [nwp.x, nwp.y]);

        /*switch to next waypont if :
          1)closer than 5 meters to it
          2)it is behind the car, but closer than 35 meters
        */
        var angle = gamejs.utils.math.normaliseDegrees(degrees(vectors.angle([0, -1], lp)));

        if(len < 10 || (lp[1] > 0 && len < 35)){
            if(this.cur_wp < this.world.max_waypoint) this.cur_wp++;
            else this.cur_wp = 1;
            wp =this.world.ai_waypoints[this.cur_wp];
        }
        if(angle > 10){
            if(lp[0] > 0)this.car.steer=STEER_RIGHT;
            else this.car.steer = STEER_LEFT;
        } else this.car.steer = STEER_NONE;

        //is this bot shooting?
        if(this.ceasfire_cur_cooldown <= 0){
            this.ceasfire = Math.random() >this.difficulty.FIRE_CHANCE ? true : false;
            this.ceasfire_cur_cooldown = this.ceasfire_cooldown;
        }else{
            this.ceasfire_cur_cooldown-= ms;
        }
        
        //fire weapons if needed        
        (['front_weapon', 'util', 'rear_weapon']).forEach(function(wtype){
            if(this.car[wtype]) this.car['fire_'+wtype] = this.ceasfire ? false : this.car[wtype].AI();
        }, this);
    }

    return this;
}

exports.MultiplayerController=function(){
    this.bindings={accelerate:gamejs.event.K_UP, //up
                   brake:gamejs.event.K_DOWN,      //down
                   steer_left:gamejs.event.K_LEFT, //left
                   steer_right:gamejs.event.K_RIGHT, //right
                   fire_front_weapon:gamejs.event.K_x, //fire front weapon
                   fire_rear_weapon:gamejs.event.K_v,
                   fire_util:gamejs.event.K_c}; //fire rear weapon

    this.actions={'accelerate':ACC_NONE,
                  'steer':STEER_NONE,
                  'fire_front_weapon':false,
                  'fire_rear_weapon':false,
                  'fire_util':false};


    this.update=function(keys_down, ms){
        var changed=false;

        var accelerate, steer, fire_front_weapon, fire_rear_weapon, fire_util;

        if(keys_down[this.bindings.accelerate]){
            accelerate=ACC_ACCELERATE;
        }else if(keys_down[this.bindings.brake]){
            accelerate=ACC_BRAKE;
        }else{
            accelerate=ACC_NONE;
        }

        if(keys_down[this.bindings.steer_right]){
            steer=STEER_RIGHT;
        }else if(keys_down[this.bindings.steer_left]){
            steer=STEER_LEFT;
        }else{
            steer=STEER_NONE;
        }

        if(keys_down[this.bindings.fire_front_weapon]) fire_front_weapon=true;
        else fire_front_weapon=false;

        if(keys_down[this.bindings.fire_rear_weapon]) fire_rear_weapon=true;
        else fire_rear_weapon=false;
        
        if(keys_down[this.bindings.util]) fire_util=true;
        else fire_util=false;

        if(!(accelerate===this.actions.accelerate)){
            this.actions.accelerate=accelerate;
            changed=true;
        }
        if(!(steer===this.actions.steer)){
            this.actions.steer=steer;
            changed=true;
        }
        if(!(fire_front_weapon===this.actions.fire_front_weapon)){
            this.actions.fire_front_weapon=fire_front_weapon;
            changed=true;
        }
        if(!(fire_rear_weapon===this.actions.fire_rear_weapon)){
            this.actions.fire_rear_weapon=fire_rear_weapon;
            changed=true;
        }
        if(!(fire_util===this.actions.fire_util)){
            this.actions.fire_util=fire_util;
            changed=true;
        }
        return changed;

    };

    return this;

};

exports.PlayerCarController=function(car){
    this.car=car;
    this.bindings={accelerate:gamejs.event.K_UP, //up
                   brake:gamejs.event.K_DOWN,      //down
                   steer_left:gamejs.event.K_LEFT, //left
                   steer_right:gamejs.event.K_RIGHT, //right
                   fire_front_weapon:gamejs.event.K_x, //fire front weapon
                   fire_rear_weapon:gamejs.event.K_v,
                   fire_util:gamejs.event.K_c}; //fire rear weapon

    this.update=function(keys_down, ms){
        if(!this.car.alive)return;
        if(keys_down[this.bindings.accelerate]){
            this.car.accelerate=ACC_ACCELERATE;
        }else if(keys_down[this.bindings.brake]){
            this.car.accelerate=ACC_BRAKE;
        }else{
            this.car.accelerate=ACC_NONE;
        }

        if(keys_down[this.bindings.steer_right]){
            this.car.steer=STEER_RIGHT;
        }else if(keys_down[this.bindings.steer_left]){
            this.car.steer=STEER_LEFT;
        }else{
            this.car.steer=STEER_NONE;
        }

        if(keys_down[this.bindings.fire_front_weapon]) this.car.fire_front_weapon=true;
        else this.car.fire_front_weapon=false;

        if(keys_down[this.bindings.fire_rear_weapon]) this.car.fire_rear_weapon=true;
        else this.car.fire_rear_weapon=false;
        
        if(keys_down[this.bindings.fire_util]) this.car.fire_util=true;
        else this.car.fire_util=false;

    };

    return this;
};

},{"./combatracer":6,"./utils":33,"gamejs":37}],8:[function(require,module,exports){
var GUI = require('./gamejs-gui');
var ui = require('./ui');
var combatracer = require('./combatracer');
var settings=require('./settings');
var gamejs=require('gamejs');
var renderer=require('./renderer');
var resources=require('./resources');
var skin=require('./skin');

var EXAMPLE='{"size":[2100,1100],"title":"Example Raceway","bgtile":"sand.png","props":[{"p":[413,159],"f":1,"a":270},{"p":[687,158],"f":1,"a":270},{"p":[960,157],"f":1,"a":270},{"p":[310,259],"f":2,"a":240},{"p":[283,350],"f":2,"a":180},{"p":[282,442],"f":2,"a":180},{"p":[283,515],"f":2,"a":150},{"p":[360,579],"f":2,"a":105},{"p":[469,596],"f":2,"a":90},{"p":[561,596],"f":2,"a":90},{"p":[654,596],"f":2,"a":90},{"p":[706,561],"f":2,"a":15},{"p":[725,475],"f":2,"a":15},{"p":[768,388],"f":2,"a":225},{"p":[857,355],"f":2,"a":75},{"p":[957,261],"f":1,"a":270},{"p":[1232,352],"f":2,"a":90},{"p":[1321,351],"f":2,"a":90},{"p":[1310,276],"f":2,"a":330},{"p":[1238,278],"f":3,"a":0},{"p":[1272,278],"f":3,"a":0},{"p":[1307,282],"f":3,"a":0},{"p":[1608,587],"f":2,"a":270},{"p":[1704,586],"f":2,"a":270},{"p":[1577,628],"f":2,"a":150},{"p":[1669,686],"f":2,"a":90},{"p":[1729,626],"f":2,"a":45},{"p":[1802,618],"f":3,"a":0},{"p":[1103,-73],"f":1,"a":270},{"p":[832,-74],"f":1,"a":270},{"p":[562,-73],"f":1,"a":270},{"p":[1367,19],"f":2,"a":285},{"p":[1449,49],"f":2,"a":300},{"p":[1516,115],"f":2,"a":330},{"p":[1558,204],"f":2,"a":345},{"p":[1578,304],"f":2,"a":0},{"p":[1610,361],"f":2,"a":270},{"p":[1702,359],"f":2,"a":270},{"p":[1794,359],"f":2,"a":270},{"p":[1877,359],"f":2,"a":285},{"p":[1943,410],"f":2,"a":330},{"p":[1988,498],"f":2,"a":345},{"p":[2006,598],"f":2,"a":0},{"p":[1992,685],"f":2,"a":15},{"p":[1956,767],"f":2,"a":30},{"p":[1901,839],"f":2,"a":45},{"p":[1833,894],"f":2,"a":75},{"p":[1752,921],"f":2,"a":90},{"p":[1660,927],"f":2,"a":90},{"p":[1557,909],"f":2,"a":105},{"p":[1462,870],"f":2,"a":120},{"p":[1389,810],"f":2,"a":135},{"p":[1352,738],"f":2,"a":165},{"p":[1349,655],"f":2,"a":180},{"p":[1380,622],"f":3,"a":0},{"p":[1352,612],"f":3,"a":0},{"p":[1080,493],"f":1,"a":270},{"p":[988,585],"f":2,"a":90},{"p":[953,645],"f":2,"a":0},{"p":[913,717],"f":2,"a":30},{"p":[853,783],"f":2,"a":60},{"p":[781,826],"f":2,"a":90},{"p":[503,739],"f":1,"a":270},{"p":[410,828],"f":2,"a":90},{"p":[320,825],"f":2,"a":90},{"p":[219,802],"f":2,"a":105},{"p":[133,754],"f":2,"a":135},{"p":[75,689],"f":2,"a":150},{"p":[45,613],"f":2,"a":165},{"p":[-42,349],"f":1,"a":0},{"p":[48,257],"f":2,"a":180},{"p":[53,154],"f":2,"a":210},{"p":[106,74],"f":2,"a":225},{"p":[182,24],"f":2,"a":240},{"p":[289,21],"f":2,"a":270},{"p":[383,19],"f":2,"a":270},{"p":[472,18],"f":2,"a":270}],"decals":[{"p":[114,84],"f":4,"a":0},{"p":[426,36],"f":5,"a":0},{"p":[714,36],"f":5,"a":0},{"p":[1002,36],"f":5,"a":0},{"p":[1290,84],"f":4,"a":90},{"p":[1386,396],"f":6,"a":0},{"p":[1410,636],"f":4,"a":270},{"p":[1716,636],"f":4,"a":180},{"p":[1812,420],"f":7,"a":90},{"p":[1668,420],"f":8,"a":90},{"p":[1578,420],"f":8,"a":90},{"p":[1194,420],"f":9,"a":90},{"p":[1002,420],"f":9,"a":90},{"p":[786,420],"f":7,"a":0},{"p":[762,636],"f":7,"a":180},{"p":[474,612],"f":5,"a":0},{"p":[114,540],"f":4,"a":270},{"p":[114,402],"f":8,"a":180},{"p":[114,342],"f":8,"a":180},{"p":[378,660],"f":8,"a":270},{"p":[1446,372],"f":10,"a":90},{"p":[1524,372],"f":10,"a":90},{"p":[1614,450],"f":10,"a":180},{"p":[1614,540],"f":10,"a":180},{"p":[1062,90],"f":11,"a":90},{"p":[1062,168],"f":11,"a":90},{"p":[1014,102],"f":12,"a":90},{"p":[924,210],"f":12,"a":90},{"p":[822,102],"f":12,"a":90},{"p":[720,210],"f":12,"a":90},{"p":[600,102],"f":12,"a":90},{"p":[480,210],"f":12,"a":90}],"ai_waypoints":[{"p":[1362,212],"n":1},{"p":[1492,504],"n":2},{"p":[1559,750],"n":3},{"p":[928,554],"n":6},{"p":[1849,727],"n":4},{"p":[1814,544],"n":5},{"p":[1109,443],"n":6},{"p":[739,675],"n":7},{"p":[343,688],"n":8},{"p":[228,463],"n":9},{"p":[237,277],"n":10},{"p":[444,186],"n":11}],"checkpoints":[{"p":[1107,45],"n":1},{"p":[1377,648],"n":2},{"p":[1763,409],"n":3},{"p":[787,413],"n":4},{"p":[118,577],"n":5},{"p":[167,67],"n":6}],"start_positions":[{"p":[965,95],"n":1,"a":90},{"p":[872,203],"n":2,"a":90},{"p":[771,98],"n":3,"a":90},{"p":[668,206],"n":4,"a":90},{"p":[546,94],"n":5,"a":90},{"p":[426,202],"n":6,"a":90}],"dict":{"1":"9tires.png","2":"3tires.png","3":"tire.png","4":"dideliskampas.png","5":"ilgas.png","6":"kryzius.png","7":"lenktas.png","8":"trumpas.png","9":"paprastas.png","10":"arrow.png","11":"startbar.png","12":"white_bar.png"}}';
var LEFT_PANEL_WIDTH=200;
var BOT_PANEL_HEIGHT=150;
var CHECKPOINT_SIZE=[280, 280];
var MIN_DIMENSION=1000;
var DIMENSION_INCREMENT=100;
var LOAD_HELP_TEXT='To save, copy level code below and save it as a text file on your computer or however is convenient. To load, paste level code into textarea below and click "load".';

var instance_id=1;

function snap(pos){
    return [Math.floor(pos[0]/6)*6,
            Math.floor(pos[1]/6)*6];
};

var drawqueue=['decalinstance', 'propinstance', 'checkpointinstance', 'startpositioninstance', 'aiwaypointinstance'];

var getLevelTemplate=function(size){
    return {'size':size,
            'title':'New track',
            'bgtile':'sand.png',
            'props':[],
            'decals':[],
            'laps':3,
            'ai_waypoints':[],
            'checkpoints':[],
            'start_positions':[]};
            
};



function getLevelProblems(level){
    //validation, returns list of problems (strings), if list empty, level is ok
    var problems=[];
    if(level.start_positions.length<6){
        problems.push('All six starting positions must be placed.');
    }
    if(level.ai_waypoints.length<2){
        problems.push('At least two AI waypoints must be placed.');
    }
    if(level.checkpoints.length<2){
        problems.push('At least two checkpoints must be placed.');
    }
    if(!level.title){
        problems.push('Level must have a title.');
    }
    console.log(problems);
    return problems;
};

function structifyLevel(level){
    var retv=getLevelTemplate([2500, 2500]);
    retv.size=level.size;
    retv.bgtile=level.bgtile;
    retv.title=level.title;
    retv.laps=level.laps;
    retv.dict={};
    var revdict={};
    var i=1;
    function trans(x){
        if(revdict[x]==undefined){
            revdict[x]=i;
            retv.dict[i]=x;
            i++;
        }
        return revdict[x];
    }
    level.props.forEach(function(prop){
       retv.props.push({'p':prop.position,
                       'f':trans(prop.original.filename),
                       'a':prop.angle});
    });
    
    level.decals.forEach(function(decal){
       retv.decals.push({'p':decal.position,
                       'f':trans(decal.original.filename),
                       'a':decal.angle});
    });
    
    level.ai_waypoints.forEach(function(wp){
        retv.ai_waypoints.push({'p':wp.position,
                               'n':wp.number});
    });
    
    level.checkpoints.forEach(function(cp){
        retv.checkpoints.push({'p':cp.position,
                              'n':cp.number});
    });
    
    level.start_positions.forEach(function(sp){
        retv.start_positions.push({'p':sp.position,
                              'n':sp.number,
                              'a':sp.angle});
    });
    return retv;
};

function stringifyLevel(level){
    return JSON.stringify(structifyLevel(level));
};



ToolViewSelectItem=exports.ToolViewSelectItem=function(pars){
    pars.size=[LEFT_PANEL_WIDTH, 22];
    this.what=pars.what;
    ToolViewSelectItem.superConstructor.apply(this, [pars]);
    this.label=new GUI.Label({'position':[0, 0],
                         'parent':this,
                         'font':ui.getFont(skin.track_selector.item_font),
                         'text':pars.text});
    this.center(this.label);
    this.label.move([this.size[0]-this.label.size[0]-16, this.label.position[1]]);
    this.selected=false;
    this.on(GUI.EVT_MOUSE_DOWN, this.select, this);
};

gamejs.utils.objects.extend(ToolViewSelectItem, GUI.View);

ToolViewSelectItem.prototype.select=function(){
    this.selected=true;
    this.refresh();
    this.despatchEvent({'type':'select', 'what':this.what});
};

ToolViewSelectItem.prototype.deselect=function(){
    this.selected=false;
    this.refresh();
};

ToolViewSelectItem.prototype.paint=function(){
    this.surface.fill(this.selected ? skin.track_selector.front_color : this.isHovered() ? skin.track_selector.item_hover_color : skin.track_selector.back_color);
};

var ToolView=exports.ToolView=function(pars){
    ToolView.superConstructor.apply(this, [pars]);
    this.scene=pars.scene;
    
    this.scw=new GUI.ScrollableView({'parent':this,
                                    'size':[this.size[0], this.size[1]-20],
                                    'position':[0, 0]});

    var scb=new GUI.HorizontalScrollbar({'parent':this,
                                        'size':[this.size[0], 20],
                                        'position':[0, this.size[1]-20]});
    this.scw.setHorizontalScrollbar(scb);
};
gamejs.utils.objects.extend(ToolView, GUI.View);

var DecalView=exports.DecalView=function(pars){
    DecalView.superConstructor.apply(this, [pars]);
    this.filename_to_decal={};
    resources.decals.forEach(function(filename){
        var tool=new Decal({'filename':filename,
                           'size':[100, 100],
                           'position':[0, 3],
                           'scene':this.scene,
                           'parent':this.scw});
        this.scene.tools.push(tool);
        this.filename_to_decal[filename]=tool;
        tool.on('select', this.scene.selectTool, this.scene);
    }, this);
    GUI.layout.horizontal(this.scw.children, 2, 2);
    this.scw.autoSetScrollableArea();
};

gamejs.utils.objects.extend(DecalView, ToolView);

//MARKER VIEW

var MarkerView=exports.MarkerView=function(pars){
    this.scene=pars.scene;
    MarkerView.superConstructor.apply(this, [pars]);
    var lbl1=new GUI.Label({'parent':this,
                           'font':ui.getFont('16_33'),
                           'text':'AI Waypoints',
                           'position':[20, 2]});
    
    
    //ai waypoint
    this.ai_waypoint=new AIWaypoint({'parent':this,
                                     'position':[40, 45],
                                     'size':[40, 40],
                                     'scene':this.scene});
    this.scene.tools.push(this.ai_waypoint);
    this.ai_waypoint.on('select', this.scene.selectTool, this.scene);
    
    this.ai_waypoint_up=new ui.IncrementButton({'direction':'up',
                                            'position':[100, 30],
                                            'size':[40, 30],
                                            'parent':this});
    
    this.ai_waypoint_up.onClick(function(){
        this.setNumber(this.number+1);
    }, this.ai_waypoint);
    
    this.ai_waypoint_down=new ui.IncrementButton({'direction':'down',
                                                'position':[100, 70],
                                                'size':[40, 30],
                                                'parent':this});
    
    this.ai_waypoint_down.onClick(function(){
        this.setNumber(this.number-1);
    }, this.ai_waypoint);
    
    //checkpoint
    var lbl2=new GUI.Label({'parent':this,
                           'font':ui.getFont('16_33'),
                           'text':'Checkpoints',
                           'position':[150, 2]});
    
    
    this.checkpoint=new Checkpoint({'parent':this,
                                     'position':[170, 45],
                                     'size':[170, 40],
                                     'scene':this.scene});
    this.scene.tools.push(this.checkpoint);
    this.checkpoint.on('select', this.scene.selectTool, this.scene);
    
    this.checkpoint_up=new ui.IncrementButton({'direction':'up',
                                            'position':[230, 30],
                                            'size':[40, 30],
                                            'parent':this});
    
    this.checkpoint_up.onClick(function(){
        this.setNumber(this.number+1);
    }, this.checkpoint);
    
    this.checkpoint_down=new ui.IncrementButton({'direction':'down',
                                                'position':[230, 70],
                                                'size':[40, 30],
                                                'parent':this});
    
    this.checkpoint_down.onClick(function(){
        this.setNumber(this.number-1);
    }, this.checkpoint);
    
    //start position
    var lbl3=new GUI.Label({'parent':this,
                           'font':ui.getFont('16_33'),
                           'text':'Start Positions',
                           'position':[280, 2]});
    
    
    this.start_position=new StartPosition({'parent':this,
                                     'position':[300, 35],
                                     'size':[60, 60],
                                     'scene':this.scene});
    this.scene.tools.push(this.start_position);
    this.start_position.on('select', this.scene.selectTool, this.scene);
    
    this.start_position_up=new ui.IncrementButton({'direction':'up',
                                            'position':[370, 30],
                                            'size':[40, 30],
                                            'parent':this});
    
    this.start_position_up.onClick(function(){
        this.setNumber(this.number+1);
    }, this.start_position);
    
    this.start_position_down=new ui.IncrementButton({'direction':'down',
                                                'position':[370, 70],
                                                'size':[40, 30],
                                                'parent':this});
    
    this.start_position_down.onClick(function(){
        this.setNumber(this.number-1);
    }, this.start_position);
    
    
};

gamejs.utils.objects.extend(MarkerView, GUI.View)

//PROPERTIES VIEW
var PropertiesView=exports.PropertiesView=function(pars){
    PropertiesView.superConstructor.apply(this, [pars]);
    this.scene=pars.scene;
    var lbl=new GUI.Label({'parent':this.scw,
                    'font':ui.getFont('16_33'),
                    'text':'Title',
                    'position':[100, 2]});
    
    this.title=new GUI.TextInput({'parent':this.scw,
                                 'font':ui.getFont('16_33'),
                                 'text':this.scene.level.title,
                                 'position':[40, 50],
                                 'size':[180, 30]});
    
    this.title.on(GUI.EVT_CHANGE, this.titleChange, this);
    
    new GUI.Label({'parent':this.scw,
                    'font':ui.getFont('16_33'),
                    'text':'Width, PX',
                    'position':[260, 2]});
    
    this.widthlbl=new GUI.Label({'parent':this.scw,
                                'font':ui.getFont('16_33'),
                                'text':String(this.scene.level.size[0]),
                                'position':[260, 50]});
    
    this.width_up_btn=new ui.IncrementButton({'parent':this.scw,
                                          'position':[350, 20],
                                          'size':[40, 40],
                                          'direction':'up'});
    
    this.width_up_btn.onClick(function(){
        this.scene.level.size[0]=Math.max(MIN_DIMENSION, this.scene.level.size[0]+DIMENSION_INCREMENT);
        this.scene.resizeLevelView();
    }, this);
    
    this.width_down_btn=new ui.IncrementButton({'parent':this.scw,
                                          'position':[350, 70],
                                          'size':[40, 40],
                                          'direction':'down'});
    
    this.width_down_btn.onClick(function(){
        this.scene.level.size[0]=Math.max(MIN_DIMENSION, this.scene.level.size[0]-DIMENSION_INCREMENT);
        this.scene.resizeLevelView();
    }, this);
    
    
    new GUI.Label({'parent':this.scw,
                    'font':ui.getFont('16_33'),
                    'text':'Height, PX',
                    'position':[420, 2]});
    
    this.heightlbl=new GUI.Label({'parent':this.scw,
                                'font':ui.getFont('16_33'),
                                'text':String(this.scene.level.size[1]),
                                'position':[420, 50]});
    
    this.height_up_btn=new ui.IncrementButton({'parent':this.scw,
                                          'position':[520, 20],
                                          'size':[40, 40],
                                          'direction':'up'});
    
    this.height_up_btn.onClick(function(){
        this.scene.level.size[1]=Math.max(MIN_DIMENSION, this.scene.level.size[1]+DIMENSION_INCREMENT);
        this.scene.resizeLevelView();
    }, this);
    
    this.height_down_btn=new ui.IncrementButton({'parent':this.scw,
                                          'position':[520, 70],
                                          'size':[40, 40],
                                          'direction':'down'});
    this.height_down_btn.onClick(function(){
        this.scene.level.size[1]=Math.max(MIN_DIMENSION, this.scene.level.size[1]-DIMENSION_INCREMENT);
        this.scene.resizeLevelView();
    }, this);
    
    
    new GUI.Label({'parent':this.scw,
                    'font':ui.getFont('16_33'),
                    'text':'Laps',
                    'position':[590, 2]});
    
    this.lapslbl=new GUI.Label({'parent':this.scw,
                                'font':ui.getFont('16_33'),
                                'text':String(this.scene.level.laps),
                                'position':[600, 50]});
    
    this.laps_up_btn=new ui.IncrementButton({'parent':this.scw,
                                          'position':[700, 20],
                                          'size':[40, 40],
                                          'direction':'up'});
    
    this.laps_up_btn.onClick(function(){
        this.scene.level.laps=Math.max(1, this.scene.level.laps+1);
        this.lapslbl.setText(String(this.scene.level.laps));
    }, this);
    
    this.laps_down_btn=new ui.IncrementButton({'parent':this.scw,
                                          'position':[700, 70],
                                          'size':[40, 40],
                                          'direction':'down'});
    this.laps_down_btn.onClick(function(){
        this.scene.level.laps=Math.max(1, this.scene.level.laps-1);
        this.lapslbl.setText(String(this.scene.level.laps));
    }, this);
    
    this.scw.autoSetScrollableArea();
    
    
}
gamejs.utils.objects.extend(PropertiesView, ToolView)

PropertiesView.prototype.titleChange=function(event){
    this.scene.level.title=event.value;  
};

//PROP VIEW

var PropView=exports.PropView=function(pars){
    PropView.superConstructor.apply(this, [pars]);
    this.filename_to_prop={};
    resources.props.forEach(function(filename){
        var tool=new Prop({'filename':filename,
                           'size':[100, 100],
                           'position':[0, 3],
                           'scene':this.scene,
                           'parent':this.scw});
        this.scene.tools.push(tool);
        this.filename_to_prop[filename]=tool;
        tool.on('select', this.scene.selectTool, this.scene);
    }, this);
    GUI.layout.horizontal(this.scw.children, 2, 2);
    this.scw.autoSetScrollableArea();
};

gamejs.utils.objects.extend(PropView, ToolView);

//LAYER VIEW

var LayerView=exports.LayerView=function(pars){
    LayerView.superConstructor.apply(this, [pars]);
    
    new GUI.Label({'parent':this.scw,
                    'font':ui.getFont('16_33'),
                    'text':'Decals',
                    'position':[10, 2]});
    
    new LayerOnOffBtn({'parent':this.scw,
                      'layer':'decals',
                      'scene':this.scene,
                      'position':[10, 50]});
    
    new GUI.Label({'parent':this.scw,
                    'font':ui.getFont('16_33'),
                    'text':'Props',
                    'position':[160, 2]});
    
    new LayerOnOffBtn({'parent':this.scw,
                      'layer':'props',
                      'scene':this.scene,
                      'position':[160, 50]});
    
    new GUI.Label({'parent':this.scw,
                    'font':ui.getFont('16_33'),
                    'text':'AI Waypoints',
                    'position':[320, 2]});
    
    new LayerOnOffBtn({'parent':this.scw,
                      'layer':'ai_waypoints',
                      'scene':this.scene,
                      'position':[320, 50]});
    
    new GUI.Label({'parent':this.scw,
                    'font':ui.getFont('16_33'),
                    'text':'Checkpoints',
                    'position':[470, 2]});
    
    new LayerOnOffBtn({'parent':this.scw,
                      'layer':'checkpoints',
                      'scene':this.scene,
                      'position':[470, 50]});
    
    new GUI.Label({'parent':this.scw,
                    'font':ui.getFont('16_33'),
                    'text':'Start pos.',
                    'position':[620, 2]});
    
    new LayerOnOffBtn({'parent':this.scw,
                      'layer':'start_positions',
                      'scene':this.scene,
                      'position':[620, 50]});
    
    
    
    this.scw.autoSetScrollableArea();
};

gamejs.utils.objects.extend(LayerView, ToolView);

//BGVIEW

var BgView=exports.BgView=function(pars){
    BgView.superConstructor.apply(this, [pars]);
    resources.tiles.forEach(function(filename){
        var tool=new BackgroundTile({'filename':filename,
                                    'size':[100, 100],
                                    'position':[0, 3],
                                    'scene':this.scene,
                                    'parent':this.scw});
    }, this);
    GUI.layout.horizontal(this.scw.children, 2, 2);
    this.scw.autoSetScrollableArea();
};

gamejs.utils.objects.extend(BgView, ToolView);


var Instance=exports.Instance=function(pars){
    Instance.superConstructor.apply(this, [pars]);
    this.instance_id=instance_id++;
    this.angle=pars.angle;
    this.original=pars.original;
    this.subtype='instance';
    this.selected=false;
    this.scene=pars.scene;
    this.on(GUI.EVT_MOUSE_DOWN, this.select, this);
    this.on('select', this.scene.selectInstance, this.scene);
};
gamejs.utils.objects.extend(Instance, GUI.View);

Instance.prototype.select=function(){
    if(!this.selected){
        if(!(this.scene.selected && this.scene.selected.subtype=='tool')){
            this.selected=true;
            this.despatchEvent({'type':'select', 'instance':this});
            this.refresh();
        }
    }
};

Instance.prototype.move=function(pos){
  if(this.selected) GUI.View.prototype.move.apply(this, [pos]);  
};

function removeInstance(instance, list){
    for(var i=0;i<list.length;i++){
        if(list[i].instance_id==instance.instance_id){
            list.splice(i, 1);
            return;
        }
    }
};

Instance.prototype.deselect=function(){
    this.selected=false;
    this.refresh();
};

Instance.prototype.paint=function(){
    this.surface.clear();
    var img=this.original.getCursorImage(this.angle);
    this.surface.blit(img, [(this.size[0]-img.getSize()[0])/2, (this.size[1]-img.getSize()[1])/2]);
    if(this.selected){
        gamejs.draw.rect(this.surface, '#0026FF', new gamejs.Rect([0, 0], this.surface.getSize()), 6);
    }
};

var CheckpointInstance=function(pars){
    CheckpointInstance.superConstructor.apply(this, [pars]);
    GUI.draggable(this);
    this.type='checkpointinstance';
    this.number=pars.number;
      this.on('select', function(){
        this.scene.marker_view.checkpoint.setNumber(this.number);
    }, this);  
};

gamejs.utils.objects.extend(CheckpointInstance, Instance);

CheckpointInstance.prototype.destroy=function(recalc){
    if(recalc===undefined)recalc=true;
    Instance.prototype.destroy.apply(this, []);
    if(recalc){
        removeInstance(this, this.scene.level.checkpoints);
        this.scene.level.checkpoints.forEach(function(cp){
            if(cp.number>this.number){
                cp.number--;
                cp.refresh();
            }
        }, this);
    }
};

CheckpointInstance.prototype.paint=function(){
    this.surface.clear();
    this.surface.blit(this.original.genHugeImage(this.number), [0, 0]);
    if(this.selected){
        gamejs.draw.rect(this.surface, '#0026FF', new gamejs.Rect([0, 0], this.surface.getSize()), 6);
    }
};

//START POSITION INSTANCE
var StartPositionInstance=function(pars){
    StartPositionInstance.superConstructor.apply(this, [pars]);
   // GUI.draggable(this);
    this.type='startpositioninstance';
    this.number=pars.number;
      this.on('select', function(){
        this.scene.marker_view.start_position.setNumber(this.number);
    }, this);
    
};

gamejs.utils.objects.extend(StartPositionInstance, Instance);

StartPositionInstance.prototype.move=function(pos){
  Instance.prototype.move.apply(this, [snap(pos)]);  
};

StartPositionInstance.prototype.destroy=function(recalc){
    
    if(recalc===undefined)recalc=true;
    Instance.prototype.destroy.apply(this, []);
    if(recalc){
        removeInstance(this, this.scene.level.start_positions);
        this.scene.level.start_positions.forEach(function(sp){
            if(sp.number>this.number){
                sp.number--;
                sp.refresh();
            }
        }, this);
    }
};

StartPositionInstance.prototype.paint=function(){
    this.surface.clear();
    this.surface.blit(this.original.genImage(this.number, this.angle), [0, 0]);
    if(this.selected){
        gamejs.draw.rect(this.surface, '#0026FF', new gamejs.Rect([0, 0], this.surface.getSize()), 6);
    }
};

//AI WAYPOINT INSTANCE
var AIWaypointInstance=function(pars){
    AIWaypointInstance.superConstructor.apply(this, [pars]);
    GUI.draggable(this);
    this.type='aiwaypointinstance';
    this.number=pars.number;
      this.on('select', function(){
        this.scene.marker_view.ai_waypoint.setNumber(this.number);
    }, this);
    
};

gamejs.utils.objects.extend(AIWaypointInstance, Instance);

AIWaypointInstance.prototype.destroy=function(recalc){
    if(recalc===undefined)recalc=true;
    Instance.prototype.destroy.apply(this, []);
    if(recalc){
        removeInstance(this, this.scene.level.ai_waypoints);
        this.scene.level.ai_waypoints.forEach(function(wp){
            if(wp.number==this.number) recalc=false;
        }, this);
        if(recalc){
            this.scene.level.ai_waypoints.forEach(function(wp){
                if(wp.number>this.number){
                    wp.number--;
                    wp.refresh();
                }
            }, this);
        }
    }
};

AIWaypointInstance.prototype.paint=function(){
    this.surface.clear();
    this.surface.blit(this.original.genImage(this.number), [0, 0]);
    if(this.selected){
        gamejs.draw.rect(this.surface, '#0026FF', new gamejs.Rect([0, 0], this.surface.getSize()), 6);
    }
};

//DECAL INSTANCE

var DecalInstance=function(pars){
    DecalInstance.superConstructor.apply(this, [pars]);
    this.type='decalinstance';
};

gamejs.utils.objects.extend(DecalInstance, Instance);

DecalInstance.prototype.destroy=function(){
    Instance.prototype.destroy.apply(this, []);
    removeInstance(this, this.scene.level.decals);
};

DecalInstance.prototype.move=function(pos){
  Instance.prototype.move.apply(this, [snap(pos)]);  
};


var PropInstance=function(pars){
    PropInstance.superConstructor.apply(this, [pars]);
    GUI.draggable(this);
    this.type='propinstance';
};

gamejs.utils.objects.extend(PropInstance, Instance);

PropInstance.prototype.destroy=function(){
    Instance.prototype.destroy.apply(this, []);
    removeInstance(this, this.scene.level.props);
};

var BackgroundTile=function(pars){
    this.filename=pars.filename;
    pars.image=renderer.cache.getTile(pars.filename);
    BackgroundTile.superConstructor.apply(this, [pars]);
    this.scene=pars.scene;
    this.on(GUI.EVT_MOUSE_DOWN, this.select, this);
};
gamejs.utils.objects.extend(BackgroundTile, GUI.Image);

BackgroundTile.prototype.select=function(){
    this.scene.level.bgtile=this.filename;
    this.scene.level_view.refresh();
};

var Tool=exports.Tool=function(pars){
    Tool.superConstructor.apply(this, [pars]);
    this.selected=false;
    this.angle=0;
    this.rotate_angle=pars.rotate_angle;
    this.on(GUI.EVT_MOUSE_DOWN, this.select, this);
    this.subtype='tool';
    this.scene=pars.scene;
};

gamejs.utils.objects.extend(Tool, GUI.Image);

Tool.prototype.select=function(){
    this.selected=true;
    this.despatchEvent({'type':'select', 'tool':this});
    this.refresh();
};

Tool.prototype.rotateLeft=function(){
    this.angle-=this.rotate_angle;
    if(this.angle<0)this.angle+=360;
    this.refresh();
};

Tool.prototype.rotateRight=function(){
    this.angle+=this.rotate_angle;
    if(this.angle>=360)this.angle-=360;
    this.refresh();
};

Tool.prototype.deselect=function(){
    this.selected=false;
    this.refresh();
};

Tool.prototype.paint=function(){
    GUI.Image.prototype.paint.apply(this, []);
    if(this.selected){
        gamejs.draw.rect(this.surface, '#0026FF', new gamejs.Rect([0, 0], this.surface.getSize()), 6);
    }
};

//CHECKPOINT
var Checkpoint=exports.Checkpoint=function(pars){
    pars.image=this.genImage(1);
    pars.rotate_angle=0;
    pars.size=[40, 40];
    pars.rotate_angle=0;
    Checkpoint.superConstructor.apply(this, [pars]);
    this.number=1;
    this.type='checkpoint';
}

gamejs.utils.objects.extend(Checkpoint, Tool);


Checkpoint.prototype.genImage=function(number){
    var s=new gamejs.Surface([40, 40]);
    var font=ui.getFont('editor_checkpoint');
    gamejs.draw.rect(s, 'RGBA(255, 86, 86, 0.2)', new gamejs.Rect([0, 0], s.getSize()));
    font.render(s, String(number), [12, 12]);
    gamejs.draw.rect(s, '#FF5656', new gamejs.Rect([0, 0], s.getSize()), 3);
    return s;
};

Checkpoint.prototype.genHugeImage=function(number){
    var s=new gamejs.Surface([280, 280]);
    var font=ui.getFont('editor_checkpoint');
    gamejs.draw.rect(s, 'RGBA(255, 86, 86, 0.2)', new gamejs.Rect([0, 0], s.getSize()));
    font.render(s, String(number), [130, 130]);
    gamejs.draw.rect(s, '#FF5656', new gamejs.Rect([0, 0], s.getSize()), 3);
    return s;
};

Checkpoint.prototype.getCursorImage=function(){
    return this.genHugeImage(this.number); 
};

Checkpoint.prototype.setNumber=function(number){
    this.number=Math.max(1, number);
    this.setImage(this.genImage(this.number));
};

Checkpoint.prototype.place=function(position){
    var img=this.getCursorImage();
    var sz=CHECKPOINT_SIZE;
    
    var wp;
    //remove previous waypoints w. this number
    for(var i=0;i<this.scene.level.checkpoints.length;i++){
        wp=this.scene.level.checkpoints[i];
        if(wp.number==this.number){
            wp.destroy(false);
        }
    }
    var instance=new CheckpointInstance({'parent':this.scene.level_view,
                                        'size':sz,
                                        'scene':this.scene,
                                        'angle':0,
                                        'original':this,
                                        'number':this.number,
                                        'position':[position[0]-Math.ceil(sz[0]/2), position[1]-Math.ceil(sz[0]/2)]});
    this.scene.level.checkpoints.push(instance);
    this.setNumber(this.number+1);
    this.refresh();
};

//START POSITION
var StartPosition=exports.StartPosition=function(pars){
    pars.image=this.genImage(1);
    pars.rotate_angle=90;
    StartPosition.superConstructor.apply(this, [pars]);
    this.type='startposition';
    this.number=1;
}

gamejs.utils.objects.extend(StartPosition, Tool);

StartPosition.prototype.genImage=function(number, angle){
    var s=new gamejs.Surface([60, 60]);
    var font=ui.getFont('editor_start_pos');
    
    
    //ptlist
    var w=s.getSize()[0];
    var h=s.getSize()[1];
    var ptlist=[[10, 10],
                [20, 0],
                [w-20, 0],
                [w-10, 10],
                [w-10, h],
                [10, h]];
                
    
    gamejs.draw.polygon(s, '#3AFF51', ptlist, 3);
    if(angle===undefined) angle=this.angle;
    s=gamejs.transform.rotate(s, angle);
    font.render(s, String(number), [20, 20]);
    return s;
};

StartPosition.prototype.getCursorImage=function(){
    return this.genImage(this.number); 
};

StartPosition.prototype.setNumber=function(number){
    this.number=Math.min(Math.max(1, number), 6);
    this.setImage(this.genImage(this.number));
};

StartPosition.prototype.place=function(position){
    var img=this.getCursorImage();
    var sz=this.size;
    
    var sp;
    //remove previous waypoints w. this number
    for(var i=0;i<this.scene.level.start_positions.length;i++){
        sp=this.scene.level.start_positions[i];
        if(sp.number==this.number){
            sp.destroy(false);
        }
    }

    var instance=new StartPositionInstance({'parent':this.scene.level_view,
                                        'size':sz,
                                        'scene':this.scene,
                                        'angle':this.angle,
                                        'original':this,
                                        'number':this.number,
                                        'position':snap([position[0]-Math.ceil(sz[0]/2), position[1]-Math.ceil(sz[0]/2)])});
    this.scene.level.start_positions.push(instance);
    this.setNumber(this.number+1);
    this.refresh();
};

//AI WAYPOINT

var AIWaypoint=exports.AIWaypoint=function(pars){
    pars.image=this.genImage(1);  
    pars.rotate_angle=0;
    AIWaypoint.superConstructor.apply(this, [pars]);
    GUI.draggable(this);
    this.type='aiwaypoint';
    this.number=1;
  
};

gamejs.utils.objects.extend(AIWaypoint, Tool);

AIWaypoint.prototype.genImage=function(number){
    var s=new gamejs.Surface([40, 40]);
    var font=ui.getFont('editor_ai_wp');
    font.render(s, String(number), [12, 12]);
    gamejs.draw.rect(s, '#0094FF', new gamejs.Rect([0, 0], s.getSize()), 3);
    return s;
};

AIWaypoint.prototype.getCursorImage=function(){
    return this.genImage(this.number); 
};

AIWaypoint.prototype.setNumber=function(number){
    this.number=Math.max(1, number);
    this.setImage(this.genImage(this.number));
};

AIWaypoint.prototype.place=function(position){
    var img=this.getCursorImage();
    var sz=img.getSize();
    
    var wp;
    //remove previous waypoints w. this number
    for(var i=0;i<this.scene.level.ai_waypoints.length;i++){
        wp=this.scene.level.ai_waypoints[i];
        if(wp.number>=this.number){
            wp.number++;
        }
    }
    var instance=new AIWaypointInstance({'parent':this.scene.level_view,
                                        'size':sz,
                                        'scene':this.scene,
                                        'angle':0,
                                        'original':this,
                                        'number':this.number,
                                        'position':[position[0]-Math.ceil(sz[0]/2), position[1]-Math.ceil(sz[0]/2)]});
    this.scene.level.ai_waypoints.push(instance);
    this.setNumber(this.number+1);
    this.refresh();
};

//DECAL

var Decal=exports.Decal=function(pars){
    pars.image=renderer.cache.getDecalSprite(pars.filename, 0);
    pars.rotate_angle=90;
    Decal.superConstructor.apply(this, [pars]);
    this.type='decal';
    this.filename=pars.filename;
};

gamejs.utils.objects.extend(Decal, Tool);

Decal.prototype.getCursorImage=function(angle){
    if(angle==undefined)angle=this.angle;
    return renderer.cache.getDecalSprite(this.filename, angle);  
};

Decal.prototype.place=function(position){
    var img=this.getCursorImage();
    var sz=img.getSize();
    var instance=new DecalInstance({'parent':this.scene.level_view,
                               'size':sz,
                               'scene':this.scene,
                               'angle':this.angle,
                               'original':this,
                               'position':snap([position[0]-Math.ceil(sz[0]/2), position[1]-Math.ceil(sz[0]/2)])});
    this.scene.level.decals.push(instance);
};

//PROP

var Prop=exports.Prop=function(pars){
    pars.image=renderer.cache.getPropSprite(pars.filename, 0);
    pars.rotate_angle=5;
    Prop.superConstructor.apply(this, [pars]);
    this.type='prop';
    this.filename=pars.filename;
    this.scene=pars.scene;
};

gamejs.utils.objects.extend(Prop, Tool);

Prop.prototype.getCursorImage=function(angle){
    if(angle==undefined)angle=this.angle;
    return renderer.cache.getPropSprite(this.filename, angle);  
};

Prop.prototype.place=function(position){
    var img=this.getCursorImage(this.angle);
    var sz=img.getSize();
    var instance=new PropInstance({'parent':this.scene.level_view,
                               'size':sz,
                               'scene':this.scene,
                               'angle':this.angle,
                               'original':this,
                               'position':[position[0]-Math.ceil(sz[0]/2), position[1]-Math.ceil(sz[0]/2)]});
    this.scene.level.props.push(instance);
};

//LEVEL VIEW
var LevelView=exports.LevelView=function(pars){
    this.scene=pars.scene;
    LevelView.superConstructor.apply(this, [pars]);
    this.mpos=[0, 0];
    
    this.on(GUI.EVT_MOUSE_MOTION, function(event){
        this.mpos=event.pos;
        this.refresh();
    }, this);
};
gamejs.utils.objects.extend(LevelView, GUI.View);


LevelView.prototype.paint=function(){
    var tile=renderer.cache.getTile(this.scene.level.bgtile);
    var ts=tile.getSize();
    for(var x=0;x<this.size[0];x+=ts[0]){
        for(var y=0;y<this.size[1];y+=ts[1]){
            this.surface.blit(tile, [x, y]);
        }
    }
};

LevelView.prototype.post_paint=function(){
    if(this.isHovered() && this.scene.selected && this.scene.selected.subtype=='tool' && this.scene.selected.getCursorImage){
        var img=this.scene.selected.getCursorImage();
        var sz=img.getSize();
        
        var pos=[parseInt(this.mpos[0]-sz[0]/2), parseInt(this.mpos[1]-sz[1]/2)];
        if(this.scene.selected.type=='decal' || this.scene.selected.type=='startposition'){
            pos=snap(pos);
        }
        this.surface.blit(img, pos);
    }
};

LevelView.prototype.draw=function(){
    var painted=false; //has something been repainted in this view?
    //does this view need repainting?
  
    this.children.forEach(function(child){
        //draw children if this view has been repainted or child has been repainted
        if(child.draw() || this._refresh){
            painted=true;
        }
    }, this);
    
    if(this._refresh || painted){
        this.paint();
        var type;
        for(var i=0;i<drawqueue.length;i++){
            type=drawqueue[i];
            this.children.forEach(function(child){
                if(child.type==type){
                    if(child.visible) this.blitChild(child);
                }
            }, this);
        }
        this.scene.minimap.image.blit(this.surface, new gamejs.Rect([0, 0], this.scene.minimap.image.getSize()),
                                      new gamejs.Rect([0, 0], this.surface.getSize()));
        this.scene.minimap.refresh();
        this.post_paint();
        
        this.despatchEvent({'type':GUI.EVT_PAINT, 'surface':this.surface});
        painted=true;
        this._refresh=false;
    }
    
    return painted;
};

var EditorScene=exports.EditorScene=function(){
    document.getElementById('gjs-canvas').oncontextmenu=new Function("return false");
    this.gui=new GUI.GUI(combatracer.game.display);
    this.gui.on(GUI.EVT_PAINT, function(){
        this.surface.clear();
    }, this.gui);
    
    this.alertdialog=new ui.Dialog({'parent':this.gui,
                           'size':[600, 150]});

    
    this.tools=[];
    
    this.minimap=new GUI.Image({'position':[0, 0],
                               'size':[LEFT_PANEL_WIDTH, LEFT_PANEL_WIDTH],
                               'parent':this.gui,
                               'image':new gamejs.Surface([LEFT_PANEL_WIDTH, LEFT_PANEL_WIDTH])});
    
    this.saveloadbtn=new ui.Button({'position':[0, 210],
                                    'size':[190, 50],
                                    'parent':this.gui,
                                    'text':'Save / Load',
                                    'lean':'left'});
    this.saveloadbtn.onClick(function(){
        this.textarea.value=stringifyLevel(this.level);
        $(this.dialogel).dialog('open');
    }, this);
    
    this.playdialog=new PlayDialog({'parent':this.gui,
                                   'scene':this});
    
    this.playbtn=new ui.Button({'position':[0, 270],
                                    'size':[190, 50],
                                    'parent':this.gui,
                                    'text':'Play',
                                    'lean':'left'});
    
    this.playbtn.onClick(function(){this.show();}, this.playdialog);
    
    this.helpbtn=new ui.Button({'position':[0, 330],
                                    'size':[190, 50],
                                    'parent':this.gui,
                                    'text':'Help',
                                    'lean':'left'});
    
    this.helpbtn.onClick(function(){
        window.open('http://www.banditracer.eu/index.php?page=track-editor-help');
    }, this);
    
    this.backbtn=new ui.Button({'position':[0, 390],
                                    'size':[190, 50],
                                    'parent':this.gui,
                                    'text':'Back',
                                    'lean':'left'});
    
    this.backbtn.onClick(function(){
        combatracer.game.showTitle();
    }, this);
    
    
    
    this.dialog=new ui.Dialog({'parent':this.gui,
                                'size':[450, 150]});
    
    this.scw=new GUI.ScrollableView({'parent':this.gui,
                                    'position':[LEFT_PANEL_WIDTH, 0],
                                    'size':[this.gui.size[0]-LEFT_PANEL_WIDTH-20, this.gui.size[1]-BOT_PANEL_HEIGHT-20]});
    
    this.hscrollbar=new GUI.HorizontalScrollbar({'parent':this.gui,
                                                'position':[LEFT_PANEL_WIDTH, this.gui.size[1]-BOT_PANEL_HEIGHT-20],
                                                'size':[this.gui.size[0]-LEFT_PANEL_WIDTH-20, 20]});
    this.scw.setHorizontalScrollbar(this.hscrollbar);
    
    this.vscrollbar=new GUI.VerticalScrollbar({'parent':this.gui,
                                              'position':[this.gui.size[0]-20, 0],
                                              'size':[20, this.gui.size[1]-BOT_PANEL_HEIGHT-20]});
    this.scw.setVerticalScrollbar(this.vscrollbar);
    
    this.level=getLevelTemplate([2500, 2500]);
    
    this.level_view=new LevelView({'parent':this.scw,
                                    'size':[20, 20],
                                    'scene':this,
                                    'position':[0, 0]});
    
    
    this.decal_view=new DecalView({'parent':this.gui,
                                 'scene':this,
                                 'position':[LEFT_PANEL_WIDTH, this.gui.size[1]-BOT_PANEL_HEIGHT],
                                 'size':[this.gui.size[0]-LEFT_PANEL_WIDTH, BOT_PANEL_HEIGHT]});
    
    this.prop_view=new PropView({'parent':this.gui,
                                 'scene':this,
                                 'position':[LEFT_PANEL_WIDTH, this.gui.size[1]-BOT_PANEL_HEIGHT],
                                 'size':[this.gui.size[0]-LEFT_PANEL_WIDTH, BOT_PANEL_HEIGHT]});
    this.prop_view.hide();
    
    this.marker_view=new MarkerView({'parent':this.gui,
                                 'scene':this,
                                 'position':[LEFT_PANEL_WIDTH, this.gui.size[1]-BOT_PANEL_HEIGHT],
                                 'size':[this.gui.size[0]-LEFT_PANEL_WIDTH, BOT_PANEL_HEIGHT]});
    this.marker_view.hide();
    
    this.bg_view=new BgView({'parent':this.gui,
                            'scene':this,
                            'position':[LEFT_PANEL_WIDTH, this.gui.size[1]-BOT_PANEL_HEIGHT],
                            'size':[this.gui.size[0]-LEFT_PANEL_WIDTH, BOT_PANEL_HEIGHT]});
    this.bg_view.hide();
    
    this.layer_view=new LayerView({'parent':this.gui,
                            'scene':this,
                            'position':[LEFT_PANEL_WIDTH, this.gui.size[1]-BOT_PANEL_HEIGHT],
                            'size':[this.gui.size[0]-LEFT_PANEL_WIDTH, BOT_PANEL_HEIGHT]});
    
    this.layer_view.hide();
    
    this.properties_view=new PropertiesView({'parent':this.gui,
                                            'scene':this,
                                            'position':[LEFT_PANEL_WIDTH, this.gui.size[1]-BOT_PANEL_HEIGHT],
                                            'size':[this.gui.size[0]-LEFT_PANEL_WIDTH, BOT_PANEL_HEIGHT]});
    this.properties_view.hide();
    
    this.select_decal_view=new ToolViewSelectItem({'parent':this.gui,
                                                  'what':'decalView',
                                                  'position':[0, this.gui.size[1]-BOT_PANEL_HEIGHT],
                                                  'text':'Decals'});
    this.select_decal_view.on('select', this.selectView, this);
    this.select_decal_view.selected=true;
    
    this.select_prop_view=new ToolViewSelectItem({'parent':this.gui,
                                                  'what':'propView',
                                                  'position':[0, this.gui.size[1]-BOT_PANEL_HEIGHT+22],
                                                  'text':'Props'});
    this.select_prop_view.on('select', this.selectView, this);
    
    this.select_marker_view=new ToolViewSelectItem({'parent':this.gui,
                                                  'what':'markerView',
                                                  'position':[0, this.gui.size[1]-BOT_PANEL_HEIGHT+22*2],
                                                  'text':'Markers'});
    this.select_marker_view.on('select', this.selectView, this);
    
    this.select_bg_view=new ToolViewSelectItem({'parent':this.gui,
                                               'what':'bgView',
                                               'position':[0, this.gui.size[1]-BOT_PANEL_HEIGHT+22*3],
                                               'text':'Background'});
    this.select_bg_view.on('select', this.selectView, this);
    
    this.select_properties_view=new ToolViewSelectItem({'parent':this.gui,
                                               'what':'propertiesView',
                                               'position':[0, this.gui.size[1]-BOT_PANEL_HEIGHT+22*4],
                                               'text':'Properties'});
    this.select_properties_view.on('select', this.selectView, this);
    
    this.select_layer_view=new ToolViewSelectItem({'parent':this.gui,
                                               'what':'layerView',
                                               'position':[0, this.gui.size[1]-BOT_PANEL_HEIGHT+22*5],
                                               'text':'Layers'});
    this.select_layer_view.on('select', this.selectView, this);
    
    
    this.gui.on(GUI.EVT_MOUSE_WHEEL, this.mouseWheel, this);
    this.level_view.on(GUI.EVT_MOUSE_DOWN, this.viewMouseDown, this);
    this.gui.on(GUI.EVT_MOUSE_DOWN, this.mouseDown, this);
    this.level_view.on(GUI.EVT_KEY_DOWN, this.keyDown, this);
    
    //init jquery dialog
    this.dialogel=document.getElementById('saveload_dialog');
    if(!this.dialogel){
        this.dialogel=document.createElement('div');
        this.dialogel.id='saveload_dialog';
        var p=document.createElement('p');
        p.innerHTML=LOAD_HELP_TEXT;
        this.dialogel.appendChild(p);
        this.textarea=document.createElement('textarea');
        this.textarea.style.width='400px';
        this.textarea.style.height='300px';
        this.dialogel.appendChild(this.textarea);
        document.body.appendChild(this.dialogel);
        $(this.dialogel).click(function(event){
            event.stopPropagation();
            // do something
          });  
    }
    $(this.dialogel).dialog({ autoOpen: false ,
                            title:'Save / Load',
                            width:460,
                       buttons: [
    {
        text: 'New',
        'click':function(){
            combatracer.game.editor_scene.loadLevel(getLevelTemplate([2500, 2500]));
            $(this).dialog("close");
        }
        
    },
    {
        text: "Load example",
        click: function() { combatracer.game.editor_scene.loadExample();
                            $(this).dialog("close");}
    },
    {
        text: "Load",
        click: function() { combatracer.game.editor_scene.load();
                            $(this).dialog("close");}
    },
    {
        text: "Close",
        click: function() { $(this).dialog("close"); }
    }]});
    
    $(this.dialogel).scene=this;
    
    this.loadLevel(this.level);

};

EditorScene.prototype.selectView=function(event){
    if(event.what=='decalView'){
        this.decal_view.show();
    }else{
        this.decal_view.hide();
        this.select_decal_view.deselect();
    }
    
    if(event.what=='propView'){
        this.prop_view.show();
    }else{
        this.prop_view.hide();
        this.select_prop_view.deselect();
    }
    
    if(event.what=='markerView'){
        this.marker_view.show();
    }else{
        this.marker_view.hide();
        this.select_marker_view.deselect();   
    }
    
    if(event.what=='bgView'){
        this.bg_view.show();
    }else{
        this.bg_view.hide();
        this.select_bg_view.deselect();
    }
    
    if(event.what=='propertiesView'){
        this.properties_view.show();
    }else{
        this.properties_view.hide();
        this.select_properties_view.deselect();
    }
    
    if(event.what=='layerView'){
        this.layer_view.show();
    }else{
        this.layer_view.hide();
        this.select_layer_view.deselect();
    }
    
    
};

EditorScene.prototype.mouseDown=function(event){
    if(event.button==2){
        this.deselectEverything();
        this.selected=null;
    }
};

EditorScene.prototype.destroyInstance=function(instance){
    instance.destroy();
    this.deselectEverything(this.instance);
    if(this.selected.subtype=='instance' && this.selected.instance_id==instance.instance_id) this.selected=null;
};

EditorScene.prototype.keyDown=function(event){
    if(this.selected && this.selected.subtype=='instance' && event.key==46){
        this.destroyInstance(this.selected);
    }
};

EditorScene.prototype.viewMouseDown=function(event){
    if(event.button==0){
        if(this.selected && this.selected.place){
            this.selected.place(event.pos);
        }
    }
};

EditorScene.prototype.selectTool=function(event){
    var tool=this.selected=event.tool;
    this.deselectEverything(tool);
};

EditorScene.prototype.deselectEverything=function(obj){
    this.tools.forEach(function(tool){
        if(!obj ||(!((tool.type==obj.type) && (tool.filename==obj.filename)))){
            tool.deselect();
        }
    }, this);
    
    this.level_view.children.forEach(function(instance){
        if(!obj || (!((instance.instance_id==obj.instance_id)))){
            instance.deselect();
        }
    }, this);
};

EditorScene.prototype.selectInstance=function(event){
    
    var instance=this.selected=event.instance;
    this.deselectEverything(instance);
    
};

EditorScene.prototype.mouseWheel=function(event){
    if(this.selected){
        if(event.delta<0){
            if(this.selected.rotateRight)for(var i=0;i<Math.abs(event.delta);i++) this.selected.rotateRight();
        }
        else if (event.delta>0){
            if(this.selected.rotateLeft)for(var i=0;i<Math.abs(event.delta);i++) this.selected.rotateLeft();
        }
    }
};

EditorScene.prototype.loadExample=function(){
  try{
    this.loadLevel(JSON.parse(EXAMPLE));
  }catch(e){
    alert('failed! '+e);
  }
};



EditorScene.prototype.load=function(){
  try{
    this.loadLevel(JSON.parse(this.textarea.value));
  }catch(e){
    alert('failed! '+e);
  }
};

EditorScene.prototype.resizeLevelView=function(){
    var size=this.level.size;
    var w=size[0], h=size[1];
    this.level_view.resize(size);
    this.scw.autoSetScrollableArea();
    this.properties_view.widthlbl.setText(String(w));
    this.properties_view.heightlbl.setText(String(h));
    var q=Math.max(w, h)/(LEFT_PANEL_WIDTH-2);
    var minimap_size=[parseInt(w/q), parseInt(h/q)];
    this.minimap.resize(minimap_size);
    this.minimap.image=new gamejs.Surface(minimap_size);
};

EditorScene.prototype.loadLevel=function(level){
    this.level=getLevelTemplate(level.size);
    this.level.bgtile=level.bgtile;
    this.level.title=level.title;
    if(level.laps) this.level.laps=level.laps;
    this.properties_view.title.setText(level.title);
    this.properties_view.lapslbl.setText(String(this.level.laps));
    this.resizeLevelView();
    this.level_view.children=[];
    
    var prop, decal, instance;
    level.decals.forEach(function(dip){
        decal=this.decal_view.filename_to_decal[level.dict[dip.f]];
        instance=new DecalInstance({'parent':this.level_view,
                               'size':decal.getCursorImage().getSize(),
                               'scene':this,
                               'angle':dip.a,
                               'original':decal,
                               'position':dip.p});
        this.level.decals.push(instance);
    }, this);
    
    level.props.forEach(function(pid){
        prop=this.prop_view.filename_to_prop[level.dict[pid.f]];
        instance=new PropInstance({'parent':this.level_view,
                               'size':prop.getCursorImage(pid.a).getSize(),
                               'scene':this,
                               'angle':pid.a,
                               'original':prop,
                               'position':pid.p});
        this.level.props.push(instance);
    }, this);
    
    
    
    var max_ai_n=0, max_cp_n=0, max_sp_n=0;
    
    level.ai_waypoints.forEach(function(aip){
        instance=new AIWaypointInstance({'parent':this.level_view,
                                        'size':this.marker_view.ai_waypoint.getCursorImage().getSize(),
                                        'scene':this,
                                        'angle':0,
                                        'number':aip.n,
                                        'original':this.marker_view.ai_waypoint,
                                        'position':aip.p});
        this.level.ai_waypoints.push(instance);
        max_ai_n=Math.max(max_ai_n, aip.n);
    }, this);
    this.marker_view.ai_waypoint.setNumber(max_ai_n+1);
    
    level.checkpoints.forEach(function(cp){
        
        instance = new CheckpointInstance({'parent':this.level_view,
                                        'size':CHECKPOINT_SIZE,
                                        'scene':this,
                                        'angle':0,
                                        'original':this.marker_view.checkpoint,
                                        'number':cp.n,
                                        'position':cp.p});
        this.level.checkpoints.push(instance);
        max_cp_n=Math.max(max_cp_n, cp.n);
    }, this);
    this.marker_view.checkpoint.setNumber(max_cp_n+1);
    
    level.start_positions.forEach(function(sp){
        instance=new StartPositionInstance({'parent':this.level_view,
                                       'size':this.marker_view.start_position.size,
                                       'scene':this,
                                       'angle':sp.a,
                                       'original':this.marker_view.start_position,
                                       'number':sp.n,
                                       'position':sp.p});
        this.level.start_positions.push(instance);
        max_sp_n=Math.max(max_sp_n, sp.n);
    }, this);
    this.marker_view.start_position.setNumber(max_sp_n+1);
    this.level_view.refresh();
};

EditorScene.prototype.alert=function(){
    this.dialog.show(text, button);
};

EditorScene.prototype.clearAlert=function(){
    this.dialog.close();
};

EditorScene.prototype.handleEvent=function(event){
    this.gui.despatchEvent(event);  
};

EditorScene.prototype.alert=function(text, button){
    this.alertdialog.show(text, button);
};
    
EditorScene.prototype.clearAlert=function(){
    this.alertdialog.close();
};
    

EditorScene.prototype.update=function(msDuration){
    if(this.ping){
        this.ms_to_ping-=msDuration;
        if(this.ms_to_ping<=0){
            this.game.getCommunicator().queueMessage('PING');
            this.ms_to_ping=10000;
        }
    }
    this.gui.update(msDuration);
};

EditorScene.prototype.draw=function(display){
    this.gui.draw();  
};

function LayerOnOffBtn(pars){
    pars.text='On';
    pars.size=[100, 40];
    LayerOnOffBtn.superConstructor.apply(this, [pars]);
    this.layer=pars.layer;
    this.scene=pars.scene;
    this.is_on=true;
    this.onClick(this.onclick, this);
};

gamejs.utils.objects.extend(LayerOnOffBtn, ui.Button);

LayerOnOffBtn.prototype.onclick=function(){
    if(this.is_on){
        this.scene.level[this.layer].forEach(function(obj){
           obj.hide(); 
        });
        this.is_on=false;
        this.setText('Off');
    }
    else{
        this.scene.level[this.layer].forEach(function(obj){
           obj.show(); 
        });
        this.is_on=true;
        this.setText('On');
    }
};

function PlayDialog(pars){
    pars.size=[220, 300];
    PlayDialog.superConstructor.apply(this, [pars]);
    this.scene=pars.scene;
    
    this.playbtn=new ui.Button({'parent':this,
                                'text':'Play',
                                'size':[180, 40],
                                'lean':'both',
                                'position':[20, 20]});
    
    this.playbtn.onClick(function(){
        this.close();
        var problems=getLevelProblems(this.scene.level);
        if(problems.length){
            this.scene.alert(problems[0]);
        }
        else combatracer.game.playLevel(structifyLevel(this.scene.level), false, false, 'editor');
    }, this);
    
    this.testaibtn=new ui.Button({'parent':this,
                                'text':'Test AI',
                                'size':[180, 40],
                                'lean':'both',
                                'position':[20, 70]});
    
    this.testaibtn.onClick(function(){
        this.close();
        var problems=getLevelProblems(this.scene.level);
        if(problems.length){
            this.scene.alert(problems[0]);
        }
        else combatracer.game.playLevel(structifyLevel(this.scene.level), true, false, 'editor');
    }, this);
    
    this.cancelbtn=new ui.Button({'parent':this,
                                'text':'Cancel',
                                'size':[180, 40],
                                'lean':'both',
                                'position':[20, 120]});
    
    this.cancelbtn.onClick(function(){
        this.close();
    }, this);
    
};

gamejs.utils.objects.extend(PlayDialog, GUI.Dialog);


},{"./combatracer":6,"./gamejs-gui":18,"./renderer":26,"./resources":27,"./settings":28,"./skin":29,"./ui":31,"gamejs":37}],9:[function(require,module,exports){


game = require('./engine/game');

exports.initialize_images = function(retv){
    exports.preload_list = exports.preload_list.concat(retv);    
}

exports.register_class = function(fn){
    game.register_class(fn);
};

exports.get_class_by_id = function(id){
    return game.get_class_by_id(id);
};

exports.get_id_by_class = function(fn){
    return game.get_id_by_class(fn);
};

exports.World = require('./engine/world').World;
exports.Object = require('./engine/object').Object;
exports.Entity = require('./engine/entity').Entity;

var sound = require('./engine/sound');
exports.Sound = sound.Sound;
exports.SoundObject = sound.SoundObject;
exports.initialize_sounds = sound.initialize;
exports.play_sound = sound.play;

exports.utils = require('./engine/utils');
exports.box2d = require('./engine/box2d');



},{"./engine/box2d":10,"./engine/entity":11,"./engine/game":12,"./engine/object":14,"./engine/sound":15,"./engine/utils":16,"./engine/world":17}],10:[function(require,module,exports){
/*
* Copyright (c) 2006-2007 Erin Catto http://www.gphysics.com
*
* This software is provided 'as-is', without any express or implied
* warranty.  In no event will the authors be held liable for any damages
* arising from the use of this software.
* Permission is granted to anyone to use this software for any purpose,
* including commercial applications, and to alter it and redistribute it
* freely, subject to the following restrictions:
* 1. The origin of this software must not be misrepresented; you must not
* claim that you wrote the original software. If you use this software
* in a product, an acknowledgment in the product documentation would be
* appreciated but is not required.
* 2. Altered source versions must be plainly marked as such, and must not be
* misrepresented as being the original software.
* 3. This notice may not be removed or altered from any source distribution.
*
*  Modified by Domas Lapinskas on 2011:
*  Box2D global and some aliases added to exports varibale to make this
*  a commonjs module
*
* 
*/
var Box2D = {};

(function (a2j, undefined) {

   if(!(Object.prototype.defineProperty instanceof Function)
      && Object.prototype.__defineGetter__ instanceof Function
      && Object.prototype.__defineSetter__ instanceof Function)
   {
      Object.defineProperty = function(obj, p, cfg) {
         if(cfg.get instanceof Function)
            obj.__defineGetter__(p, cfg.get);
         if(cfg.set instanceof Function)
            obj.__defineSetter__(p, cfg.set);
      }
   }
   
   function emptyFn() {};
   a2j.inherit = function(cls, base) {
      var tmpCtr = cls;
      emptyFn.prototype = base.prototype;
      cls.prototype = new emptyFn;
      cls.prototype.constructor = tmpCtr;
   };
   
   a2j.generateCallback = function generateCallback(context, cb) {
      return function () {
         cb.apply(context, arguments);
      };
   };
   
   a2j.NVector = function NVector(length) {
      if (length === undefined) length = 0;
      var tmp = new Array(length || 0);
      for (var i = 0; i < length; ++i)
      tmp[i] = 0;
      return tmp;
   };
   
   a2j.is = function is(o1, o2) {
      if (o1 === null) return false;
      if ((o2 instanceof Function) && (o1 instanceof o2)) return true;
      if ((o1.constructor.__implements != undefined) && (o1.constructor.__implements[o2])) return true;
      return false;
   };
   
   a2j.parseUInt = function(v) {
      return Math.abs(parseInt(v));
   }
   
})(Box2D);

//#TODO remove assignments from global namespace
var Vector = Array;
var Vector_a2j_Number = Box2D.NVector;
//package structure
if (typeof(Box2D) === "undefined") Box2D = {};
if (typeof(Box2D.Collision) === "undefined") Box2D.Collision = {};
if (typeof(Box2D.Collision.Shapes) === "undefined") Box2D.Collision.Shapes = {};
if (typeof(Box2D.Common) === "undefined") Box2D.Common = {};
if (typeof(Box2D.Common.Math) === "undefined") Box2D.Common.Math = {};
if (typeof(Box2D.Dynamics) === "undefined") Box2D.Dynamics = {};
if (typeof(Box2D.Dynamics.Contacts) === "undefined") Box2D.Dynamics.Contacts = {};
if (typeof(Box2D.Dynamics.Controllers) === "undefined") Box2D.Dynamics.Controllers = {};
if (typeof(Box2D.Dynamics.Joints) === "undefined") Box2D.Dynamics.Joints = {};
//pre-definitions
(function () {
   Box2D.Collision.IBroadPhase = 'Box2D.Collision.IBroadPhase';

   function b2AABB() {
      b2AABB.b2AABB.apply(this, arguments);
   };
   Box2D.Collision.b2AABB = b2AABB;

   function b2Bound() {
      b2Bound.b2Bound.apply(this, arguments);
   };
   Box2D.Collision.b2Bound = b2Bound;

   function b2BoundValues() {
      b2BoundValues.b2BoundValues.apply(this, arguments);
      if (this.constructor === b2BoundValues) this.b2BoundValues.apply(this, arguments);
   };
   Box2D.Collision.b2BoundValues = b2BoundValues;

   function b2Collision() {
      b2Collision.b2Collision.apply(this, arguments);
   };
   Box2D.Collision.b2Collision = b2Collision;

   function b2ContactID() {
      b2ContactID.b2ContactID.apply(this, arguments);
      if (this.constructor === b2ContactID) this.b2ContactID.apply(this, arguments);
   };
   Box2D.Collision.b2ContactID = b2ContactID;

   function b2ContactPoint() {
      b2ContactPoint.b2ContactPoint.apply(this, arguments);
   };
   Box2D.Collision.b2ContactPoint = b2ContactPoint;

   function b2Distance() {
      b2Distance.b2Distance.apply(this, arguments);
   };
   Box2D.Collision.b2Distance = b2Distance;

   function b2DistanceInput() {
      b2DistanceInput.b2DistanceInput.apply(this, arguments);
   };
   Box2D.Collision.b2DistanceInput = b2DistanceInput;

   function b2DistanceOutput() {
      b2DistanceOutput.b2DistanceOutput.apply(this, arguments);
   };
   Box2D.Collision.b2DistanceOutput = b2DistanceOutput;

   function b2DistanceProxy() {
      b2DistanceProxy.b2DistanceProxy.apply(this, arguments);
   };
   Box2D.Collision.b2DistanceProxy = b2DistanceProxy;

   function b2DynamicTree() {
      b2DynamicTree.b2DynamicTree.apply(this, arguments);
      if (this.constructor === b2DynamicTree) this.b2DynamicTree.apply(this, arguments);
   };
   Box2D.Collision.b2DynamicTree = b2DynamicTree;

   function b2DynamicTreeBroadPhase() {
      b2DynamicTreeBroadPhase.b2DynamicTreeBroadPhase.apply(this, arguments);
   };
   Box2D.Collision.b2DynamicTreeBroadPhase = b2DynamicTreeBroadPhase;

   function b2DynamicTreeNode() {
      b2DynamicTreeNode.b2DynamicTreeNode.apply(this, arguments);
   };
   Box2D.Collision.b2DynamicTreeNode = b2DynamicTreeNode;

   function b2DynamicTreePair() {
      b2DynamicTreePair.b2DynamicTreePair.apply(this, arguments);
   };
   Box2D.Collision.b2DynamicTreePair = b2DynamicTreePair;

   function b2Manifold() {
      b2Manifold.b2Manifold.apply(this, arguments);
      if (this.constructor === b2Manifold) this.b2Manifold.apply(this, arguments);
   };
   Box2D.Collision.b2Manifold = b2Manifold;

   function b2ManifoldPoint() {
      b2ManifoldPoint.b2ManifoldPoint.apply(this, arguments);
      if (this.constructor === b2ManifoldPoint) this.b2ManifoldPoint.apply(this, arguments);
   };
   Box2D.Collision.b2ManifoldPoint = b2ManifoldPoint;

   function b2Point() {
      b2Point.b2Point.apply(this, arguments);
   };
   Box2D.Collision.b2Point = b2Point;

   function b2RayCastInput() {
      b2RayCastInput.b2RayCastInput.apply(this, arguments);
      if (this.constructor === b2RayCastInput) this.b2RayCastInput.apply(this, arguments);
   };
   Box2D.Collision.b2RayCastInput = b2RayCastInput;

   function b2RayCastOutput() {
      b2RayCastOutput.b2RayCastOutput.apply(this, arguments);
   };
   Box2D.Collision.b2RayCastOutput = b2RayCastOutput;

   function b2Segment() {
      b2Segment.b2Segment.apply(this, arguments);
   };
   Box2D.Collision.b2Segment = b2Segment;

   function b2SeparationFunction() {
      b2SeparationFunction.b2SeparationFunction.apply(this, arguments);
   };
   Box2D.Collision.b2SeparationFunction = b2SeparationFunction;

   function b2Simplex() {
      b2Simplex.b2Simplex.apply(this, arguments);
      if (this.constructor === b2Simplex) this.b2Simplex.apply(this, arguments);
   };
   Box2D.Collision.b2Simplex = b2Simplex;

   function b2SimplexCache() {
      b2SimplexCache.b2SimplexCache.apply(this, arguments);
   };
   Box2D.Collision.b2SimplexCache = b2SimplexCache;

   function b2SimplexVertex() {
      b2SimplexVertex.b2SimplexVertex.apply(this, arguments);
   };
   Box2D.Collision.b2SimplexVertex = b2SimplexVertex;

   function b2TimeOfImpact() {
      b2TimeOfImpact.b2TimeOfImpact.apply(this, arguments);
   };
   Box2D.Collision.b2TimeOfImpact = b2TimeOfImpact;

   function b2TOIInput() {
      b2TOIInput.b2TOIInput.apply(this, arguments);
   };
   Box2D.Collision.b2TOIInput = b2TOIInput;

   function b2WorldManifold() {
      b2WorldManifold.b2WorldManifold.apply(this, arguments);
      if (this.constructor === b2WorldManifold) this.b2WorldManifold.apply(this, arguments);
   };
   Box2D.Collision.b2WorldManifold = b2WorldManifold;

   function ClipVertex() {
      ClipVertex.ClipVertex.apply(this, arguments);
   };
   Box2D.Collision.ClipVertex = ClipVertex;

   function Features() {
      Features.Features.apply(this, arguments);
   };
   Box2D.Collision.Features = Features;

   function b2CircleShape() {
      b2CircleShape.b2CircleShape.apply(this, arguments);
      if (this.constructor === b2CircleShape) this.b2CircleShape.apply(this, arguments);
   };
   Box2D.Collision.Shapes.b2CircleShape = b2CircleShape;

   function b2EdgeChainDef() {
      b2EdgeChainDef.b2EdgeChainDef.apply(this, arguments);
      if (this.constructor === b2EdgeChainDef) this.b2EdgeChainDef.apply(this, arguments);
   };
   Box2D.Collision.Shapes.b2EdgeChainDef = b2EdgeChainDef;

   function b2EdgeShape() {
      b2EdgeShape.b2EdgeShape.apply(this, arguments);
      if (this.constructor === b2EdgeShape) this.b2EdgeShape.apply(this, arguments);
   };
   Box2D.Collision.Shapes.b2EdgeShape = b2EdgeShape;

   function b2MassData() {
      b2MassData.b2MassData.apply(this, arguments);
   };
   Box2D.Collision.Shapes.b2MassData = b2MassData;

   function b2PolygonShape() {
      b2PolygonShape.b2PolygonShape.apply(this, arguments);
      if (this.constructor === b2PolygonShape) this.b2PolygonShape.apply(this, arguments);
   };
   Box2D.Collision.Shapes.b2PolygonShape = b2PolygonShape;

   function b2Shape() {
      b2Shape.b2Shape.apply(this, arguments);
      if (this.constructor === b2Shape) this.b2Shape.apply(this, arguments);
   };
   Box2D.Collision.Shapes.b2Shape = b2Shape;
   Box2D.Common.b2internal = 'Box2D.Common.b2internal';

   function b2Color() {
      b2Color.b2Color.apply(this, arguments);
      if (this.constructor === b2Color) this.b2Color.apply(this, arguments);
   };
   Box2D.Common.b2Color = b2Color;

   function b2Settings() {
      b2Settings.b2Settings.apply(this, arguments);
   };
   Box2D.Common.b2Settings = b2Settings;

   function b2Mat22() {
      b2Mat22.b2Mat22.apply(this, arguments);
      if (this.constructor === b2Mat22) this.b2Mat22.apply(this, arguments);
   };
   Box2D.Common.Math.b2Mat22 = b2Mat22;

   function b2Mat33() {
      b2Mat33.b2Mat33.apply(this, arguments);
      if (this.constructor === b2Mat33) this.b2Mat33.apply(this, arguments);
   };
   Box2D.Common.Math.b2Mat33 = b2Mat33;

   function b2Math() {
      b2Math.b2Math.apply(this, arguments);
   };
   Box2D.Common.Math.b2Math = b2Math;

   function b2Sweep() {
      b2Sweep.b2Sweep.apply(this, arguments);
   };
   Box2D.Common.Math.b2Sweep = b2Sweep;

   function b2Transform() {
      b2Transform.b2Transform.apply(this, arguments);
      if (this.constructor === b2Transform) this.b2Transform.apply(this, arguments);
   };
   Box2D.Common.Math.b2Transform = b2Transform;

   function b2Vec2() {
      b2Vec2.b2Vec2.apply(this, arguments);
      if (this.constructor === b2Vec2) this.b2Vec2.apply(this, arguments);
   };
   Box2D.Common.Math.b2Vec2 = b2Vec2;

   function b2Vec3() {
      b2Vec3.b2Vec3.apply(this, arguments);
      if (this.constructor === b2Vec3) this.b2Vec3.apply(this, arguments);
   };
   Box2D.Common.Math.b2Vec3 = b2Vec3;

   function b2Body() {
      b2Body.b2Body.apply(this, arguments);
      if (this.constructor === b2Body) this.b2Body.apply(this, arguments);
   };
   Box2D.Dynamics.b2Body = b2Body;

   function b2BodyDef() {
      b2BodyDef.b2BodyDef.apply(this, arguments);
      if (this.constructor === b2BodyDef) this.b2BodyDef.apply(this, arguments);
   };
   Box2D.Dynamics.b2BodyDef = b2BodyDef;

   function b2ContactFilter() {
      b2ContactFilter.b2ContactFilter.apply(this, arguments);
   };
   Box2D.Dynamics.b2ContactFilter = b2ContactFilter;

   function b2ContactImpulse() {
      b2ContactImpulse.b2ContactImpulse.apply(this, arguments);
   };
   Box2D.Dynamics.b2ContactImpulse = b2ContactImpulse;

   function b2ContactListener() {
      b2ContactListener.b2ContactListener.apply(this, arguments);
   };
   Box2D.Dynamics.b2ContactListener = b2ContactListener;

   function b2ContactManager() {
      b2ContactManager.b2ContactManager.apply(this, arguments);
      if (this.constructor === b2ContactManager) this.b2ContactManager.apply(this, arguments);
   };
   Box2D.Dynamics.b2ContactManager = b2ContactManager;

   function b2DebugDraw() {
      b2DebugDraw.b2DebugDraw.apply(this, arguments);
      if (this.constructor === b2DebugDraw) this.b2DebugDraw.apply(this, arguments);
   };
   Box2D.Dynamics.b2DebugDraw = b2DebugDraw;

   function b2DestructionListener() {
      b2DestructionListener.b2DestructionListener.apply(this, arguments);
   };
   Box2D.Dynamics.b2DestructionListener = b2DestructionListener;

   function b2FilterData() {
      b2FilterData.b2FilterData.apply(this, arguments);
   };
   Box2D.Dynamics.b2FilterData = b2FilterData;

   function b2Fixture() {
      b2Fixture.b2Fixture.apply(this, arguments);
      if (this.constructor === b2Fixture) this.b2Fixture.apply(this, arguments);
   };
   Box2D.Dynamics.b2Fixture = b2Fixture;

   function b2FixtureDef() {
      b2FixtureDef.b2FixtureDef.apply(this, arguments);
      if (this.constructor === b2FixtureDef) this.b2FixtureDef.apply(this, arguments);
   };
   Box2D.Dynamics.b2FixtureDef = b2FixtureDef;

   function b2Island() {
      b2Island.b2Island.apply(this, arguments);
      if (this.constructor === b2Island) this.b2Island.apply(this, arguments);
   };
   Box2D.Dynamics.b2Island = b2Island;

   function b2TimeStep() {
      b2TimeStep.b2TimeStep.apply(this, arguments);
   };
   Box2D.Dynamics.b2TimeStep = b2TimeStep;

   function b2World() {
      b2World.b2World.apply(this, arguments);
      if (this.constructor === b2World) this.b2World.apply(this, arguments);
   };
   Box2D.Dynamics.b2World = b2World;

   function b2CircleContact() {
      b2CircleContact.b2CircleContact.apply(this, arguments);
   };
   Box2D.Dynamics.Contacts.b2CircleContact = b2CircleContact;

   function b2Contact() {
      b2Contact.b2Contact.apply(this, arguments);
      if (this.constructor === b2Contact) this.b2Contact.apply(this, arguments);
   };
   Box2D.Dynamics.Contacts.b2Contact = b2Contact;

   function b2ContactConstraint() {
      b2ContactConstraint.b2ContactConstraint.apply(this, arguments);
      if (this.constructor === b2ContactConstraint) this.b2ContactConstraint.apply(this, arguments);
   };
   Box2D.Dynamics.Contacts.b2ContactConstraint = b2ContactConstraint;

   function b2ContactConstraintPoint() {
      b2ContactConstraintPoint.b2ContactConstraintPoint.apply(this, arguments);
   };
   Box2D.Dynamics.Contacts.b2ContactConstraintPoint = b2ContactConstraintPoint;

   function b2ContactEdge() {
      b2ContactEdge.b2ContactEdge.apply(this, arguments);
   };
   Box2D.Dynamics.Contacts.b2ContactEdge = b2ContactEdge;

   function b2ContactFactory() {
      b2ContactFactory.b2ContactFactory.apply(this, arguments);
      if (this.constructor === b2ContactFactory) this.b2ContactFactory.apply(this, arguments);
   };
   Box2D.Dynamics.Contacts.b2ContactFactory = b2ContactFactory;

   function b2ContactRegister() {
      b2ContactRegister.b2ContactRegister.apply(this, arguments);
   };
   Box2D.Dynamics.Contacts.b2ContactRegister = b2ContactRegister;

   function b2ContactResult() {
      b2ContactResult.b2ContactResult.apply(this, arguments);
   };
   Box2D.Dynamics.Contacts.b2ContactResult = b2ContactResult;

   function b2ContactSolver() {
      b2ContactSolver.b2ContactSolver.apply(this, arguments);
      if (this.constructor === b2ContactSolver) this.b2ContactSolver.apply(this, arguments);
   };
   Box2D.Dynamics.Contacts.b2ContactSolver = b2ContactSolver;

   function b2EdgeAndCircleContact() {
      b2EdgeAndCircleContact.b2EdgeAndCircleContact.apply(this, arguments);
   };
   Box2D.Dynamics.Contacts.b2EdgeAndCircleContact = b2EdgeAndCircleContact;

   function b2NullContact() {
      b2NullContact.b2NullContact.apply(this, arguments);
      if (this.constructor === b2NullContact) this.b2NullContact.apply(this, arguments);
   };
   Box2D.Dynamics.Contacts.b2NullContact = b2NullContact;

   function b2PolyAndCircleContact() {
      b2PolyAndCircleContact.b2PolyAndCircleContact.apply(this, arguments);
   };
   Box2D.Dynamics.Contacts.b2PolyAndCircleContact = b2PolyAndCircleContact;

   function b2PolyAndEdgeContact() {
      b2PolyAndEdgeContact.b2PolyAndEdgeContact.apply(this, arguments);
   };
   Box2D.Dynamics.Contacts.b2PolyAndEdgeContact = b2PolyAndEdgeContact;

   function b2PolygonContact() {
      b2PolygonContact.b2PolygonContact.apply(this, arguments);
   };
   Box2D.Dynamics.Contacts.b2PolygonContact = b2PolygonContact;

   function b2PositionSolverManifold() {
      b2PositionSolverManifold.b2PositionSolverManifold.apply(this, arguments);
      if (this.constructor === b2PositionSolverManifold) this.b2PositionSolverManifold.apply(this, arguments);
   };
   Box2D.Dynamics.Contacts.b2PositionSolverManifold = b2PositionSolverManifold;

   function b2BuoyancyController() {
      b2BuoyancyController.b2BuoyancyController.apply(this, arguments);
   };
   Box2D.Dynamics.Controllers.b2BuoyancyController = b2BuoyancyController;

   function b2ConstantAccelController() {
      b2ConstantAccelController.b2ConstantAccelController.apply(this, arguments);
   };
   Box2D.Dynamics.Controllers.b2ConstantAccelController = b2ConstantAccelController;

   function b2ConstantForceController() {
      b2ConstantForceController.b2ConstantForceController.apply(this, arguments);
   };
   Box2D.Dynamics.Controllers.b2ConstantForceController = b2ConstantForceController;

   function b2Controller() {
      b2Controller.b2Controller.apply(this, arguments);
   };
   Box2D.Dynamics.Controllers.b2Controller = b2Controller;

   function b2ControllerEdge() {
      b2ControllerEdge.b2ControllerEdge.apply(this, arguments);
   };
   Box2D.Dynamics.Controllers.b2ControllerEdge = b2ControllerEdge;

   function b2GravityController() {
      b2GravityController.b2GravityController.apply(this, arguments);
   };
   Box2D.Dynamics.Controllers.b2GravityController = b2GravityController;

   function b2TensorDampingController() {
      b2TensorDampingController.b2TensorDampingController.apply(this, arguments);
   };
   Box2D.Dynamics.Controllers.b2TensorDampingController = b2TensorDampingController;

   function b2DistanceJoint() {
      b2DistanceJoint.b2DistanceJoint.apply(this, arguments);
      if (this.constructor === b2DistanceJoint) this.b2DistanceJoint.apply(this, arguments);
   };
   Box2D.Dynamics.Joints.b2DistanceJoint = b2DistanceJoint;

   function b2DistanceJointDef() {
      b2DistanceJointDef.b2DistanceJointDef.apply(this, arguments);
      if (this.constructor === b2DistanceJointDef) this.b2DistanceJointDef.apply(this, arguments);
   };
   Box2D.Dynamics.Joints.b2DistanceJointDef = b2DistanceJointDef;

   function b2FrictionJoint() {
      b2FrictionJoint.b2FrictionJoint.apply(this, arguments);
      if (this.constructor === b2FrictionJoint) this.b2FrictionJoint.apply(this, arguments);
   };
   Box2D.Dynamics.Joints.b2FrictionJoint = b2FrictionJoint;

   function b2FrictionJointDef() {
      b2FrictionJointDef.b2FrictionJointDef.apply(this, arguments);
      if (this.constructor === b2FrictionJointDef) this.b2FrictionJointDef.apply(this, arguments);
   };
   Box2D.Dynamics.Joints.b2FrictionJointDef = b2FrictionJointDef;

   function b2GearJoint() {
      b2GearJoint.b2GearJoint.apply(this, arguments);
      if (this.constructor === b2GearJoint) this.b2GearJoint.apply(this, arguments);
   };
   Box2D.Dynamics.Joints.b2GearJoint = b2GearJoint;

   function b2GearJointDef() {
      b2GearJointDef.b2GearJointDef.apply(this, arguments);
      if (this.constructor === b2GearJointDef) this.b2GearJointDef.apply(this, arguments);
   };
   Box2D.Dynamics.Joints.b2GearJointDef = b2GearJointDef;

   function b2Jacobian() {
      b2Jacobian.b2Jacobian.apply(this, arguments);
   };
   Box2D.Dynamics.Joints.b2Jacobian = b2Jacobian;

   function b2Joint() {
      b2Joint.b2Joint.apply(this, arguments);
      if (this.constructor === b2Joint) this.b2Joint.apply(this, arguments);
   };
   Box2D.Dynamics.Joints.b2Joint = b2Joint;

   function b2JointDef() {
      b2JointDef.b2JointDef.apply(this, arguments);
      if (this.constructor === b2JointDef) this.b2JointDef.apply(this, arguments);
   };
   Box2D.Dynamics.Joints.b2JointDef = b2JointDef;

   function b2JointEdge() {
      b2JointEdge.b2JointEdge.apply(this, arguments);
   };
   Box2D.Dynamics.Joints.b2JointEdge = b2JointEdge;

   function b2LineJoint() {
      b2LineJoint.b2LineJoint.apply(this, arguments);
      if (this.constructor === b2LineJoint) this.b2LineJoint.apply(this, arguments);
   };
   Box2D.Dynamics.Joints.b2LineJoint = b2LineJoint;

   function b2LineJointDef() {
      b2LineJointDef.b2LineJointDef.apply(this, arguments);
      if (this.constructor === b2LineJointDef) this.b2LineJointDef.apply(this, arguments);
   };
   Box2D.Dynamics.Joints.b2LineJointDef = b2LineJointDef;

   function b2MouseJoint() {
      b2MouseJoint.b2MouseJoint.apply(this, arguments);
      if (this.constructor === b2MouseJoint) this.b2MouseJoint.apply(this, arguments);
   };
   Box2D.Dynamics.Joints.b2MouseJoint = b2MouseJoint;

   function b2MouseJointDef() {
      b2MouseJointDef.b2MouseJointDef.apply(this, arguments);
      if (this.constructor === b2MouseJointDef) this.b2MouseJointDef.apply(this, arguments);
   };
   Box2D.Dynamics.Joints.b2MouseJointDef = b2MouseJointDef;

   function b2PrismaticJoint() {
      b2PrismaticJoint.b2PrismaticJoint.apply(this, arguments);
      if (this.constructor === b2PrismaticJoint) this.b2PrismaticJoint.apply(this, arguments);
   };
   Box2D.Dynamics.Joints.b2PrismaticJoint = b2PrismaticJoint;

   function b2PrismaticJointDef() {
      b2PrismaticJointDef.b2PrismaticJointDef.apply(this, arguments);
      if (this.constructor === b2PrismaticJointDef) this.b2PrismaticJointDef.apply(this, arguments);
   };
   Box2D.Dynamics.Joints.b2PrismaticJointDef = b2PrismaticJointDef;

   function b2PulleyJoint() {
      b2PulleyJoint.b2PulleyJoint.apply(this, arguments);
      if (this.constructor === b2PulleyJoint) this.b2PulleyJoint.apply(this, arguments);
   };
   Box2D.Dynamics.Joints.b2PulleyJoint = b2PulleyJoint;

   function b2PulleyJointDef() {
      b2PulleyJointDef.b2PulleyJointDef.apply(this, arguments);
      if (this.constructor === b2PulleyJointDef) this.b2PulleyJointDef.apply(this, arguments);
   };
   Box2D.Dynamics.Joints.b2PulleyJointDef = b2PulleyJointDef;

   function b2RevoluteJoint() {
      b2RevoluteJoint.b2RevoluteJoint.apply(this, arguments);
      if (this.constructor === b2RevoluteJoint) this.b2RevoluteJoint.apply(this, arguments);
   };
   Box2D.Dynamics.Joints.b2RevoluteJoint = b2RevoluteJoint;

   function b2RevoluteJointDef() {
      b2RevoluteJointDef.b2RevoluteJointDef.apply(this, arguments);
      if (this.constructor === b2RevoluteJointDef) this.b2RevoluteJointDef.apply(this, arguments);
   };
   Box2D.Dynamics.Joints.b2RevoluteJointDef = b2RevoluteJointDef;

   function b2WeldJoint() {
      b2WeldJoint.b2WeldJoint.apply(this, arguments);
      if (this.constructor === b2WeldJoint) this.b2WeldJoint.apply(this, arguments);
   };
   Box2D.Dynamics.Joints.b2WeldJoint = b2WeldJoint;

   function b2WeldJointDef() {
      b2WeldJointDef.b2WeldJointDef.apply(this, arguments);
      if (this.constructor === b2WeldJointDef) this.b2WeldJointDef.apply(this, arguments);
   };
   Box2D.Dynamics.Joints.b2WeldJointDef = b2WeldJointDef;
})(); //definitions
Box2D.postDefs = [];
(function () {
   var b2CircleShape = Box2D.Collision.Shapes.b2CircleShape,
      b2EdgeChainDef = Box2D.Collision.Shapes.b2EdgeChainDef,
      b2EdgeShape = Box2D.Collision.Shapes.b2EdgeShape,
      b2MassData = Box2D.Collision.Shapes.b2MassData,
      b2PolygonShape = Box2D.Collision.Shapes.b2PolygonShape,
      b2Shape = Box2D.Collision.Shapes.b2Shape,
      b2Color = Box2D.Common.b2Color,
      b2internal = Box2D.Common.b2internal,
      b2Settings = Box2D.Common.b2Settings,
      b2Mat22 = Box2D.Common.Math.b2Mat22,
      b2Mat33 = Box2D.Common.Math.b2Mat33,
      b2Math = Box2D.Common.Math.b2Math,
      b2Sweep = Box2D.Common.Math.b2Sweep,
      b2Transform = Box2D.Common.Math.b2Transform,
      b2Vec2 = Box2D.Common.Math.b2Vec2,
      b2Vec3 = Box2D.Common.Math.b2Vec3,
      b2AABB = Box2D.Collision.b2AABB,
      b2Bound = Box2D.Collision.b2Bound,
      b2BoundValues = Box2D.Collision.b2BoundValues,
      b2Collision = Box2D.Collision.b2Collision,
      b2ContactID = Box2D.Collision.b2ContactID,
      b2ContactPoint = Box2D.Collision.b2ContactPoint,
      b2Distance = Box2D.Collision.b2Distance,
      b2DistanceInput = Box2D.Collision.b2DistanceInput,
      b2DistanceOutput = Box2D.Collision.b2DistanceOutput,
      b2DistanceProxy = Box2D.Collision.b2DistanceProxy,
      b2DynamicTree = Box2D.Collision.b2DynamicTree,
      b2DynamicTreeBroadPhase = Box2D.Collision.b2DynamicTreeBroadPhase,
      b2DynamicTreeNode = Box2D.Collision.b2DynamicTreeNode,
      b2DynamicTreePair = Box2D.Collision.b2DynamicTreePair,
      b2Manifold = Box2D.Collision.b2Manifold,
      b2ManifoldPoint = Box2D.Collision.b2ManifoldPoint,
      b2Point = Box2D.Collision.b2Point,
      b2RayCastInput = Box2D.Collision.b2RayCastInput,
      b2RayCastOutput = Box2D.Collision.b2RayCastOutput,
      b2Segment = Box2D.Collision.b2Segment,
      b2SeparationFunction = Box2D.Collision.b2SeparationFunction,
      b2Simplex = Box2D.Collision.b2Simplex,
      b2SimplexCache = Box2D.Collision.b2SimplexCache,
      b2SimplexVertex = Box2D.Collision.b2SimplexVertex,
      b2TimeOfImpact = Box2D.Collision.b2TimeOfImpact,
      b2TOIInput = Box2D.Collision.b2TOIInput,
      b2WorldManifold = Box2D.Collision.b2WorldManifold,
      ClipVertex = Box2D.Collision.ClipVertex,
      Features = Box2D.Collision.Features,
      IBroadPhase = Box2D.Collision.IBroadPhase;

   b2AABB.b2AABB = function () {
      this.lowerBound = new b2Vec2();
      this.upperBound = new b2Vec2();
   };
   b2AABB.prototype.IsValid = function () {
      var dX = this.upperBound.x - this.lowerBound.x;
      var dY = this.upperBound.y - this.lowerBound.y;
      var valid = dX >= 0.0 && dY >= 0.0;
      valid = valid && this.lowerBound.IsValid() && this.upperBound.IsValid();
      return valid;
   }
   b2AABB.prototype.GetCenter = function () {
      return new b2Vec2((this.lowerBound.x + this.upperBound.x) / 2, (this.lowerBound.y + this.upperBound.y) / 2);
   }
   b2AABB.prototype.GetExtents = function () {
      return new b2Vec2((this.upperBound.x - this.lowerBound.x) / 2, (this.upperBound.y - this.lowerBound.y) / 2);
   }
   b2AABB.prototype.Contains = function (aabb) {
      var result = true;
      result = result && this.lowerBound.x <= aabb.lowerBound.x;
      result = result && this.lowerBound.y <= aabb.lowerBound.y;
      result = result && aabb.upperBound.x <= this.upperBound.x;
      result = result && aabb.upperBound.y <= this.upperBound.y;
      return result;
   }
   b2AABB.prototype.RayCast = function (output, input) {
      var tmin = (-Number.MAX_VALUE);
      var tmax = Number.MAX_VALUE;
      var pX = input.p1.x;
      var pY = input.p1.y;
      var dX = input.p2.x - input.p1.x;
      var dY = input.p2.y - input.p1.y;
      var absDX = Math.abs(dX);
      var absDY = Math.abs(dY);
      var normal = output.normal;
      var inv_d = 0;
      var t1 = 0;
      var t2 = 0;
      var t3 = 0;
      var s = 0; {
         if (absDX < Number.MIN_VALUE) {
            if (pX < this.lowerBound.x || this.upperBound.x < pX) return false;
         }
         else {
            inv_d = 1.0 / dX;
            t1 = (this.lowerBound.x - pX) * inv_d;
            t2 = (this.upperBound.x - pX) * inv_d;
            s = (-1.0);
            if (t1 > t2) {
               t3 = t1;
               t1 = t2;
               t2 = t3;
               s = 1.0;
            }
            if (t1 > tmin) {
               normal.x = s;
               normal.y = 0;
               tmin = t1;
            }
            tmax = Math.min(tmax, t2);
            if (tmin > tmax) return false;
         }
      } {
         if (absDY < Number.MIN_VALUE) {
            if (pY < this.lowerBound.y || this.upperBound.y < pY) return false;
         }
         else {
            inv_d = 1.0 / dY;
            t1 = (this.lowerBound.y - pY) * inv_d;
            t2 = (this.upperBound.y - pY) * inv_d;
            s = (-1.0);
            if (t1 > t2) {
               t3 = t1;
               t1 = t2;
               t2 = t3;
               s = 1.0;
            }
            if (t1 > tmin) {
               normal.y = s;
               normal.x = 0;
               tmin = t1;
            }
            tmax = Math.min(tmax, t2);
            if (tmin > tmax) return false;
         }
      }
      output.fraction = tmin;
      return true;
   }
   b2AABB.prototype.TestOverlap = function (other) {
      var d1X = other.lowerBound.x - this.upperBound.x;
      var d1Y = other.lowerBound.y - this.upperBound.y;
      var d2X = this.lowerBound.x - other.upperBound.x;
      var d2Y = this.lowerBound.y - other.upperBound.y;
      if (d1X > 0.0 || d1Y > 0.0) return false;
      if (d2X > 0.0 || d2Y > 0.0) return false;
      return true;
   }
   b2AABB.Combine = function (aabb1, aabb2) {
      var aabb = new b2AABB();
      aabb.Combine(aabb1, aabb2);
      return aabb;
   }
   b2AABB.prototype.Combine = function (aabb1, aabb2) {
      this.lowerBound.x = Math.min(aabb1.lowerBound.x, aabb2.lowerBound.x);
      this.lowerBound.y = Math.min(aabb1.lowerBound.y, aabb2.lowerBound.y);
      this.upperBound.x = Math.max(aabb1.upperBound.x, aabb2.upperBound.x);
      this.upperBound.y = Math.max(aabb1.upperBound.y, aabb2.upperBound.y);
   }
   b2Bound.b2Bound = function () {};
   b2Bound.prototype.IsLower = function () {
      return (this.value & 1) == 0;
   }
   b2Bound.prototype.IsUpper = function () {
      return (this.value & 1) == 1;
   }
   b2Bound.prototype.Swap = function (b) {
      var tempValue = this.value;
      var tempProxy = this.proxy;
      var tempStabbingCount = this.stabbingCount;
      this.value = b.value;
      this.proxy = b.proxy;
      this.stabbingCount = b.stabbingCount;
      b.value = tempValue;
      b.proxy = tempProxy;
      b.stabbingCount = tempStabbingCount;
   }
   b2BoundValues.b2BoundValues = function () {};
   b2BoundValues.prototype.b2BoundValues = function () {
      this.lowerValues = new Vector_a2j_Number();
      this.lowerValues[0] = 0.0;
      this.lowerValues[1] = 0.0;
      this.upperValues = new Vector_a2j_Number();
      this.upperValues[0] = 0.0;
      this.upperValues[1] = 0.0;
   }
   b2Collision.b2Collision = function () {};
   b2Collision.ClipSegmentToLine = function (vOut, vIn, normal, offset) {
      if (offset === undefined) offset = 0;
      var cv;
      var numOut = 0;
      cv = vIn[0];
      var vIn0 = cv.v;
      cv = vIn[1];
      var vIn1 = cv.v;
      var distance0 = normal.x * vIn0.x + normal.y * vIn0.y - offset;
      var distance1 = normal.x * vIn1.x + normal.y * vIn1.y - offset;
      if (distance0 <= 0.0) vOut[numOut++].Set(vIn[0]);
      if (distance1 <= 0.0) vOut[numOut++].Set(vIn[1]);
      if (distance0 * distance1 < 0.0) {
         var interp = distance0 / (distance0 - distance1);
         cv = vOut[numOut];
         var tVec = cv.v;
         tVec.x = vIn0.x + interp * (vIn1.x - vIn0.x);
         tVec.y = vIn0.y + interp * (vIn1.y - vIn0.y);
         cv = vOut[numOut];
         var cv2;
         if (distance0 > 0.0) {
            cv2 = vIn[0];
            cv.id = cv2.id;
         }
         else {
            cv2 = vIn[1];
            cv.id = cv2.id;
         }++numOut;
      }
      return numOut;
   }
   b2Collision.EdgeSeparation = function (poly1, xf1, edge1, poly2, xf2) {
      if (edge1 === undefined) edge1 = 0;
      var count1 = parseInt(poly1.m_vertexCount);
      var vertices1 = poly1.m_vertices;
      var normals1 = poly1.m_normals;
      var count2 = parseInt(poly2.m_vertexCount);
      var vertices2 = poly2.m_vertices;
      var tMat;
      var tVec;
      tMat = xf1.R;
      tVec = normals1[edge1];
      var normal1WorldX = (tMat.col1.x * tVec.x + tMat.col2.x * tVec.y);
      var normal1WorldY = (tMat.col1.y * tVec.x + tMat.col2.y * tVec.y);
      tMat = xf2.R;
      var normal1X = (tMat.col1.x * normal1WorldX + tMat.col1.y * normal1WorldY);
      var normal1Y = (tMat.col2.x * normal1WorldX + tMat.col2.y * normal1WorldY);
      var index = 0;
      var minDot = Number.MAX_VALUE;
      for (var i = 0; i < count2; ++i) {
         tVec = vertices2[i];
         var dot = tVec.x * normal1X + tVec.y * normal1Y;
         if (dot < minDot) {
            minDot = dot;
            index = i;
         }
      }
      tVec = vertices1[edge1];
      tMat = xf1.R;
      var v1X = xf1.position.x + (tMat.col1.x * tVec.x + tMat.col2.x * tVec.y);
      var v1Y = xf1.position.y + (tMat.col1.y * tVec.x + tMat.col2.y * tVec.y);
      tVec = vertices2[index];
      tMat = xf2.R;
      var v2X = xf2.position.x + (tMat.col1.x * tVec.x + tMat.col2.x * tVec.y);
      var v2Y = xf2.position.y + (tMat.col1.y * tVec.x + tMat.col2.y * tVec.y);
      v2X -= v1X;
      v2Y -= v1Y;
      var separation = v2X * normal1WorldX + v2Y * normal1WorldY;
      return separation;
   }
   b2Collision.FindMaxSeparation = function (edgeIndex, poly1, xf1, poly2, xf2) {
      var count1 = parseInt(poly1.m_vertexCount);
      var normals1 = poly1.m_normals;
      var tVec;
      var tMat;
      tMat = xf2.R;
      tVec = poly2.m_centroid;
      var dX = xf2.position.x + (tMat.col1.x * tVec.x + tMat.col2.x * tVec.y);
      var dY = xf2.position.y + (tMat.col1.y * tVec.x + tMat.col2.y * tVec.y);
      tMat = xf1.R;
      tVec = poly1.m_centroid;
      dX -= xf1.position.x + (tMat.col1.x * tVec.x + tMat.col2.x * tVec.y);
      dY -= xf1.position.y + (tMat.col1.y * tVec.x + tMat.col2.y * tVec.y);
      var dLocal1X = (dX * xf1.R.col1.x + dY * xf1.R.col1.y);
      var dLocal1Y = (dX * xf1.R.col2.x + dY * xf1.R.col2.y);
      var edge = 0;
      var maxDot = (-Number.MAX_VALUE);
      for (var i = 0; i < count1; ++i) {
         tVec = normals1[i];
         var dot = (tVec.x * dLocal1X + tVec.y * dLocal1Y);
         if (dot > maxDot) {
            maxDot = dot;
            edge = i;
         }
      }
      var s = b2Collision.EdgeSeparation(poly1, xf1, edge, poly2, xf2);
      var prevEdge = parseInt(edge - 1 >= 0 ? edge - 1 : count1 - 1);
      var sPrev = b2Collision.EdgeSeparation(poly1, xf1, prevEdge, poly2, xf2);
      var nextEdge = parseInt(edge + 1 < count1 ? edge + 1 : 0);
      var sNext = b2Collision.EdgeSeparation(poly1, xf1, nextEdge, poly2, xf2);
      var bestEdge = 0;
      var bestSeparation = 0;
      var increment = 0;
      if (sPrev > s && sPrev > sNext) {
         increment = (-1);
         bestEdge = prevEdge;
         bestSeparation = sPrev;
      }
      else if (sNext > s) {
         increment = 1;
         bestEdge = nextEdge;
         bestSeparation = sNext;
      }
      else {
         edgeIndex[0] = edge;
         return s;
      }
      while (true) {
         if (increment == (-1)) edge = bestEdge - 1 >= 0 ? bestEdge - 1 : count1 - 1;
         else edge = bestEdge + 1 < count1 ? bestEdge + 1 : 0;s = b2Collision.EdgeSeparation(poly1, xf1, edge, poly2, xf2);
         if (s > bestSeparation) {
            bestEdge = edge;
            bestSeparation = s;
         }
         else {
            break;
         }
      }
      edgeIndex[0] = bestEdge;
      return bestSeparation;
   }
   b2Collision.FindIncidentEdge = function (c, poly1, xf1, edge1, poly2, xf2) {
      if (edge1 === undefined) edge1 = 0;
      var count1 = parseInt(poly1.m_vertexCount);
      var normals1 = poly1.m_normals;
      var count2 = parseInt(poly2.m_vertexCount);
      var vertices2 = poly2.m_vertices;
      var normals2 = poly2.m_normals;
      var tMat;
      var tVec;
      tMat = xf1.R;
      tVec = normals1[edge1];
      var normal1X = (tMat.col1.x * tVec.x + tMat.col2.x * tVec.y);
      var normal1Y = (tMat.col1.y * tVec.x + tMat.col2.y * tVec.y);
      tMat = xf2.R;
      var tX = (tMat.col1.x * normal1X + tMat.col1.y * normal1Y);
      normal1Y = (tMat.col2.x * normal1X + tMat.col2.y * normal1Y);
      normal1X = tX;
      var index = 0;
      var minDot = Number.MAX_VALUE;
      for (var i = 0; i < count2; ++i) {
         tVec = normals2[i];
         var dot = (normal1X * tVec.x + normal1Y * tVec.y);
         if (dot < minDot) {
            minDot = dot;
            index = i;
         }
      }
      var tClip;
      var i1 = parseInt(index);
      var i2 = parseInt(i1 + 1 < count2 ? i1 + 1 : 0);
      tClip = c[0];
      tVec = vertices2[i1];
      tMat = xf2.R;
      tClip.v.x = xf2.position.x + (tMat.col1.x * tVec.x + tMat.col2.x * tVec.y);
      tClip.v.y = xf2.position.y + (tMat.col1.y * tVec.x + tMat.col2.y * tVec.y);
      tClip.id.features.referenceEdge = edge1;
      tClip.id.features.incidentEdge = i1;
      tClip.id.features.incidentVertex = 0;
      tClip = c[1];
      tVec = vertices2[i2];
      tMat = xf2.R;
      tClip.v.x = xf2.position.x + (tMat.col1.x * tVec.x + tMat.col2.x * tVec.y);
      tClip.v.y = xf2.position.y + (tMat.col1.y * tVec.x + tMat.col2.y * tVec.y);
      tClip.id.features.referenceEdge = edge1;
      tClip.id.features.incidentEdge = i2;
      tClip.id.features.incidentVertex = 1;
   }
   b2Collision.MakeClipPointVector = function () {
      var r = new Vector(2);
      r[0] = new ClipVertex();
      r[1] = new ClipVertex();
      return r;
   }
   b2Collision.CollidePolygons = function (manifold, polyA, xfA, polyB, xfB) {
      var cv;
      manifold.m_pointCount = 0;
      var totalRadius = polyA.m_radius + polyB.m_radius;
      var edgeA = 0;
      b2Collision.s_edgeAO[0] = edgeA;
      var separationA = b2Collision.FindMaxSeparation(b2Collision.s_edgeAO, polyA, xfA, polyB, xfB);
      edgeA = b2Collision.s_edgeAO[0];
      if (separationA > totalRadius) return;
      var edgeB = 0;
      b2Collision.s_edgeBO[0] = edgeB;
      var separationB = b2Collision.FindMaxSeparation(b2Collision.s_edgeBO, polyB, xfB, polyA, xfA);
      edgeB = b2Collision.s_edgeBO[0];
      if (separationB > totalRadius) return;
      var poly1;
      var poly2;
      var xf1;
      var xf2;
      var edge1 = 0;
      var flip = 0;
      var k_relativeTol = 0.98;
      var k_absoluteTol = 0.001;
      var tMat;
      if (separationB > k_relativeTol * separationA + k_absoluteTol) {
         poly1 = polyB;
         poly2 = polyA;
         xf1 = xfB;
         xf2 = xfA;
         edge1 = edgeB;
         manifold.m_type = b2Manifold.e_faceB;
         flip = 1;
      }
      else {
         poly1 = polyA;
         poly2 = polyB;
         xf1 = xfA;
         xf2 = xfB;
         edge1 = edgeA;
         manifold.m_type = b2Manifold.e_faceA;
         flip = 0;
      }
      var incidentEdge = b2Collision.s_incidentEdge;
      b2Collision.FindIncidentEdge(incidentEdge, poly1, xf1, edge1, poly2, xf2);
      var count1 = parseInt(poly1.m_vertexCount);
      var vertices1 = poly1.m_vertices;
      var local_v11 = vertices1[edge1];
      var local_v12;
      if (edge1 + 1 < count1) {
         local_v12 = vertices1[parseInt(edge1 + 1)];
      }
      else {
         local_v12 = vertices1[0];
      }
      var localTangent = b2Collision.s_localTangent;
      localTangent.Set(local_v12.x - local_v11.x, local_v12.y - local_v11.y);
      localTangent.Normalize();
      var localNormal = b2Collision.s_localNormal;
      localNormal.x = localTangent.y;
      localNormal.y = (-localTangent.x);
      var planePoint = b2Collision.s_planePoint;
      planePoint.Set(0.5 * (local_v11.x + local_v12.x), 0.5 * (local_v11.y + local_v12.y));
      var tangent = b2Collision.s_tangent;
      tMat = xf1.R;
      tangent.x = (tMat.col1.x * localTangent.x + tMat.col2.x * localTangent.y);
      tangent.y = (tMat.col1.y * localTangent.x + tMat.col2.y * localTangent.y);
      var tangent2 = b2Collision.s_tangent2;
      tangent2.x = (-tangent.x);
      tangent2.y = (-tangent.y);
      var normal = b2Collision.s_normal;
      normal.x = tangent.y;
      normal.y = (-tangent.x);
      var v11 = b2Collision.s_v11;
      var v12 = b2Collision.s_v12;
      v11.x = xf1.position.x + (tMat.col1.x * local_v11.x + tMat.col2.x * local_v11.y);
      v11.y = xf1.position.y + (tMat.col1.y * local_v11.x + tMat.col2.y * local_v11.y);
      v12.x = xf1.position.x + (tMat.col1.x * local_v12.x + tMat.col2.x * local_v12.y);
      v12.y = xf1.position.y + (tMat.col1.y * local_v12.x + tMat.col2.y * local_v12.y);
      var frontOffset = normal.x * v11.x + normal.y * v11.y;
      var sideOffset1 = (-tangent.x * v11.x) - tangent.y * v11.y + totalRadius;
      var sideOffset2 = tangent.x * v12.x + tangent.y * v12.y + totalRadius;
      var clipPoints1 = b2Collision.s_clipPoints1;
      var clipPoints2 = b2Collision.s_clipPoints2;
      var np = 0;
      np = b2Collision.ClipSegmentToLine(clipPoints1, incidentEdge, tangent2, sideOffset1);
      if (np < 2) return;
      np = b2Collision.ClipSegmentToLine(clipPoints2, clipPoints1, tangent, sideOffset2);
      if (np < 2) return;
      manifold.m_localPlaneNormal.SetV(localNormal);
      manifold.m_localPoint.SetV(planePoint);
      var pointCount = 0;
      for (var i = 0; i < b2Settings.b2_maxManifoldPoints; ++i) {
         cv = clipPoints2[i];
         var separation = normal.x * cv.v.x + normal.y * cv.v.y - frontOffset;
         if (separation <= totalRadius) {
            var cp = manifold.m_points[pointCount];
            tMat = xf2.R;
            var tX = cv.v.x - xf2.position.x;
            var tY = cv.v.y - xf2.position.y;
            cp.m_localPoint.x = (tX * tMat.col1.x + tY * tMat.col1.y);
            cp.m_localPoint.y = (tX * tMat.col2.x + tY * tMat.col2.y);
            cp.m_id.Set(cv.id);
            cp.m_id.features.flip = flip;
            ++pointCount;
         }
      }
      manifold.m_pointCount = pointCount;
   }
   b2Collision.CollideCircles = function (manifold, circle1, xf1, circle2, xf2) {
      manifold.m_pointCount = 0;
      var tMat;
      var tVec;
      tMat = xf1.R;
      tVec = circle1.m_p;
      var p1X = xf1.position.x + (tMat.col1.x * tVec.x + tMat.col2.x * tVec.y);
      var p1Y = xf1.position.y + (tMat.col1.y * tVec.x + tMat.col2.y * tVec.y);
      tMat = xf2.R;
      tVec = circle2.m_p;
      var p2X = xf2.position.x + (tMat.col1.x * tVec.x + tMat.col2.x * tVec.y);
      var p2Y = xf2.position.y + (tMat.col1.y * tVec.x + tMat.col2.y * tVec.y);
      var dX = p2X - p1X;
      var dY = p2Y - p1Y;
      var distSqr = dX * dX + dY * dY;
      var radius = circle1.m_radius + circle2.m_radius;
      if (distSqr > radius * radius) {
         return;
      }
      manifold.m_type = b2Manifold.e_circles;
      manifold.m_localPoint.SetV(circle1.m_p);
      manifold.m_localPlaneNormal.SetZero();
      manifold.m_pointCount = 1;
      manifold.m_points[0].m_localPoint.SetV(circle2.m_p);
      manifold.m_points[0].m_id.key = 0;
   }
   b2Collision.CollidePolygonAndCircle = function (manifold, polygon, xf1, circle, xf2) {
      manifold.m_pointCount = 0;
      var tPoint;
      var dX = 0;
      var dY = 0;
      var positionX = 0;
      var positionY = 0;
      var tVec;
      var tMat;
      tMat = xf2.R;
      tVec = circle.m_p;
      var cX = xf2.position.x + (tMat.col1.x * tVec.x + tMat.col2.x * tVec.y);
      var cY = xf2.position.y + (tMat.col1.y * tVec.x + tMat.col2.y * tVec.y);
      dX = cX - xf1.position.x;
      dY = cY - xf1.position.y;
      tMat = xf1.R;
      var cLocalX = (dX * tMat.col1.x + dY * tMat.col1.y);
      var cLocalY = (dX * tMat.col2.x + dY * tMat.col2.y);
      var dist = 0;
      var normalIndex = 0;
      var separation = (-Number.MAX_VALUE);
      var radius = polygon.m_radius + circle.m_radius;
      var vertexCount = parseInt(polygon.m_vertexCount);
      var vertices = polygon.m_vertices;
      var normals = polygon.m_normals;
      for (var i = 0; i < vertexCount; ++i) {
         tVec = vertices[i];
         dX = cLocalX - tVec.x;
         dY = cLocalY - tVec.y;
         tVec = normals[i];
         var s = tVec.x * dX + tVec.y * dY;
         if (s > radius) {
            return;
         }
         if (s > separation) {
            separation = s;
            normalIndex = i;
         }
      }
      var vertIndex1 = parseInt(normalIndex);
      var vertIndex2 = parseInt(vertIndex1 + 1 < vertexCount ? vertIndex1 + 1 : 0);
      var v1 = vertices[vertIndex1];
      var v2 = vertices[vertIndex2];
      if (separation < Number.MIN_VALUE) {
         manifold.m_pointCount = 1;
         manifold.m_type = b2Manifold.e_faceA;
         manifold.m_localPlaneNormal.SetV(normals[normalIndex]);
         manifold.m_localPoint.x = 0.5 * (v1.x + v2.x);
         manifold.m_localPoint.y = 0.5 * (v1.y + v2.y);
         manifold.m_points[0].m_localPoint.SetV(circle.m_p);
         manifold.m_points[0].m_id.key = 0;
         return;
      }
      var u1 = (cLocalX - v1.x) * (v2.x - v1.x) + (cLocalY - v1.y) * (v2.y - v1.y);
      var u2 = (cLocalX - v2.x) * (v1.x - v2.x) + (cLocalY - v2.y) * (v1.y - v2.y);
      if (u1 <= 0.0) {
         if ((cLocalX - v1.x) * (cLocalX - v1.x) + (cLocalY - v1.y) * (cLocalY - v1.y) > radius * radius) return;
         manifold.m_pointCount = 1;
         manifold.m_type = b2Manifold.e_faceA;
         manifold.m_localPlaneNormal.x = cLocalX - v1.x;
         manifold.m_localPlaneNormal.y = cLocalY - v1.y;
         manifold.m_localPlaneNormal.Normalize();
         manifold.m_localPoint.SetV(v1);
         manifold.m_points[0].m_localPoint.SetV(circle.m_p);
         manifold.m_points[0].m_id.key = 0;
      }
      else if (u2 <= 0) {
         if ((cLocalX - v2.x) * (cLocalX - v2.x) + (cLocalY - v2.y) * (cLocalY - v2.y) > radius * radius) return;
         manifold.m_pointCount = 1;
         manifold.m_type = b2Manifold.e_faceA;
         manifold.m_localPlaneNormal.x = cLocalX - v2.x;
         manifold.m_localPlaneNormal.y = cLocalY - v2.y;
         manifold.m_localPlaneNormal.Normalize();
         manifold.m_localPoint.SetV(v2);
         manifold.m_points[0].m_localPoint.SetV(circle.m_p);
         manifold.m_points[0].m_id.key = 0;
      }
      else {
         var faceCenterX = 0.5 * (v1.x + v2.x);
         var faceCenterY = 0.5 * (v1.y + v2.y);
         separation = (cLocalX - faceCenterX) * normals[vertIndex1].x + (cLocalY - faceCenterY) * normals[vertIndex1].y;
         if (separation > radius) return;
         manifold.m_pointCount = 1;
         manifold.m_type = b2Manifold.e_faceA;
         manifold.m_localPlaneNormal.x = normals[vertIndex1].x;
         manifold.m_localPlaneNormal.y = normals[vertIndex1].y;
         manifold.m_localPlaneNormal.Normalize();
         manifold.m_localPoint.Set(faceCenterX, faceCenterY);
         manifold.m_points[0].m_localPoint.SetV(circle.m_p);
         manifold.m_points[0].m_id.key = 0;
      }
   }
   b2Collision.TestOverlap = function (a, b) {
      var t1 = b.lowerBound;
      var t2 = a.upperBound;
      var d1X = t1.x - t2.x;
      var d1Y = t1.y - t2.y;
      t1 = a.lowerBound;
      t2 = b.upperBound;
      var d2X = t1.x - t2.x;
      var d2Y = t1.y - t2.y;
      if (d1X > 0.0 || d1Y > 0.0) return false;
      if (d2X > 0.0 || d2Y > 0.0) return false;
      return true;
   }
   Box2D.postDefs.push(function () {
      Box2D.Collision.b2Collision.s_incidentEdge = b2Collision.MakeClipPointVector();
      Box2D.Collision.b2Collision.s_clipPoints1 = b2Collision.MakeClipPointVector();
      Box2D.Collision.b2Collision.s_clipPoints2 = b2Collision.MakeClipPointVector();
      Box2D.Collision.b2Collision.s_edgeAO = new Vector_a2j_Number(1);
      Box2D.Collision.b2Collision.s_edgeBO = new Vector_a2j_Number(1);
      Box2D.Collision.b2Collision.s_localTangent = new b2Vec2();
      Box2D.Collision.b2Collision.s_localNormal = new b2Vec2();
      Box2D.Collision.b2Collision.s_planePoint = new b2Vec2();
      Box2D.Collision.b2Collision.s_normal = new b2Vec2();
      Box2D.Collision.b2Collision.s_tangent = new b2Vec2();
      Box2D.Collision.b2Collision.s_tangent2 = new b2Vec2();
      Box2D.Collision.b2Collision.s_v11 = new b2Vec2();
      Box2D.Collision.b2Collision.s_v12 = new b2Vec2();
      Box2D.Collision.b2Collision.b2CollidePolyTempVec = new b2Vec2();
      Box2D.Collision.b2Collision.b2_nullFeature = 0x000000ff;
   });
   b2ContactID.b2ContactID = function () {
      this.features = new Features();
   };
   b2ContactID.prototype.b2ContactID = function () {
      this.features._m_id = this;
   }
   b2ContactID.prototype.Set = function (id) {
      this.key = id._key;
   }
   b2ContactID.prototype.Copy = function () {
      var id = new b2ContactID();
      id.key = this.key;
      return id;
   }
   Object.defineProperty(b2ContactID.prototype, 'key', {
      enumerable: false,
      configurable: true,
      get: function () {
         return this._key;
      }
   });
   Object.defineProperty(b2ContactID.prototype, 'key', {
      enumerable: false,
      configurable: true,
      set: function (value) {
         if (value === undefined) value = 0;
         this._key = value;
         this.features._referenceEdge = this._key & 0x000000ff;
         this.features._incidentEdge = ((this._key & 0x0000ff00) >> 8) & 0x000000ff;
         this.features._incidentVertex = ((this._key & 0x00ff0000) >> 16) & 0x000000ff;
         this.features._flip = ((this._key & 0xff000000) >> 24) & 0x000000ff;
      }
   });
   b2ContactPoint.b2ContactPoint = function () {
      this.position = new b2Vec2();
      this.velocity = new b2Vec2();
      this.normal = new b2Vec2();
      this.id = new b2ContactID();
   };
   b2Distance.b2Distance = function () {};
   b2Distance.Distance = function (output, cache, input) {
      ++b2Distance.b2_gjkCalls;
      var proxyA = input.proxyA;
      var proxyB = input.proxyB;
      var transformA = input.transformA;
      var transformB = input.transformB;
      var simplex = b2Distance.s_simplex;
      simplex.ReadCache(cache, proxyA, transformA, proxyB, transformB);
      var vertices = simplex.m_vertices;
      var k_maxIters = 20;
      var saveA = b2Distance.s_saveA;
      var saveB = b2Distance.s_saveB;
      var saveCount = 0;
      var closestPoint = simplex.GetClosestPoint();
      var distanceSqr1 = closestPoint.LengthSquared();
      var distanceSqr2 = distanceSqr1;
      var i = 0;
      var p;
      var iter = 0;
      while (iter < k_maxIters) {
         saveCount = simplex.m_count;
         for (i = 0;
         i < saveCount; i++) {
            saveA[i] = vertices[i].indexA;
            saveB[i] = vertices[i].indexB;
         }
         switch (simplex.m_count) {
         case 1:
            break;
         case 2:
            simplex.Solve2();
            break;
         case 3:
            simplex.Solve3();
            break;
         default:
            b2Settings.b2Assert(false);
         }
         if (simplex.m_count == 3) {
            break;
         }
         p = simplex.GetClosestPoint();
         distanceSqr2 = p.LengthSquared();
         if (distanceSqr2 > distanceSqr1) {}
         distanceSqr1 = distanceSqr2;
         var d = simplex.GetSearchDirection();
         if (d.LengthSquared() < Number.MIN_VALUE * Number.MIN_VALUE) {
            break;
         }
         var vertex = vertices[simplex.m_count];
         vertex.indexA = proxyA.GetSupport(b2Math.MulTMV(transformA.R, d.GetNegative()));
         vertex.wA = b2Math.MulX(transformA, proxyA.GetVertex(vertex.indexA));
         vertex.indexB = proxyB.GetSupport(b2Math.MulTMV(transformB.R, d));
         vertex.wB = b2Math.MulX(transformB, proxyB.GetVertex(vertex.indexB));
         vertex.w = b2Math.SubtractVV(vertex.wB, vertex.wA);
         ++iter;
         ++b2Distance.b2_gjkIters;
         var duplicate = false;
         for (i = 0;
         i < saveCount; i++) {
            if (vertex.indexA == saveA[i] && vertex.indexB == saveB[i]) {
               duplicate = true;
               break;
            }
         }
         if (duplicate) {
            break;
         }++simplex.m_count;
      }
      b2Distance.b2_gjkMaxIters = b2Math.Max(b2Distance.b2_gjkMaxIters, iter);
      simplex.GetWitnessPoints(output.pointA, output.pointB);
      output.distance = b2Math.SubtractVV(output.pointA, output.pointB).Length();
      output.iterations = iter;
      simplex.WriteCache(cache);
      if (input.useRadii) {
         var rA = proxyA.m_radius;
         var rB = proxyB.m_radius;
         if (output.distance > rA + rB && output.distance > Number.MIN_VALUE) {
            output.distance -= rA + rB;
            var normal = b2Math.SubtractVV(output.pointB, output.pointA);
            normal.Normalize();
            output.pointA.x += rA * normal.x;
            output.pointA.y += rA * normal.y;
            output.pointB.x -= rB * normal.x;
            output.pointB.y -= rB * normal.y;
         }
         else {
            p = new b2Vec2();
            p.x = .5 * (output.pointA.x + output.pointB.x);
            p.y = .5 * (output.pointA.y + output.pointB.y);
            output.pointA.x = output.pointB.x = p.x;
            output.pointA.y = output.pointB.y = p.y;
            output.distance = 0.0;
         }
      }
   }
   Box2D.postDefs.push(function () {
      Box2D.Collision.b2Distance.s_simplex = new b2Simplex();
      Box2D.Collision.b2Distance.s_saveA = new Vector_a2j_Number(3);
      Box2D.Collision.b2Distance.s_saveB = new Vector_a2j_Number(3);
   });
   b2DistanceInput.b2DistanceInput = function () {};
   b2DistanceOutput.b2DistanceOutput = function () {
      this.pointA = new b2Vec2();
      this.pointB = new b2Vec2();
   };
   b2DistanceProxy.b2DistanceProxy = function () {};
   b2DistanceProxy.prototype.Set = function (shape) {
      switch (shape.GetType()) {
      case b2Shape.e_circleShape:
         {
            var circle = (shape instanceof b2CircleShape ? shape : null);
            this.m_vertices = new Vector(1, true);
            this.m_vertices[0] = circle.m_p;
            this.m_count = 1;
            this.m_radius = circle.m_radius;
         }
         break;
      case b2Shape.e_polygonShape:
         {
            var polygon = (shape instanceof b2PolygonShape ? shape : null);
            this.m_vertices = polygon.m_vertices;
            this.m_count = polygon.m_vertexCount;
            this.m_radius = polygon.m_radius;
         }
         break;
      default:
         b2Settings.b2Assert(false);
      }
   }
   b2DistanceProxy.prototype.GetSupport = function (d) {
      var bestIndex = 0;
      var bestValue = this.m_vertices[0].x * d.x + this.m_vertices[0].y * d.y;
      for (var i = 1; i < this.m_count; ++i) {
         var value = this.m_vertices[i].x * d.x + this.m_vertices[i].y * d.y;
         if (value > bestValue) {
            bestIndex = i;
            bestValue = value;
         }
      }
      return bestIndex;
   }
   b2DistanceProxy.prototype.GetSupportVertex = function (d) {
      var bestIndex = 0;
      var bestValue = this.m_vertices[0].x * d.x + this.m_vertices[0].y * d.y;
      for (var i = 1; i < this.m_count; ++i) {
         var value = this.m_vertices[i].x * d.x + this.m_vertices[i].y * d.y;
         if (value > bestValue) {
            bestIndex = i;
            bestValue = value;
         }
      }
      return this.m_vertices[bestIndex];
   }
   b2DistanceProxy.prototype.GetVertexCount = function () {
      return this.m_count;
   }
   b2DistanceProxy.prototype.GetVertex = function (index) {
      if (index === undefined) index = 0;
      b2Settings.b2Assert(0 <= index && index < this.m_count);
      return this.m_vertices[index];
   }
   b2DynamicTree.b2DynamicTree = function () {};
   b2DynamicTree.prototype.b2DynamicTree = function () {
      this.m_root = null;
      this.m_freeList = null;
      this.m_path = 0;
      this.m_insertionCount = 0;
   }
   b2DynamicTree.prototype.CreateProxy = function (aabb, userData) {
      var node = this.AllocateNode();
      var extendX = b2Settings.b2_aabbExtension;
      var extendY = b2Settings.b2_aabbExtension;
      node.aabb.lowerBound.x = aabb.lowerBound.x - extendX;
      node.aabb.lowerBound.y = aabb.lowerBound.y - extendY;
      node.aabb.upperBound.x = aabb.upperBound.x + extendX;
      node.aabb.upperBound.y = aabb.upperBound.y + extendY;
      node.userData = userData;
      this.InsertLeaf(node);
      return node;
   }
   b2DynamicTree.prototype.DestroyProxy = function (proxy) {
      this.RemoveLeaf(proxy);
      this.FreeNode(proxy);
   }
   b2DynamicTree.prototype.MoveProxy = function (proxy, aabb, displacement) {
      b2Settings.b2Assert(proxy.IsLeaf());
      if (proxy.aabb.Contains(aabb)) {
         return false;
      }
      this.RemoveLeaf(proxy);
      var extendX = b2Settings.b2_aabbExtension + b2Settings.b2_aabbMultiplier * (displacement.x > 0 ? displacement.x : (-displacement.x));
      var extendY = b2Settings.b2_aabbExtension + b2Settings.b2_aabbMultiplier * (displacement.y > 0 ? displacement.y : (-displacement.y));
      proxy.aabb.lowerBound.x = aabb.lowerBound.x - extendX;
      proxy.aabb.lowerBound.y = aabb.lowerBound.y - extendY;
      proxy.aabb.upperBound.x = aabb.upperBound.x + extendX;
      proxy.aabb.upperBound.y = aabb.upperBound.y + extendY;
      this.InsertLeaf(proxy);
      return true;
   }
   b2DynamicTree.prototype.Rebalance = function (iterations) {
      if (iterations === undefined) iterations = 0;
      if (this.m_root == null) return;
      for (var i = 0; i < iterations; i++) {
         var node = this.m_root;
         var bit = 0;
         while (node.IsLeaf() == false) {
            node = (this.m_path >> bit) & 1 ? node.child2 : node.child1;
            bit = (bit + 1) & 31;
         }++this.m_path;
         this.RemoveLeaf(node);
         this.InsertLeaf(node);
      }
   }
   b2DynamicTree.prototype.GetFatAABB = function (proxy) {
      return proxy.aabb;
   }
   b2DynamicTree.prototype.GetUserData = function (proxy) {
      return proxy.userData;
   }
   b2DynamicTree.prototype.Query = function (callback, aabb) {
      if (this.m_root == null) return;
      var stack = new Vector();
      var count = 0;
      stack[count++] = this.m_root;
      while (count > 0) {
         var node = stack[--count];
         if (node.aabb.TestOverlap(aabb)) {
            if (node.IsLeaf()) {
               var proceed = callback(node);
               if (!proceed) return;
            }
            else {
               stack[count++] = node.child1;
               stack[count++] = node.child2;
            }
         }
      }
   }
   b2DynamicTree.prototype.RayCast = function (callback, input) {
      if (this.m_root == null) return;
      var p1 = input.p1;
      var p2 = input.p2;
      var r = b2Math.SubtractVV(p1, p2);
      r.Normalize();
      var v = b2Math.CrossFV(1.0, r);
      var abs_v = b2Math.AbsV(v);
      var maxFraction = input.maxFraction;
      var segmentAABB = new b2AABB();
      var tX = 0;
      var tY = 0; {
         tX = p1.x + maxFraction * (p2.x - p1.x);
         tY = p1.y + maxFraction * (p2.y - p1.y);
         segmentAABB.lowerBound.x = Math.min(p1.x, tX);
         segmentAABB.lowerBound.y = Math.min(p1.y, tY);
         segmentAABB.upperBound.x = Math.max(p1.x, tX);
         segmentAABB.upperBound.y = Math.max(p1.y, tY);
      }
      var stack = new Vector();
      var count = 0;
      stack[count++] = this.m_root;
      while (count > 0) {
         var node = stack[--count];
         if (node.aabb.TestOverlap(segmentAABB) == false) {
            continue;
         }
         var c = node.aabb.GetCenter();
         var h = node.aabb.GetExtents();
         var separation = Math.abs(v.x * (p1.x - c.x) + v.y * (p1.y - c.y)) - abs_v.x * h.x - abs_v.y * h.y;
         if (separation > 0.0) continue;
         if (node.IsLeaf()) {
            var subInput = new b2RayCastInput();
            subInput.p1 = input.p1;
            subInput.p2 = input.p2;
            subInput.maxFraction = input.maxFraction;
            maxFraction = callback(subInput, node);
            if (maxFraction == 0.0) return;
            if (maxFraction > 0.0) {
               tX = p1.x + maxFraction * (p2.x - p1.x);
               tY = p1.y + maxFraction * (p2.y - p1.y);
               segmentAABB.lowerBound.x = Math.min(p1.x, tX);
               segmentAABB.lowerBound.y = Math.min(p1.y, tY);
               segmentAABB.upperBound.x = Math.max(p1.x, tX);
               segmentAABB.upperBound.y = Math.max(p1.y, tY);
            }
         }
         else {
            stack[count++] = node.child1;
            stack[count++] = node.child2;
         }
      }
   }
   b2DynamicTree.prototype.AllocateNode = function () {
      if (this.m_freeList) {
         var node = this.m_freeList;
         this.m_freeList = node.parent;
         node.parent = null;
         node.child1 = null;
         node.child2 = null;
         return node;
      }
      return new b2DynamicTreeNode();
   }
   b2DynamicTree.prototype.FreeNode = function (node) {
      node.parent = this.m_freeList;
      this.m_freeList = node;
   }
   b2DynamicTree.prototype.InsertLeaf = function (leaf) {
      ++this.m_insertionCount;
      if (this.m_root == null) {
         this.m_root = leaf;
         this.m_root.parent = null;
         return;
      }
      var center = leaf.aabb.GetCenter();
      var sibling = this.m_root;
      if (sibling.IsLeaf() == false) {
         do {
            var child1 = sibling.child1;
            var child2 = sibling.child2;
            var norm1 = Math.abs((child1.aabb.lowerBound.x + child1.aabb.upperBound.x) / 2 - center.x) + Math.abs((child1.aabb.lowerBound.y + child1.aabb.upperBound.y) / 2 - center.y);
            var norm2 = Math.abs((child2.aabb.lowerBound.x + child2.aabb.upperBound.x) / 2 - center.x) + Math.abs((child2.aabb.lowerBound.y + child2.aabb.upperBound.y) / 2 - center.y);
            if (norm1 < norm2) {
               sibling = child1;
            }
            else {
               sibling = child2;
            }
         }
         while (sibling.IsLeaf() == false)
      }
      var node1 = sibling.parent;
      var node2 = this.AllocateNode();
      node2.parent = node1;
      node2.userData = null;
      node2.aabb.Combine(leaf.aabb, sibling.aabb);
      if (node1) {
         if (sibling.parent.child1 == sibling) {
            node1.child1 = node2;
         }
         else {
            node1.child2 = node2;
         }
         node2.child1 = sibling;
         node2.child2 = leaf;
         sibling.parent = node2;
         leaf.parent = node2;
         do {
            if (node1.aabb.Contains(node2.aabb)) break;
            node1.aabb.Combine(node1.child1.aabb, node1.child2.aabb);
            node2 = node1;
            node1 = node1.parent;
         }
         while (node1)
      }
      else {
         node2.child1 = sibling;
         node2.child2 = leaf;
         sibling.parent = node2;
         leaf.parent = node2;
         this.m_root = node2;
      }
   }
   b2DynamicTree.prototype.RemoveLeaf = function (leaf) {
      if (leaf == this.m_root) {
         this.m_root = null;
         return;
      }
      var node2 = leaf.parent;
      var node1 = node2.parent;
      var sibling;
      if (node2.child1 == leaf) {
         sibling = node2.child2;
      }
      else {
         sibling = node2.child1;
      }
      if (node1) {
         if (node1.child1 == node2) {
            node1.child1 = sibling;
         }
         else {
            node1.child2 = sibling;
         }
         sibling.parent = node1;
         this.FreeNode(node2);
         while (node1) {
            var oldAABB = node1.aabb;
            node1.aabb = b2AABB.Combine(node1.child1.aabb, node1.child2.aabb);
            if (oldAABB.Contains(node1.aabb)) break;
            node1 = node1.parent;
         }
      }
      else {
         this.m_root = sibling;
         sibling.parent = null;
         this.FreeNode(node2);
      }
   }
   b2DynamicTreeBroadPhase.b2DynamicTreeBroadPhase = function () {
      this.m_tree = new b2DynamicTree();
      this.m_moveBuffer = new Vector();
      this.m_pairBuffer = new Vector();
      this.m_pairCount = 0;
   };
   b2DynamicTreeBroadPhase.prototype.CreateProxy = function (aabb, userData) {
      var proxy = this.m_tree.CreateProxy(aabb, userData);
      ++this.m_proxyCount;
      this.BufferMove(proxy);
      return proxy;
   }
   b2DynamicTreeBroadPhase.prototype.DestroyProxy = function (proxy) {
      this.UnBufferMove(proxy);
      --this.m_proxyCount;
      this.m_tree.DestroyProxy(proxy);
   }
   b2DynamicTreeBroadPhase.prototype.MoveProxy = function (proxy, aabb, displacement) {
      var buffer = this.m_tree.MoveProxy(proxy, aabb, displacement);
      if (buffer) {
         this.BufferMove(proxy);
      }
   }
   b2DynamicTreeBroadPhase.prototype.TestOverlap = function (proxyA, proxyB) {
      var aabbA = this.m_tree.GetFatAABB(proxyA);
      var aabbB = this.m_tree.GetFatAABB(proxyB);
      return aabbA.TestOverlap(aabbB);
   }
   b2DynamicTreeBroadPhase.prototype.GetUserData = function (proxy) {
      return this.m_tree.GetUserData(proxy);
   }
   b2DynamicTreeBroadPhase.prototype.GetFatAABB = function (proxy) {
      return this.m_tree.GetFatAABB(proxy);
   }
   b2DynamicTreeBroadPhase.prototype.GetProxyCount = function () {
      return this.m_proxyCount;
   }
   b2DynamicTreeBroadPhase.prototype.UpdatePairs = function (callback) {
      var __this = this;
      __this.m_pairCount = 0;
      var i = 0,
         queryProxy;
      for (i = 0;
      i < __this.m_moveBuffer.length; ++i) {
         queryProxy = __this.m_moveBuffer[i];

         function QueryCallback(proxy) {
            if (proxy == queryProxy) return true;
            if (__this.m_pairCount == __this.m_pairBuffer.length) {
               __this.m_pairBuffer[__this.m_pairCount] = new b2DynamicTreePair();
            }
            var pair = __this.m_pairBuffer[__this.m_pairCount];
            pair.proxyA = proxy < queryProxy ? proxy : queryProxy;
            pair.proxyB = proxy >= queryProxy ? proxy : queryProxy;++__this.m_pairCount;
            return true;
         };
         var fatAABB = __this.m_tree.GetFatAABB(queryProxy);
         __this.m_tree.Query(QueryCallback, fatAABB);
      }
      __this.m_moveBuffer.length = 0;
      for (var i = 0; i < __this.m_pairCount;) {
         var primaryPair = __this.m_pairBuffer[i];
         var userDataA = __this.m_tree.GetUserData(primaryPair.proxyA);
         var userDataB = __this.m_tree.GetUserData(primaryPair.proxyB);
         callback(userDataA, userDataB);
         ++i;
         while (i < __this.m_pairCount) {
            var pair = __this.m_pairBuffer[i];
            if (pair.proxyA != primaryPair.proxyA || pair.proxyB != primaryPair.proxyB) {
               break;
            }++i;
         }
      }
   }
   b2DynamicTreeBroadPhase.prototype.Query = function (callback, aabb) {
      this.m_tree.Query(callback, aabb);
   }
   b2DynamicTreeBroadPhase.prototype.RayCast = function (callback, input) {
      this.m_tree.RayCast(callback, input);
   }
   b2DynamicTreeBroadPhase.prototype.Validate = function () {}
   b2DynamicTreeBroadPhase.prototype.Rebalance = function (iterations) {
      if (iterations === undefined) iterations = 0;
      this.m_tree.Rebalance(iterations);
   }
   b2DynamicTreeBroadPhase.prototype.BufferMove = function (proxy) {
      this.m_moveBuffer[this.m_moveBuffer.length] = proxy;
   }
   b2DynamicTreeBroadPhase.prototype.UnBufferMove = function (proxy) {
      var i = parseInt(this.m_moveBuffer.indexOf(proxy));
      this.m_moveBuffer.splice(i, 1);
   }
   b2DynamicTreeBroadPhase.prototype.ComparePairs = function (pair1, pair2) {
      return 0;
   }
   b2DynamicTreeBroadPhase.__implements = {};
   b2DynamicTreeBroadPhase.__implements[IBroadPhase] = true;
   b2DynamicTreeNode.b2DynamicTreeNode = function () {
      this.aabb = new b2AABB();
   };
   b2DynamicTreeNode.prototype.IsLeaf = function () {
      return this.child1 == null;
   }
   b2DynamicTreePair.b2DynamicTreePair = function () {};
   b2Manifold.b2Manifold = function () {
      this.m_pointCount = 0;
   };
   b2Manifold.prototype.b2Manifold = function () {
      this.m_points = new Vector(b2Settings.b2_maxManifoldPoints);
      for (var i = 0; i < b2Settings.b2_maxManifoldPoints; i++) {
         this.m_points[i] = new b2ManifoldPoint();
      }
      this.m_localPlaneNormal = new b2Vec2();
      this.m_localPoint = new b2Vec2();
   }
   b2Manifold.prototype.Reset = function () {
      for (var i = 0; i < b2Settings.b2_maxManifoldPoints; i++) {
         ((this.m_points[i] instanceof b2ManifoldPoint ? this.m_points[i] : null)).Reset();
      }
      this.m_localPlaneNormal.SetZero();
      this.m_localPoint.SetZero();
      this.m_type = 0;
      this.m_pointCount = 0;
   }
   b2Manifold.prototype.Set = function (m) {
      this.m_pointCount = m.m_pointCount;
      for (var i = 0; i < b2Settings.b2_maxManifoldPoints; i++) {
         ((this.m_points[i] instanceof b2ManifoldPoint ? this.m_points[i] : null)).Set(m.m_points[i]);
      }
      this.m_localPlaneNormal.SetV(m.m_localPlaneNormal);
      this.m_localPoint.SetV(m.m_localPoint);
      this.m_type = m.m_type;
   }
   b2Manifold.prototype.Copy = function () {
      var copy = new b2Manifold();
      copy.Set(this);
      return copy;
   }
   Box2D.postDefs.push(function () {
      Box2D.Collision.b2Manifold.e_circles = 0x0001;
      Box2D.Collision.b2Manifold.e_faceA = 0x0002;
      Box2D.Collision.b2Manifold.e_faceB = 0x0004;
   });
   b2ManifoldPoint.b2ManifoldPoint = function () {
      this.m_localPoint = new b2Vec2();
      this.m_id = new b2ContactID();
   };
   b2ManifoldPoint.prototype.b2ManifoldPoint = function () {
      this.Reset();
   }
   b2ManifoldPoint.prototype.Reset = function () {
      this.m_localPoint.SetZero();
      this.m_normalImpulse = 0.0;
      this.m_tangentImpulse = 0.0;
      this.m_id.key = 0;
   }
   b2ManifoldPoint.prototype.Set = function (m) {
      this.m_localPoint.SetV(m.m_localPoint);
      this.m_normalImpulse = m.m_normalImpulse;
      this.m_tangentImpulse = m.m_tangentImpulse;
      this.m_id.Set(m.m_id);
   }
   b2Point.b2Point = function () {
      this.p = new b2Vec2();
   };
   b2Point.prototype.Support = function (xf, vX, vY) {
      if (vX === undefined) vX = 0;
      if (vY === undefined) vY = 0;
      return this.p;
   }
   b2Point.prototype.GetFirstVertex = function (xf) {
      return this.p;
   }
   b2RayCastInput.b2RayCastInput = function () {
      this.p1 = new b2Vec2();
      this.p2 = new b2Vec2();
   };
   b2RayCastInput.prototype.b2RayCastInput = function (p1, p2, maxFraction) {
      if (p1 === undefined) p1 = null;
      if (p2 === undefined) p2 = null;
      if (maxFraction === undefined) maxFraction = 1;
      if (p1) this.p1.SetV(p1);
      if (p2) this.p2.SetV(p2);
      this.maxFraction = maxFraction;
   }
   b2RayCastOutput.b2RayCastOutput = function () {
      this.normal = new b2Vec2();
   };
   b2Segment.b2Segment = function () {
      this.p1 = new b2Vec2();
      this.p2 = new b2Vec2();
   };
   b2Segment.prototype.TestSegment = function (lambda, normal, segment, maxLambda) {
      if (maxLambda === undefined) maxLambda = 0;
      var s = segment.p1;
      var rX = segment.p2.x - s.x;
      var rY = segment.p2.y - s.y;
      var dX = this.p2.x - this.p1.x;
      var dY = this.p2.y - this.p1.y;
      var nX = dY;
      var nY = (-dX);
      var k_slop = 100.0 * Number.MIN_VALUE;
      var denom = (-(rX * nX + rY * nY));
      if (denom > k_slop) {
         var bX = s.x - this.p1.x;
         var bY = s.y - this.p1.y;
         var a = (bX * nX + bY * nY);
         if (0.0 <= a && a <= maxLambda * denom) {
            var mu2 = (-rX * bY) + rY * bX;
            if ((-k_slop * denom) <= mu2 && mu2 <= denom * (1.0 + k_slop)) {
               a /= denom;
               var nLen = Math.sqrt(nX * nX + nY * nY);
               nX /= nLen;
               nY /= nLen;
               lambda[0] = a;
               normal.Set(nX, nY);
               return true;
            }
         }
      }
      return false;
   }
   b2Segment.prototype.Extend = function (aabb) {
      this.ExtendForward(aabb);
      this.ExtendBackward(aabb);
   }
   b2Segment.prototype.ExtendForward = function (aabb) {
      var dX = this.p2.x - this.p1.x;
      var dY = this.p2.y - this.p1.y;
      var lambda = Math.min(dX > 0 ? (aabb.upperBound.x - this.p1.x) / dX : dX < 0 ? (aabb.lowerBound.x - this.p1.x) / dX : Number.POSITIVE_INFINITY,
      dY > 0 ? (aabb.upperBound.y - this.p1.y) / dY : dY < 0 ? (aabb.lowerBound.y - this.p1.y) / dY : Number.POSITIVE_INFINITY);
      this.p2.x = this.p1.x + dX * lambda;
      this.p2.y = this.p1.y + dY * lambda;
   }
   b2Segment.prototype.ExtendBackward = function (aabb) {
      var dX = (-this.p2.x) + this.p1.x;
      var dY = (-this.p2.y) + this.p1.y;
      var lambda = Math.min(dX > 0 ? (aabb.upperBound.x - this.p2.x) / dX : dX < 0 ? (aabb.lowerBound.x - this.p2.x) / dX : Number.POSITIVE_INFINITY,
      dY > 0 ? (aabb.upperBound.y - this.p2.y) / dY : dY < 0 ? (aabb.lowerBound.y - this.p2.y) / dY : Number.POSITIVE_INFINITY);
      this.p1.x = this.p2.x + dX * lambda;
      this.p1.y = this.p2.y + dY * lambda;
   }
   b2SeparationFunction.b2SeparationFunction = function () {
      this.m_localPoint = new b2Vec2();
      this.m_axis = new b2Vec2();
   };
   b2SeparationFunction.prototype.Initialize = function (cache, proxyA, transformA, proxyB, transformB) {
      this.m_proxyA = proxyA;
      this.m_proxyB = proxyB;
      var count = parseInt(cache.count);
      b2Settings.b2Assert(0 < count && count < 3);
      var localPointA;
      var localPointA1;
      var localPointA2;
      var localPointB;
      var localPointB1;
      var localPointB2;
      var pointAX = 0;
      var pointAY = 0;
      var pointBX = 0;
      var pointBY = 0;
      var normalX = 0;
      var normalY = 0;
      var tMat;
      var tVec;
      var s = 0;
      var sgn = 0;
      if (count == 1) {
         this.m_type = b2SeparationFunction.e_points;
         localPointA = this.m_proxyA.GetVertex(cache.indexA[0]);
         localPointB = this.m_proxyB.GetVertex(cache.indexB[0]);
         tVec = localPointA;
         tMat = transformA.R;
         pointAX = transformA.position.x + (tMat.col1.x * tVec.x + tMat.col2.x * tVec.y);
         pointAY = transformA.position.y + (tMat.col1.y * tVec.x + tMat.col2.y * tVec.y);
         tVec = localPointB;
         tMat = transformB.R;
         pointBX = transformB.position.x + (tMat.col1.x * tVec.x + tMat.col2.x * tVec.y);
         pointBY = transformB.position.y + (tMat.col1.y * tVec.x + tMat.col2.y * tVec.y);
         this.m_axis.x = pointBX - pointAX;
         this.m_axis.y = pointBY - pointAY;
         this.m_axis.Normalize();
      }
      else if (cache.indexB[0] == cache.indexB[1]) {
         this.m_type = b2SeparationFunction.e_faceA;
         localPointA1 = this.m_proxyA.GetVertex(cache.indexA[0]);
         localPointA2 = this.m_proxyA.GetVertex(cache.indexA[1]);
         localPointB = this.m_proxyB.GetVertex(cache.indexB[0]);
         this.m_localPoint.x = 0.5 * (localPointA1.x + localPointA2.x);
         this.m_localPoint.y = 0.5 * (localPointA1.y + localPointA2.y);
         this.m_axis = b2Math.CrossVF(b2Math.SubtractVV(localPointA2, localPointA1), 1.0);
         this.m_axis.Normalize();
         tVec = this.m_axis;
         tMat = transformA.R;
         normalX = tMat.col1.x * tVec.x + tMat.col2.x * tVec.y;
         normalY = tMat.col1.y * tVec.x + tMat.col2.y * tVec.y;
         tVec = this.m_localPoint;
         tMat = transformA.R;
         pointAX = transformA.position.x + (tMat.col1.x * tVec.x + tMat.col2.x * tVec.y);
         pointAY = transformA.position.y + (tMat.col1.y * tVec.x + tMat.col2.y * tVec.y);
         tVec = localPointB;
         tMat = transformB.R;
         pointBX = transformB.position.x + (tMat.col1.x * tVec.x + tMat.col2.x * tVec.y);
         pointBY = transformB.position.y + (tMat.col1.y * tVec.x + tMat.col2.y * tVec.y);
         s = (pointBX - pointAX) * normalX + (pointBY - pointAY) * normalY;
         if (s < 0.0) {
            this.m_axis.NegativeSelf();
         }
      }
      else if (cache.indexA[0] == cache.indexA[0]) {
         this.m_type = b2SeparationFunction.e_faceB;
         localPointB1 = this.m_proxyB.GetVertex(cache.indexB[0]);
         localPointB2 = this.m_proxyB.GetVertex(cache.indexB[1]);
         localPointA = this.m_proxyA.GetVertex(cache.indexA[0]);
         this.m_localPoint.x = 0.5 * (localPointB1.x + localPointB2.x);
         this.m_localPoint.y = 0.5 * (localPointB1.y + localPointB2.y);
         this.m_axis = b2Math.CrossVF(b2Math.SubtractVV(localPointB2, localPointB1), 1.0);
         this.m_axis.Normalize();
         tVec = this.m_axis;
         tMat = transformB.R;
         normalX = tMat.col1.x * tVec.x + tMat.col2.x * tVec.y;
         normalY = tMat.col1.y * tVec.x + tMat.col2.y * tVec.y;
         tVec = this.m_localPoint;
         tMat = transformB.R;
         pointBX = transformB.position.x + (tMat.col1.x * tVec.x + tMat.col2.x * tVec.y);
         pointBY = transformB.position.y + (tMat.col1.y * tVec.x + tMat.col2.y * tVec.y);
         tVec = localPointA;
         tMat = transformA.R;
         pointAX = transformA.position.x + (tMat.col1.x * tVec.x + tMat.col2.x * tVec.y);
         pointAY = transformA.position.y + (tMat.col1.y * tVec.x + tMat.col2.y * tVec.y);
         s = (pointAX - pointBX) * normalX + (pointAY - pointBY) * normalY;
         if (s < 0.0) {
            this.m_axis.NegativeSelf();
         }
      }
      else {
         localPointA1 = this.m_proxyA.GetVertex(cache.indexA[0]);
         localPointA2 = this.m_proxyA.GetVertex(cache.indexA[1]);
         localPointB1 = this.m_proxyB.GetVertex(cache.indexB[0]);
         localPointB2 = this.m_proxyB.GetVertex(cache.indexB[1]);
         var pA = b2Math.MulX(transformA, localPointA);
         var dA = b2Math.MulMV(transformA.R, b2Math.SubtractVV(localPointA2, localPointA1));
         var pB = b2Math.MulX(transformB, localPointB);
         var dB = b2Math.MulMV(transformB.R, b2Math.SubtractVV(localPointB2, localPointB1));
         var a = dA.x * dA.x + dA.y * dA.y;
         var e = dB.x * dB.x + dB.y * dB.y;
         var r = b2Math.SubtractVV(dB, dA);
         var c = dA.x * r.x + dA.y * r.y;
         var f = dB.x * r.x + dB.y * r.y;
         var b = dA.x * dB.x + dA.y * dB.y;
         var denom = a * e - b * b;
         s = 0.0;
         if (denom != 0.0) {
            s = b2Math.Clamp((b * f - c * e) / denom, 0.0, 1.0);
         }
         var t = (b * s + f) / e;
         if (t < 0.0) {
            t = 0.0;
            s = b2Math.Clamp((b - c) / a, 0.0, 1.0);
         }
         localPointA = new b2Vec2();
         localPointA.x = localPointA1.x + s * (localPointA2.x - localPointA1.x);
         localPointA.y = localPointA1.y + s * (localPointA2.y - localPointA1.y);
         localPointB = new b2Vec2();
         localPointB.x = localPointB1.x + s * (localPointB2.x - localPointB1.x);
         localPointB.y = localPointB1.y + s * (localPointB2.y - localPointB1.y);
         if (s == 0.0 || s == 1.0) {
            this.m_type = b2SeparationFunction.e_faceB;
            this.m_axis = b2Math.CrossVF(b2Math.SubtractVV(localPointB2, localPointB1), 1.0);
            this.m_axis.Normalize();
            this.m_localPoint = localPointB;
            tVec = this.m_axis;
            tMat = transformB.R;
            normalX = tMat.col1.x * tVec.x + tMat.col2.x * tVec.y;
            normalY = tMat.col1.y * tVec.x + tMat.col2.y * tVec.y;
            tVec = this.m_localPoint;
            tMat = transformB.R;
            pointBX = transformB.position.x + (tMat.col1.x * tVec.x + tMat.col2.x * tVec.y);
            pointBY = transformB.position.y + (tMat.col1.y * tVec.x + tMat.col2.y * tVec.y);
            tVec = localPointA;
            tMat = transformA.R;
            pointAX = transformA.position.x + (tMat.col1.x * tVec.x + tMat.col2.x * tVec.y);
            pointAY = transformA.position.y + (tMat.col1.y * tVec.x + tMat.col2.y * tVec.y);
            sgn = (pointAX - pointBX) * normalX + (pointAY - pointBY) * normalY;
            if (s < 0.0) {
               this.m_axis.NegativeSelf();
            }
         }
         else {
            this.m_type = b2SeparationFunction.e_faceA;
            this.m_axis = b2Math.CrossVF(b2Math.SubtractVV(localPointA2, localPointA1), 1.0);
            this.m_localPoint = localPointA;
            tVec = this.m_axis;
            tMat = transformA.R;
            normalX = tMat.col1.x * tVec.x + tMat.col2.x * tVec.y;
            normalY = tMat.col1.y * tVec.x + tMat.col2.y * tVec.y;
            tVec = this.m_localPoint;
            tMat = transformA.R;
            pointAX = transformA.position.x + (tMat.col1.x * tVec.x + tMat.col2.x * tVec.y);
            pointAY = transformA.position.y + (tMat.col1.y * tVec.x + tMat.col2.y * tVec.y);
            tVec = localPointB;
            tMat = transformB.R;
            pointBX = transformB.position.x + (tMat.col1.x * tVec.x + tMat.col2.x * tVec.y);
            pointBY = transformB.position.y + (tMat.col1.y * tVec.x + tMat.col2.y * tVec.y);
            sgn = (pointBX - pointAX) * normalX + (pointBY - pointAY) * normalY;
            if (s < 0.0) {
               this.m_axis.NegativeSelf();
            }
         }
      }
   }
   b2SeparationFunction.prototype.Evaluate = function (transformA, transformB) {
      var axisA;
      var axisB;
      var localPointA;
      var localPointB;
      var pointA;
      var pointB;
      var seperation = 0;
      var normal;
      switch (this.m_type) {
      case b2SeparationFunction.e_points:
         {
            axisA = b2Math.MulTMV(transformA.R, this.m_axis);
            axisB = b2Math.MulTMV(transformB.R, this.m_axis.GetNegative());
            localPointA = this.m_proxyA.GetSupportVertex(axisA);
            localPointB = this.m_proxyB.GetSupportVertex(axisB);
            pointA = b2Math.MulX(transformA, localPointA);
            pointB = b2Math.MulX(transformB, localPointB);
            seperation = (pointB.x - pointA.x) * this.m_axis.x + (pointB.y - pointA.y) * this.m_axis.y;
            return seperation;
         }
      case b2SeparationFunction.e_faceA:
         {
            normal = b2Math.MulMV(transformA.R, this.m_axis);
            pointA = b2Math.MulX(transformA, this.m_localPoint);
            axisB = b2Math.MulTMV(transformB.R, normal.GetNegative());
            localPointB = this.m_proxyB.GetSupportVertex(axisB);
            pointB = b2Math.MulX(transformB, localPointB);
            seperation = (pointB.x - pointA.x) * normal.x + (pointB.y - pointA.y) * normal.y;
            return seperation;
         }
      case b2SeparationFunction.e_faceB:
         {
            normal = b2Math.MulMV(transformB.R, this.m_axis);
            pointB = b2Math.MulX(transformB, this.m_localPoint);
            axisA = b2Math.MulTMV(transformA.R, normal.GetNegative());
            localPointA = this.m_proxyA.GetSupportVertex(axisA);
            pointA = b2Math.MulX(transformA, localPointA);
            seperation = (pointA.x - pointB.x) * normal.x + (pointA.y - pointB.y) * normal.y;
            return seperation;
         }
      default:
         b2Settings.b2Assert(false);
         return 0.0;
      }
   }
   Box2D.postDefs.push(function () {
      Box2D.Collision.b2SeparationFunction.e_points = 0x01;
      Box2D.Collision.b2SeparationFunction.e_faceA = 0x02;
      Box2D.Collision.b2SeparationFunction.e_faceB = 0x04;
   });
   b2Simplex.b2Simplex = function () {
      this.m_v1 = new b2SimplexVertex();
      this.m_v2 = new b2SimplexVertex();
      this.m_v3 = new b2SimplexVertex();
      this.m_vertices = new Vector(3);
   };
   b2Simplex.prototype.b2Simplex = function () {
      this.m_vertices[0] = this.m_v1;
      this.m_vertices[1] = this.m_v2;
      this.m_vertices[2] = this.m_v3;
   }
   b2Simplex.prototype.ReadCache = function (cache, proxyA, transformA, proxyB, transformB) {
      b2Settings.b2Assert(0 <= cache.count && cache.count <= 3);
      var wALocal;
      var wBLocal;
      this.m_count = cache.count;
      var vertices = this.m_vertices;
      for (var i = 0; i < this.m_count; i++) {
         var v = vertices[i];
         v.indexA = cache.indexA[i];
         v.indexB = cache.indexB[i];
         wALocal = proxyA.GetVertex(v.indexA);
         wBLocal = proxyB.GetVertex(v.indexB);
         v.wA = b2Math.MulX(transformA, wALocal);
         v.wB = b2Math.MulX(transformB, wBLocal);
         v.w = b2Math.SubtractVV(v.wB, v.wA);
         v.a = 0;
      }
      if (this.m_count > 1) {
         var metric1 = cache.metric;
         var metric2 = this.GetMetric();
         if (metric2 < .5 * metric1 || 2.0 * metric1 < metric2 || metric2 < Number.MIN_VALUE) {
            this.m_count = 0;
         }
      }
      if (this.m_count == 0) {
         v = vertices[0];
         v.indexA = 0;
         v.indexB = 0;
         wALocal = proxyA.GetVertex(0);
         wBLocal = proxyB.GetVertex(0);
         v.wA = b2Math.MulX(transformA, wALocal);
         v.wB = b2Math.MulX(transformB, wBLocal);
         v.w = b2Math.SubtractVV(v.wB, v.wA);
         this.m_count = 1;
      }
   }
   b2Simplex.prototype.WriteCache = function (cache) {
      cache.metric = this.GetMetric();
      cache.count = Box2D.parseUInt(this.m_count);
      var vertices = this.m_vertices;
      for (var i = 0; i < this.m_count; i++) {
         cache.indexA[i] = Box2D.parseUInt(vertices[i].indexA);
         cache.indexB[i] = Box2D.parseUInt(vertices[i].indexB);
      }
   }
   b2Simplex.prototype.GetSearchDirection = function () {
      switch (this.m_count) {
      case 1:
         return this.m_v1.w.GetNegative();
      case 2:
         {
            var e12 = b2Math.SubtractVV(this.m_v2.w, this.m_v1.w);
            var sgn = b2Math.CrossVV(e12, this.m_v1.w.GetNegative());
            if (sgn > 0.0) {
               return b2Math.CrossFV(1.0, e12);
            }
            else {
               return b2Math.CrossVF(e12, 1.0);
            }
         }
      default:
         b2Settings.b2Assert(false);
         return new b2Vec2();
      }
   }
   b2Simplex.prototype.GetClosestPoint = function () {
      switch (this.m_count) {
      case 0:
         b2Settings.b2Assert(false);
         return new b2Vec2();
      case 1:
         return this.m_v1.w;
      case 2:
         return new b2Vec2(this.m_v1.a * this.m_v1.w.x + this.m_v2.a * this.m_v2.w.x, this.m_v1.a * this.m_v1.w.y + this.m_v2.a * this.m_v2.w.y);
      default:
         b2Settings.b2Assert(false);
         return new b2Vec2();
      }
   }
   b2Simplex.prototype.GetWitnessPoints = function (pA, pB) {
      switch (this.m_count) {
      case 0:
         b2Settings.b2Assert(false);
         break;
      case 1:
         pA.SetV(this.m_v1.wA);
         pB.SetV(this.m_v1.wB);
         break;
      case 2:
         pA.x = this.m_v1.a * this.m_v1.wA.x + this.m_v2.a * this.m_v2.wA.x;
         pA.y = this.m_v1.a * this.m_v1.wA.y + this.m_v2.a * this.m_v2.wA.y;
         pB.x = this.m_v1.a * this.m_v1.wB.x + this.m_v2.a * this.m_v2.wB.x;
         pB.y = this.m_v1.a * this.m_v1.wB.y + this.m_v2.a * this.m_v2.wB.y;
         break;
      case 3:
         pB.x = pA.x = this.m_v1.a * this.m_v1.wA.x + this.m_v2.a * this.m_v2.wA.x + this.m_v3.a * this.m_v3.wA.x;
         pB.y = pA.y = this.m_v1.a * this.m_v1.wA.y + this.m_v2.a * this.m_v2.wA.y + this.m_v3.a * this.m_v3.wA.y;
         break;
      default:
         b2Settings.b2Assert(false);
         break;
      }
   }
   b2Simplex.prototype.GetMetric = function () {
      switch (this.m_count) {
      case 0:
         b2Settings.b2Assert(false);
         return 0.0;
      case 1:
         return 0.0;
      case 2:
         return b2Math.SubtractVV(this.m_v1.w, this.m_v2.w).Length();
      case 3:
         return b2Math.CrossVV(b2Math.SubtractVV(this.m_v2.w, this.m_v1.w), b2Math.SubtractVV(this.m_v3.w, this.m_v1.w));
      default:
         b2Settings.b2Assert(false);
         return 0.0;
      }
   }
   b2Simplex.prototype.Solve2 = function () {
      var w1 = this.m_v1.w;
      var w2 = this.m_v2.w;
      var e12 = b2Math.SubtractVV(w2, w1);
      var d12_2 = (-(w1.x * e12.x + w1.y * e12.y));
      if (d12_2 <= 0.0) {
         this.m_v1.a = 1.0;
         this.m_count = 1;
         return;
      }
      var d12_1 = (w2.x * e12.x + w2.y * e12.y);
      if (d12_1 <= 0.0) {
         this.m_v2.a = 1.0;
         this.m_count = 1;
         this.m_v1.Set(this.m_v2);
         return;
      }
      var inv_d12 = 1.0 / (d12_1 + d12_2);
      this.m_v1.a = d12_1 * inv_d12;
      this.m_v2.a = d12_2 * inv_d12;
      this.m_count = 2;
   }
   b2Simplex.prototype.Solve3 = function () {
      var w1 = this.m_v1.w;
      var w2 = this.m_v2.w;
      var w3 = this.m_v3.w;
      var e12 = b2Math.SubtractVV(w2, w1);
      var w1e12 = b2Math.Dot(w1, e12);
      var w2e12 = b2Math.Dot(w2, e12);
      var d12_1 = w2e12;
      var d12_2 = (-w1e12);
      var e13 = b2Math.SubtractVV(w3, w1);
      var w1e13 = b2Math.Dot(w1, e13);
      var w3e13 = b2Math.Dot(w3, e13);
      var d13_1 = w3e13;
      var d13_2 = (-w1e13);
      var e23 = b2Math.SubtractVV(w3, w2);
      var w2e23 = b2Math.Dot(w2, e23);
      var w3e23 = b2Math.Dot(w3, e23);
      var d23_1 = w3e23;
      var d23_2 = (-w2e23);
      var n123 = b2Math.CrossVV(e12, e13);
      var d123_1 = n123 * b2Math.CrossVV(w2, w3);
      var d123_2 = n123 * b2Math.CrossVV(w3, w1);
      var d123_3 = n123 * b2Math.CrossVV(w1, w2);
      if (d12_2 <= 0.0 && d13_2 <= 0.0) {
         this.m_v1.a = 1.0;
         this.m_count = 1;
         return;
      }
      if (d12_1 > 0.0 && d12_2 > 0.0 && d123_3 <= 0.0) {
         var inv_d12 = 1.0 / (d12_1 + d12_2);
         this.m_v1.a = d12_1 * inv_d12;
         this.m_v2.a = d12_2 * inv_d12;
         this.m_count = 2;
         return;
      }
      if (d13_1 > 0.0 && d13_2 > 0.0 && d123_2 <= 0.0) {
         var inv_d13 = 1.0 / (d13_1 + d13_2);
         this.m_v1.a = d13_1 * inv_d13;
         this.m_v3.a = d13_2 * inv_d13;
         this.m_count = 2;
         this.m_v2.Set(this.m_v3);
         return;
      }
      if (d12_1 <= 0.0 && d23_2 <= 0.0) {
         this.m_v2.a = 1.0;
         this.m_count = 1;
         this.m_v1.Set(this.m_v2);
         return;
      }
      if (d13_1 <= 0.0 && d23_1 <= 0.0) {
         this.m_v3.a = 1.0;
         this.m_count = 1;
         this.m_v1.Set(this.m_v3);
         return;
      }
      if (d23_1 > 0.0 && d23_2 > 0.0 && d123_1 <= 0.0) {
         var inv_d23 = 1.0 / (d23_1 + d23_2);
         this.m_v2.a = d23_1 * inv_d23;
         this.m_v3.a = d23_2 * inv_d23;
         this.m_count = 2;
         this.m_v1.Set(this.m_v3);
         return;
      }
      var inv_d123 = 1.0 / (d123_1 + d123_2 + d123_3);
      this.m_v1.a = d123_1 * inv_d123;
      this.m_v2.a = d123_2 * inv_d123;
      this.m_v3.a = d123_3 * inv_d123;
      this.m_count = 3;
   }
   b2SimplexCache.b2SimplexCache = function () {
      this.indexA = new Vector_a2j_Number(3);
      this.indexB = new Vector_a2j_Number(3);
   };
   b2SimplexVertex.b2SimplexVertex = function () {};
   b2SimplexVertex.prototype.Set = function (other) {
      this.wA.SetV(other.wA);
      this.wB.SetV(other.wB);
      this.w.SetV(other.w);
      this.a = other.a;
      this.indexA = other.indexA;
      this.indexB = other.indexB;
   }
   b2TimeOfImpact.b2TimeOfImpact = function () {};
   b2TimeOfImpact.TimeOfImpact = function (input) {
      ++b2TimeOfImpact.b2_toiCalls;
      var proxyA = input.proxyA;
      var proxyB = input.proxyB;
      var sweepA = input.sweepA;
      var sweepB = input.sweepB;
      b2Settings.b2Assert(sweepA.t0 == sweepB.t0);
      b2Settings.b2Assert(1.0 - sweepA.t0 > Number.MIN_VALUE);
      var radius = proxyA.m_radius + proxyB.m_radius;
      var tolerance = input.tolerance;
      var alpha = 0.0;
      var k_maxIterations = 1000;
      var iter = 0;
      var target = 0.0;
      b2TimeOfImpact.s_cache.count = 0;
      b2TimeOfImpact.s_distanceInput.useRadii = false;
      for (;;) {
         sweepA.GetTransform(b2TimeOfImpact.s_xfA, alpha);
         sweepB.GetTransform(b2TimeOfImpact.s_xfB, alpha);
         b2TimeOfImpact.s_distanceInput.proxyA = proxyA;
         b2TimeOfImpact.s_distanceInput.proxyB = proxyB;
         b2TimeOfImpact.s_distanceInput.transformA = b2TimeOfImpact.s_xfA;
         b2TimeOfImpact.s_distanceInput.transformB = b2TimeOfImpact.s_xfB;
         b2Distance.Distance(b2TimeOfImpact.s_distanceOutput, b2TimeOfImpact.s_cache, b2TimeOfImpact.s_distanceInput);
         if (b2TimeOfImpact.s_distanceOutput.distance <= 0.0) {
            alpha = 1.0;
            break;
         }
         b2TimeOfImpact.s_fcn.Initialize(b2TimeOfImpact.s_cache, proxyA, b2TimeOfImpact.s_xfA, proxyB, b2TimeOfImpact.s_xfB);
         var separation = b2TimeOfImpact.s_fcn.Evaluate(b2TimeOfImpact.s_xfA, b2TimeOfImpact.s_xfB);
         if (separation <= 0.0) {
            alpha = 1.0;
            break;
         }
         if (iter == 0) {
            if (separation > radius) {
               target = b2Math.Max(radius - tolerance, 0.75 * radius);
            }
            else {
               target = b2Math.Max(separation - tolerance, 0.02 * radius);
            }
         }
         if (separation - target < 0.5 * tolerance) {
            if (iter == 0) {
               alpha = 1.0;
               break;
            }
            break;
         }
         var newAlpha = alpha; {
            var x1 = alpha;
            var x2 = 1.0;
            var f1 = separation;
            sweepA.GetTransform(b2TimeOfImpact.s_xfA, x2);
            sweepB.GetTransform(b2TimeOfImpact.s_xfB, x2);
            var f2 = b2TimeOfImpact.s_fcn.Evaluate(b2TimeOfImpact.s_xfA, b2TimeOfImpact.s_xfB);
            if (f2 >= target) {
               alpha = 1.0;
               break;
            }
            var rootIterCount = 0;
            for (;;) {
               var x = 0;
               if (rootIterCount & 1) {
                  x = x1 + (target - f1) * (x2 - x1) / (f2 - f1);
               }
               else {
                  x = 0.5 * (x1 + x2);
               }
               sweepA.GetTransform(b2TimeOfImpact.s_xfA, x);
               sweepB.GetTransform(b2TimeOfImpact.s_xfB, x);
               var f = b2TimeOfImpact.s_fcn.Evaluate(b2TimeOfImpact.s_xfA, b2TimeOfImpact.s_xfB);
               if (b2Math.Abs(f - target) < 0.025 * tolerance) {
                  newAlpha = x;
                  break;
               }
               if (f > target) {
                  x1 = x;
                  f1 = f;
               }
               else {
                  x2 = x;
                  f2 = f;
               }++rootIterCount;
               ++b2TimeOfImpact.b2_toiRootIters;
               if (rootIterCount == 50) {
                  break;
               }
            }
            b2TimeOfImpact.b2_toiMaxRootIters = b2Math.Max(b2TimeOfImpact.b2_toiMaxRootIters, rootIterCount);
         }
         if (newAlpha < (1.0 + 100.0 * Number.MIN_VALUE) * alpha) {
            break;
         }
         alpha = newAlpha;
         iter++;
         ++b2TimeOfImpact.b2_toiIters;
         if (iter == k_maxIterations) {
            break;
         }
      }
      b2TimeOfImpact.b2_toiMaxIters = b2Math.Max(b2TimeOfImpact.b2_toiMaxIters, iter);
      return alpha;
   }
   Box2D.postDefs.push(function () {
      Box2D.Collision.b2TimeOfImpact.b2_toiCalls = 0;
      Box2D.Collision.b2TimeOfImpact.b2_toiIters = 0;
      Box2D.Collision.b2TimeOfImpact.b2_toiMaxIters = 0;
      Box2D.Collision.b2TimeOfImpact.b2_toiRootIters = 0;
      Box2D.Collision.b2TimeOfImpact.b2_toiMaxRootIters = 0;
      Box2D.Collision.b2TimeOfImpact.s_cache = new b2SimplexCache();
      Box2D.Collision.b2TimeOfImpact.s_distanceInput = new b2DistanceInput();
      Box2D.Collision.b2TimeOfImpact.s_xfA = new b2Transform();
      Box2D.Collision.b2TimeOfImpact.s_xfB = new b2Transform();
      Box2D.Collision.b2TimeOfImpact.s_fcn = new b2SeparationFunction();
      Box2D.Collision.b2TimeOfImpact.s_distanceOutput = new b2DistanceOutput();
   });
   b2TOIInput.b2TOIInput = function () {
      this.proxyA = new b2DistanceProxy();
      this.proxyB = new b2DistanceProxy();
      this.sweepA = new b2Sweep();
      this.sweepB = new b2Sweep();
   };
   b2WorldManifold.b2WorldManifold = function () {
      this.m_normal = new b2Vec2();
   };
   b2WorldManifold.prototype.b2WorldManifold = function () {
      this.m_points = new Vector(b2Settings.b2_maxManifoldPoints);
      for (var i = 0; i < b2Settings.b2_maxManifoldPoints; i++) {
         this.m_points[i] = new b2Vec2();
      }
   }
   b2WorldManifold.prototype.Initialize = function (manifold, xfA, radiusA, xfB, radiusB) {
      if (radiusA === undefined) radiusA = 0;
      if (radiusB === undefined) radiusB = 0;
      if (manifold.m_pointCount == 0) {
         return;
      }
      var i = 0;
      var tVec;
      var tMat;
      var normalX = 0;
      var normalY = 0;
      var planePointX = 0;
      var planePointY = 0;
      var clipPointX = 0;
      var clipPointY = 0;
      switch (manifold.m_type) {
      case b2Manifold.e_circles:
         {
            tMat = xfA.R;
            tVec = manifold.m_localPoint;
            var pointAX = xfA.position.x + tMat.col1.x * tVec.x + tMat.col2.x * tVec.y;
            var pointAY = xfA.position.y + tMat.col1.y * tVec.x + tMat.col2.y * tVec.y;
            tMat = xfB.R;
            tVec = manifold.m_points[0].m_localPoint;
            var pointBX = xfB.position.x + tMat.col1.x * tVec.x + tMat.col2.x * tVec.y;
            var pointBY = xfB.position.y + tMat.col1.y * tVec.x + tMat.col2.y * tVec.y;
            var dX = pointBX - pointAX;
            var dY = pointBY - pointAY;
            var d2 = dX * dX + dY * dY;
            if (d2 > Number.MIN_VALUE * Number.MIN_VALUE) {
               var d = Math.sqrt(d2);
               this.m_normal.x = dX / d;
               this.m_normal.y = dY / d;
            }
            else {
               this.m_normal.x = 1;
               this.m_normal.y = 0;
            }
            var cAX = pointAX + radiusA * this.m_normal.x;
            var cAY = pointAY + radiusA * this.m_normal.y;
            var cBX = pointBX - radiusB * this.m_normal.x;
            var cBY = pointBY - radiusB * this.m_normal.y;
            this.m_points[0].x = 0.5 * (cAX + cBX);
            this.m_points[0].y = 0.5 * (cAY + cBY);
         }
         break;
      case b2Manifold.e_faceA:
         {
            tMat = xfA.R;
            tVec = manifold.m_localPlaneNormal;
            normalX = tMat.col1.x * tVec.x + tMat.col2.x * tVec.y;
            normalY = tMat.col1.y * tVec.x + tMat.col2.y * tVec.y;
            tMat = xfA.R;
            tVec = manifold.m_localPoint;
            planePointX = xfA.position.x + tMat.col1.x * tVec.x + tMat.col2.x * tVec.y;
            planePointY = xfA.position.y + tMat.col1.y * tVec.x + tMat.col2.y * tVec.y;
            this.m_normal.x = normalX;
            this.m_normal.y = normalY;
            for (i = 0;
            i < manifold.m_pointCount; i++) {
               tMat = xfB.R;
               tVec = manifold.m_points[i].m_localPoint;
               clipPointX = xfB.position.x + tMat.col1.x * tVec.x + tMat.col2.x * tVec.y;
               clipPointY = xfB.position.y + tMat.col1.y * tVec.x + tMat.col2.y * tVec.y;
               this.m_points[i].x = clipPointX + 0.5 * (radiusA - (clipPointX - planePointX) * normalX - (clipPointY - planePointY) * normalY - radiusB) * normalX;
               this.m_points[i].y = clipPointY + 0.5 * (radiusA - (clipPointX - planePointX) * normalX - (clipPointY - planePointY) * normalY - radiusB) * normalY;
            }
         }
         break;
      case b2Manifold.e_faceB:
         {
            tMat = xfB.R;
            tVec = manifold.m_localPlaneNormal;
            normalX = tMat.col1.x * tVec.x + tMat.col2.x * tVec.y;
            normalY = tMat.col1.y * tVec.x + tMat.col2.y * tVec.y;
            tMat = xfB.R;
            tVec = manifold.m_localPoint;
            planePointX = xfB.position.x + tMat.col1.x * tVec.x + tMat.col2.x * tVec.y;
            planePointY = xfB.position.y + tMat.col1.y * tVec.x + tMat.col2.y * tVec.y;
            this.m_normal.x = (-normalX);
            this.m_normal.y = (-normalY);
            for (i = 0;
            i < manifold.m_pointCount; i++) {
               tMat = xfA.R;
               tVec = manifold.m_points[i].m_localPoint;
               clipPointX = xfA.position.x + tMat.col1.x * tVec.x + tMat.col2.x * tVec.y;
               clipPointY = xfA.position.y + tMat.col1.y * tVec.x + tMat.col2.y * tVec.y;
               this.m_points[i].x = clipPointX + 0.5 * (radiusB - (clipPointX - planePointX) * normalX - (clipPointY - planePointY) * normalY - radiusA) * normalX;
               this.m_points[i].y = clipPointY + 0.5 * (radiusB - (clipPointX - planePointX) * normalX - (clipPointY - planePointY) * normalY - radiusA) * normalY;
            }
         }
         break;
      }
   }
   ClipVertex.ClipVertex = function () {
      this.v = new b2Vec2();
      this.id = new b2ContactID();
   };
   ClipVertex.prototype.Set = function (other) {
      this.v.SetV(other.v);
      this.id.Set(other.id);
   }
   Features.Features = function () {};
   Object.defineProperty(Features.prototype, 'referenceEdge', {
      enumerable: false,
      configurable: true,
      get: function () {
         return this._referenceEdge;
      }
   });
   Object.defineProperty(Features.prototype, 'referenceEdge', {
      enumerable: false,
      configurable: true,
      set: function (value) {
         if (value === undefined) value = 0;
         this._referenceEdge = value;
         this._m_id._key = (this._m_id._key & 0xffffff00) | (this._referenceEdge & 0x000000ff);
      }
   });
   Object.defineProperty(Features.prototype, 'incidentEdge', {
      enumerable: false,
      configurable: true,
      get: function () {
         return this._incidentEdge;
      }
   });
   Object.defineProperty(Features.prototype, 'incidentEdge', {
      enumerable: false,
      configurable: true,
      set: function (value) {
         if (value === undefined) value = 0;
         this._incidentEdge = value;
         this._m_id._key = (this._m_id._key & 0xffff00ff) | ((this._incidentEdge << 8) & 0x0000ff00);
      }
   });
   Object.defineProperty(Features.prototype, 'incidentVertex', {
      enumerable: false,
      configurable: true,
      get: function () {
         return this._incidentVertex;
      }
   });
   Object.defineProperty(Features.prototype, 'incidentVertex', {
      enumerable: false,
      configurable: true,
      set: function (value) {
         if (value === undefined) value = 0;
         this._incidentVertex = value;
         this._m_id._key = (this._m_id._key & 0xff00ffff) | ((this._incidentVertex << 16) & 0x00ff0000);
      }
   });
   Object.defineProperty(Features.prototype, 'flip', {
      enumerable: false,
      configurable: true,
      get: function () {
         return this._flip;
      }
   });
   Object.defineProperty(Features.prototype, 'flip', {
      enumerable: false,
      configurable: true,
      set: function (value) {
         if (value === undefined) value = 0;
         this._flip = value;
         this._m_id._key = (this._m_id._key & 0x00ffffff) | ((this._flip << 24) & 0xff000000);
      }
   });
})();
(function () {
   var b2Color = Box2D.Common.b2Color,
      b2internal = Box2D.Common.b2internal,
      b2Settings = Box2D.Common.b2Settings,
      b2CircleShape = Box2D.Collision.Shapes.b2CircleShape,
      b2EdgeChainDef = Box2D.Collision.Shapes.b2EdgeChainDef,
      b2EdgeShape = Box2D.Collision.Shapes.b2EdgeShape,
      b2MassData = Box2D.Collision.Shapes.b2MassData,
      b2PolygonShape = Box2D.Collision.Shapes.b2PolygonShape,
      b2Shape = Box2D.Collision.Shapes.b2Shape,
      b2Mat22 = Box2D.Common.Math.b2Mat22,
      b2Mat33 = Box2D.Common.Math.b2Mat33,
      b2Math = Box2D.Common.Math.b2Math,
      b2Sweep = Box2D.Common.Math.b2Sweep,
      b2Transform = Box2D.Common.Math.b2Transform,
      b2Vec2 = Box2D.Common.Math.b2Vec2,
      b2Vec3 = Box2D.Common.Math.b2Vec3,
      b2Body = Box2D.Dynamics.b2Body,
      b2BodyDef = Box2D.Dynamics.b2BodyDef,
      b2ContactFilter = Box2D.Dynamics.b2ContactFilter,
      b2ContactImpulse = Box2D.Dynamics.b2ContactImpulse,
      b2ContactListener = Box2D.Dynamics.b2ContactListener,
      b2ContactManager = Box2D.Dynamics.b2ContactManager,
      b2DebugDraw = Box2D.Dynamics.b2DebugDraw,
      b2DestructionListener = Box2D.Dynamics.b2DestructionListener,
      b2FilterData = Box2D.Dynamics.b2FilterData,
      b2Fixture = Box2D.Dynamics.b2Fixture,
      b2FixtureDef = Box2D.Dynamics.b2FixtureDef,
      b2Island = Box2D.Dynamics.b2Island,
      b2TimeStep = Box2D.Dynamics.b2TimeStep,
      b2World = Box2D.Dynamics.b2World,
      b2AABB = Box2D.Collision.b2AABB,
      b2Bound = Box2D.Collision.b2Bound,
      b2BoundValues = Box2D.Collision.b2BoundValues,
      b2Collision = Box2D.Collision.b2Collision,
      b2ContactID = Box2D.Collision.b2ContactID,
      b2ContactPoint = Box2D.Collision.b2ContactPoint,
      b2Distance = Box2D.Collision.b2Distance,
      b2DistanceInput = Box2D.Collision.b2DistanceInput,
      b2DistanceOutput = Box2D.Collision.b2DistanceOutput,
      b2DistanceProxy = Box2D.Collision.b2DistanceProxy,
      b2DynamicTree = Box2D.Collision.b2DynamicTree,
      b2DynamicTreeBroadPhase = Box2D.Collision.b2DynamicTreeBroadPhase,
      b2DynamicTreeNode = Box2D.Collision.b2DynamicTreeNode,
      b2DynamicTreePair = Box2D.Collision.b2DynamicTreePair,
      b2Manifold = Box2D.Collision.b2Manifold,
      b2ManifoldPoint = Box2D.Collision.b2ManifoldPoint,
      b2Point = Box2D.Collision.b2Point,
      b2RayCastInput = Box2D.Collision.b2RayCastInput,
      b2RayCastOutput = Box2D.Collision.b2RayCastOutput,
      b2Segment = Box2D.Collision.b2Segment,
      b2SeparationFunction = Box2D.Collision.b2SeparationFunction,
      b2Simplex = Box2D.Collision.b2Simplex,
      b2SimplexCache = Box2D.Collision.b2SimplexCache,
      b2SimplexVertex = Box2D.Collision.b2SimplexVertex,
      b2TimeOfImpact = Box2D.Collision.b2TimeOfImpact,
      b2TOIInput = Box2D.Collision.b2TOIInput,
      b2WorldManifold = Box2D.Collision.b2WorldManifold,
      ClipVertex = Box2D.Collision.ClipVertex,
      Features = Box2D.Collision.Features,
      IBroadPhase = Box2D.Collision.IBroadPhase;

   Box2D.inherit(b2CircleShape, Box2D.Collision.Shapes.b2Shape);
   b2CircleShape.prototype.__super = Box2D.Collision.Shapes.b2Shape.prototype;
   b2CircleShape.b2CircleShape = function () {
      Box2D.Collision.Shapes.b2Shape.b2Shape.apply(this, arguments);
      this.m_p = new b2Vec2();
   };
   b2CircleShape.prototype.Copy = function () {
      var s = new b2CircleShape();
      s.Set(this);
      return s;
   }
   b2CircleShape.prototype.Set = function (other) {
      this.__super.Set.call(this, other);
      if (Box2D.is(other, b2CircleShape)) {
         var other2 = (other instanceof b2CircleShape ? other : null);
         this.m_p.SetV(other2.m_p);
      }
   }
   b2CircleShape.prototype.TestPoint = function (transform, p) {
      var tMat = transform.R;
      var dX = transform.position.x + (tMat.col1.x * this.m_p.x + tMat.col2.x * this.m_p.y);
      var dY = transform.position.y + (tMat.col1.y * this.m_p.x + tMat.col2.y * this.m_p.y);
      dX = p.x - dX;
      dY = p.y - dY;
      return (dX * dX + dY * dY) <= this.m_radius * this.m_radius;
   }
   b2CircleShape.prototype.RayCast = function (output, input, transform) {
      var tMat = transform.R;
      var positionX = transform.position.x + (tMat.col1.x * this.m_p.x + tMat.col2.x * this.m_p.y);
      var positionY = transform.position.y + (tMat.col1.y * this.m_p.x + tMat.col2.y * this.m_p.y);
      var sX = input.p1.x - positionX;
      var sY = input.p1.y - positionY;
      var b = (sX * sX + sY * sY) - this.m_radius * this.m_radius;
      var rX = input.p2.x - input.p1.x;
      var rY = input.p2.y - input.p1.y;
      var c = (sX * rX + sY * rY);
      var rr = (rX * rX + rY * rY);
      var sigma = c * c - rr * b;
      if (sigma < 0.0 || rr < Number.MIN_VALUE) {
         return false;
      }
      var a = (-(c + Math.sqrt(sigma)));
      if (0.0 <= a && a <= input.maxFraction * rr) {
         a /= rr;
         output.fraction = a;
         output.normal.x = sX + a * rX;
         output.normal.y = sY + a * rY;
         output.normal.Normalize();
         return true;
      }
      return false;
   }
   b2CircleShape.prototype.ComputeAABB = function (aabb, transform) {
      var tMat = transform.R;
      var pX = transform.position.x + (tMat.col1.x * this.m_p.x + tMat.col2.x * this.m_p.y);
      var pY = transform.position.y + (tMat.col1.y * this.m_p.x + tMat.col2.y * this.m_p.y);
      aabb.lowerBound.Set(pX - this.m_radius, pY - this.m_radius);
      aabb.upperBound.Set(pX + this.m_radius, pY + this.m_radius);
   }
   b2CircleShape.prototype.ComputeMass = function (massData, density) {
      if (density === undefined) density = 0;
      massData.mass = density * b2Settings.b2_pi * this.m_radius * this.m_radius;
      massData.center.SetV(this.m_p);
      massData.I = massData.mass * (0.5 * this.m_radius * this.m_radius + (this.m_p.x * this.m_p.x + this.m_p.y * this.m_p.y));
   }
   b2CircleShape.prototype.ComputeSubmergedArea = function (normal, offset, xf, c) {
      if (offset === undefined) offset = 0;
      var p = b2Math.MulX(xf, this.m_p);
      var l = (-(b2Math.Dot(normal, p) - offset));
      if (l < (-this.m_radius) + Number.MIN_VALUE) {
         return 0;
      }
      if (l > this.m_radius) {
         c.SetV(p);
         return Math.PI * this.m_radius * this.m_radius;
      }
      var r2 = this.m_radius * this.m_radius;
      var l2 = l * l;
      var area = r2 * (Math.asin(l / this.m_radius) + Math.PI / 2) + l * Math.sqrt(r2 - l2);
      var com = (-2 / 3 * Math.pow(r2 - l2, 1.5) / area);
      c.x = p.x + normal.x * com;
      c.y = p.y + normal.y * com;
      return area;
   }
   b2CircleShape.prototype.GetLocalPosition = function () {
      return this.m_p;
   }
   b2CircleShape.prototype.SetLocalPosition = function (position) {
      this.m_p.SetV(position);
   }
   b2CircleShape.prototype.GetRadius = function () {
      return this.m_radius;
   }
   b2CircleShape.prototype.SetRadius = function (radius) {
      if (radius === undefined) radius = 0;
      this.m_radius = radius;
   }
   b2CircleShape.prototype.b2CircleShape = function (radius) {
      if (radius === undefined) radius = 0;
      this.__super.b2Shape.call(this);
      this.m_type = b2Shape.e_circleShape;
      this.m_radius = radius;
   }
   b2EdgeChainDef.b2EdgeChainDef = function () {};
   b2EdgeChainDef.prototype.b2EdgeChainDef = function () {
      this.vertexCount = 0;
      this.isALoop = true;
      this.vertices = [];
   }
   Box2D.inherit(b2EdgeShape, Box2D.Collision.Shapes.b2Shape);
   b2EdgeShape.prototype.__super = Box2D.Collision.Shapes.b2Shape.prototype;
   b2EdgeShape.b2EdgeShape = function () {
      Box2D.Collision.Shapes.b2Shape.b2Shape.apply(this, arguments);
      this.s_supportVec = new b2Vec2();
      this.m_v1 = new b2Vec2();
      this.m_v2 = new b2Vec2();
      this.m_coreV1 = new b2Vec2();
      this.m_coreV2 = new b2Vec2();
      this.m_normal = new b2Vec2();
      this.m_direction = new b2Vec2();
      this.m_cornerDir1 = new b2Vec2();
      this.m_cornerDir2 = new b2Vec2();
   };
   b2EdgeShape.prototype.TestPoint = function (transform, p) {
      return false;
   }
   b2EdgeShape.prototype.RayCast = function (output, input, transform) {
      var tMat;
      var rX = input.p2.x - input.p1.x;
      var rY = input.p2.y - input.p1.y;
      tMat = transform.R;
      var v1X = transform.position.x + (tMat.col1.x * this.m_v1.x + tMat.col2.x * this.m_v1.y);
      var v1Y = transform.position.y + (tMat.col1.y * this.m_v1.x + tMat.col2.y * this.m_v1.y);
      var nX = transform.position.y + (tMat.col1.y * this.m_v2.x + tMat.col2.y * this.m_v2.y) - v1Y;
      var nY = (-(transform.position.x + (tMat.col1.x * this.m_v2.x + tMat.col2.x * this.m_v2.y) - v1X));
      var k_slop = 100.0 * Number.MIN_VALUE;
      var denom = (-(rX * nX + rY * nY));
      if (denom > k_slop) {
         var bX = input.p1.x - v1X;
         var bY = input.p1.y - v1Y;
         var a = (bX * nX + bY * nY);
         if (0.0 <= a && a <= input.maxFraction * denom) {
            var mu2 = (-rX * bY) + rY * bX;
            if ((-k_slop * denom) <= mu2 && mu2 <= denom * (1.0 + k_slop)) {
               a /= denom;
               output.fraction = a;
               var nLen = Math.sqrt(nX * nX + nY * nY);
               output.normal.x = nX / nLen;
               output.normal.y = nY / nLen;
               return true;
            }
         }
      }
      return false;
   }
   b2EdgeShape.prototype.ComputeAABB = function (aabb, transform) {
      var tMat = transform.R;
      var v1X = transform.position.x + (tMat.col1.x * this.m_v1.x + tMat.col2.x * this.m_v1.y);
      var v1Y = transform.position.y + (tMat.col1.y * this.m_v1.x + tMat.col2.y * this.m_v1.y);
      var v2X = transform.position.x + (tMat.col1.x * this.m_v2.x + tMat.col2.x * this.m_v2.y);
      var v2Y = transform.position.y + (tMat.col1.y * this.m_v2.x + tMat.col2.y * this.m_v2.y);
      if (v1X < v2X) {
         aabb.lowerBound.x = v1X;
         aabb.upperBound.x = v2X;
      }
      else {
         aabb.lowerBound.x = v2X;
         aabb.upperBound.x = v1X;
      }
      if (v1Y < v2Y) {
         aabb.lowerBound.y = v1Y;
         aabb.upperBound.y = v2Y;
      }
      else {
         aabb.lowerBound.y = v2Y;
         aabb.upperBound.y = v1Y;
      }
   }
   b2EdgeShape.prototype.ComputeMass = function (massData, density) {
      if (density === undefined) density = 0;
      massData.mass = 0;
      massData.center.SetV(this.m_v1);
      massData.I = 0;
   }
   b2EdgeShape.prototype.ComputeSubmergedArea = function (normal, offset, xf, c) {
      if (offset === undefined) offset = 0;
      var v0 = new b2Vec2(normal.x * offset, normal.y * offset);
      var v1 = b2Math.MulX(xf, this.m_v1);
      var v2 = b2Math.MulX(xf, this.m_v2);
      var d1 = b2Math.Dot(normal, v1) - offset;
      var d2 = b2Math.Dot(normal, v2) - offset;
      if (d1 > 0) {
         if (d2 > 0) {
            return 0;
         }
         else {
            v1.x = (-d2 / (d1 - d2) * v1.x) + d1 / (d1 - d2) * v2.x;
            v1.y = (-d2 / (d1 - d2) * v1.y) + d1 / (d1 - d2) * v2.y;
         }
      }
      else {
         if (d2 > 0) {
            v2.x = (-d2 / (d1 - d2) * v1.x) + d1 / (d1 - d2) * v2.x;
            v2.y = (-d2 / (d1 - d2) * v1.y) + d1 / (d1 - d2) * v2.y;
         }
         else {}
      }
      c.x = (v0.x + v1.x + v2.x) / 3;
      c.y = (v0.y + v1.y + v2.y) / 3;
      return 0.5 * ((v1.x - v0.x) * (v2.y - v0.y) - (v1.y - v0.y) * (v2.x - v0.x));
   }
   b2EdgeShape.prototype.GetLength = function () {
      return this.m_length;
   }
   b2EdgeShape.prototype.GetVertex1 = function () {
      return this.m_v1;
   }
   b2EdgeShape.prototype.GetVertex2 = function () {
      return this.m_v2;
   }
   b2EdgeShape.prototype.GetCoreVertex1 = function () {
      return this.m_coreV1;
   }
   b2EdgeShape.prototype.GetCoreVertex2 = function () {
      return this.m_coreV2;
   }
   b2EdgeShape.prototype.GetNormalVector = function () {
      return this.m_normal;
   }
   b2EdgeShape.prototype.GetDirectionVector = function () {
      return this.m_direction;
   }
   b2EdgeShape.prototype.GetCorner1Vector = function () {
      return this.m_cornerDir1;
   }
   b2EdgeShape.prototype.GetCorner2Vector = function () {
      return this.m_cornerDir2;
   }
   b2EdgeShape.prototype.Corner1IsConvex = function () {
      return this.m_cornerConvex1;
   }
   b2EdgeShape.prototype.Corner2IsConvex = function () {
      return this.m_cornerConvex2;
   }
   b2EdgeShape.prototype.GetFirstVertex = function (xf) {
      var tMat = xf.R;
      return new b2Vec2(xf.position.x + (tMat.col1.x * this.m_coreV1.x + tMat.col2.x * this.m_coreV1.y), xf.position.y + (tMat.col1.y * this.m_coreV1.x + tMat.col2.y * this.m_coreV1.y));
   }
   b2EdgeShape.prototype.GetNextEdge = function () {
      return this.m_nextEdge;
   }
   b2EdgeShape.prototype.GetPrevEdge = function () {
      return this.m_prevEdge;
   }
   b2EdgeShape.prototype.Support = function (xf, dX, dY) {
      if (dX === undefined) dX = 0;
      if (dY === undefined) dY = 0;
      var tMat = xf.R;
      var v1X = xf.position.x + (tMat.col1.x * this.m_coreV1.x + tMat.col2.x * this.m_coreV1.y);
      var v1Y = xf.position.y + (tMat.col1.y * this.m_coreV1.x + tMat.col2.y * this.m_coreV1.y);
      var v2X = xf.position.x + (tMat.col1.x * this.m_coreV2.x + tMat.col2.x * this.m_coreV2.y);
      var v2Y = xf.position.y + (tMat.col1.y * this.m_coreV2.x + tMat.col2.y * this.m_coreV2.y);
      if ((v1X * dX + v1Y * dY) > (v2X * dX + v2Y * dY)) {
         this.s_supportVec.x = v1X;
         this.s_supportVec.y = v1Y;
      }
      else {
         this.s_supportVec.x = v2X;
         this.s_supportVec.y = v2Y;
      }
      return this.s_supportVec;
   }
   b2EdgeShape.prototype.b2EdgeShape = function (v1, v2) {
      this.__super.b2Shape.call(this);
      this.m_type = b2Shape.e_edgeShape;
      this.m_prevEdge = null;
      this.m_nextEdge = null;
      this.m_v1 = v1;
      this.m_v2 = v2;
      this.m_direction.Set(this.m_v2.x - this.m_v1.x, this.m_v2.y - this.m_v1.y);
      this.m_length = this.m_direction.Normalize();
      this.m_normal.Set(this.m_direction.y, (-this.m_direction.x));
      this.m_coreV1.Set((-b2Settings.b2_toiSlop * (this.m_normal.x - this.m_direction.x)) + this.m_v1.x, (-b2Settings.b2_toiSlop * (this.m_normal.y - this.m_direction.y)) + this.m_v1.y);
      this.m_coreV2.Set((-b2Settings.b2_toiSlop * (this.m_normal.x + this.m_direction.x)) + this.m_v2.x, (-b2Settings.b2_toiSlop * (this.m_normal.y + this.m_direction.y)) + this.m_v2.y);
      this.m_cornerDir1 = this.m_normal;
      this.m_cornerDir2.Set((-this.m_normal.x), (-this.m_normal.y));
   }
   b2EdgeShape.prototype.SetPrevEdge = function (edge, core, cornerDir, convex) {
      this.m_prevEdge = edge;
      this.m_coreV1 = core;
      this.m_cornerDir1 = cornerDir;
      this.m_cornerConvex1 = convex;
   }
   b2EdgeShape.prototype.SetNextEdge = function (edge, core, cornerDir, convex) {
      this.m_nextEdge = edge;
      this.m_coreV2 = core;
      this.m_cornerDir2 = cornerDir;
      this.m_cornerConvex2 = convex;
   }
   b2MassData.b2MassData = function () {
      this.mass = 0.0;
      this.center = new b2Vec2(0, 0);
      this.I = 0.0;
   };
   Box2D.inherit(b2PolygonShape, Box2D.Collision.Shapes.b2Shape);
   b2PolygonShape.prototype.__super = Box2D.Collision.Shapes.b2Shape.prototype;
   b2PolygonShape.b2PolygonShape = function () {
      Box2D.Collision.Shapes.b2Shape.b2Shape.apply(this, arguments);
   };
   b2PolygonShape.prototype.Copy = function () {
      var s = new b2PolygonShape();
      s.Set(this);
      return s;
   }
   b2PolygonShape.prototype.Set = function (other) {
      this.__super.Set.call(this, other);
      if (Box2D.is(other, b2PolygonShape)) {
         var other2 = (other instanceof b2PolygonShape ? other : null);
         this.m_centroid.SetV(other2.m_centroid);
         this.m_vertexCount = other2.m_vertexCount;
         this.Reserve(this.m_vertexCount);
         for (var i = 0; i < this.m_vertexCount; i++) {
            this.m_vertices[i].SetV(other2.m_vertices[i]);
            this.m_normals[i].SetV(other2.m_normals[i]);
         }
      }
   }
   b2PolygonShape.prototype.SetAsArray = function (vertices, vertexCount) {
      if (vertexCount === undefined) vertexCount = 0;
      var v = new Vector();
      var i = 0,
         tVec;
      for (i = 0;
      i < vertices.length; ++i) {
         tVec = vertices[i];
         v.push(tVec);
      }
      this.SetAsVector(v, vertexCount);
   }
   b2PolygonShape.AsArray = function (vertices, vertexCount) {
      if (vertexCount === undefined) vertexCount = 0;
      var polygonShape = new b2PolygonShape();
      polygonShape.SetAsArray(vertices, vertexCount);
      return polygonShape;
   }
   b2PolygonShape.prototype.SetAsVector = function (vertices, vertexCount) {
      if (vertexCount === undefined) vertexCount = 0;
      if (vertexCount == 0) vertexCount = vertices.length;
      b2Settings.b2Assert(2 <= vertexCount);
      this.m_vertexCount = vertexCount;
      this.Reserve(vertexCount);
      var i = 0;
      for (i = 0;
      i < this.m_vertexCount; i++) {
         this.m_vertices[i].SetV(vertices[i]);
      }
      for (i = 0;
      i < this.m_vertexCount; ++i) {
         var i1 = parseInt(i);
         var i2 = parseInt(i + 1 < this.m_vertexCount ? i + 1 : 0);
         var edge = b2Math.SubtractVV(this.m_vertices[i2], this.m_vertices[i1]);
         b2Settings.b2Assert(edge.LengthSquared() > Number.MIN_VALUE);
         this.m_normals[i].SetV(b2Math.CrossVF(edge, 1.0));
         this.m_normals[i].Normalize();
      }
      this.m_centroid = b2PolygonShape.ComputeCentroid(this.m_vertices, this.m_vertexCount);
   }
   b2PolygonShape.AsVector = function (vertices, vertexCount) {
      if (vertexCount === undefined) vertexCount = 0;
      var polygonShape = new b2PolygonShape();
      polygonShape.SetAsVector(vertices, vertexCount);
      return polygonShape;
   }
   b2PolygonShape.prototype.SetAsBox = function (hx, hy) {
      if (hx === undefined) hx = 0;
      if (hy === undefined) hy = 0;
      this.m_vertexCount = 4;
      this.Reserve(4);
      this.m_vertices[0].Set((-hx), (-hy));
      this.m_vertices[1].Set(hx, (-hy));
      this.m_vertices[2].Set(hx, hy);
      this.m_vertices[3].Set((-hx), hy);
      this.m_normals[0].Set(0.0, (-1.0));
      this.m_normals[1].Set(1.0, 0.0);
      this.m_normals[2].Set(0.0, 1.0);
      this.m_normals[3].Set((-1.0), 0.0);
      this.m_centroid.SetZero();
   }
   b2PolygonShape.AsBox = function (hx, hy) {
      if (hx === undefined) hx = 0;
      if (hy === undefined) hy = 0;
      var polygonShape = new b2PolygonShape();
      polygonShape.SetAsBox(hx, hy);
      return polygonShape;
   }
   b2PolygonShape.prototype.SetAsOrientedBox = function (hx, hy, center, angle) {
      if (hx === undefined) hx = 0;
      if (hy === undefined) hy = 0;
      if (center === undefined) center = null;
      if (angle === undefined) angle = 0.0;
      this.m_vertexCount = 4;
      this.Reserve(4);
      this.m_vertices[0].Set((-hx), (-hy));
      this.m_vertices[1].Set(hx, (-hy));
      this.m_vertices[2].Set(hx, hy);
      this.m_vertices[3].Set((-hx), hy);
      this.m_normals[0].Set(0.0, (-1.0));
      this.m_normals[1].Set(1.0, 0.0);
      this.m_normals[2].Set(0.0, 1.0);
      this.m_normals[3].Set((-1.0), 0.0);
      this.m_centroid = center;
      var xf = new b2Transform();
      xf.position = center;
      xf.R.Set(angle);
      for (var i = 0; i < this.m_vertexCount; ++i) {
         this.m_vertices[i] = b2Math.MulX(xf, this.m_vertices[i]);
         this.m_normals[i] = b2Math.MulMV(xf.R, this.m_normals[i]);
      }
   }
   b2PolygonShape.AsOrientedBox = function (hx, hy, center, angle) {
      if (hx === undefined) hx = 0;
      if (hy === undefined) hy = 0;
      if (center === undefined) center = null;
      if (angle === undefined) angle = 0.0;
      var polygonShape = new b2PolygonShape();
      polygonShape.SetAsOrientedBox(hx, hy, center, angle);
      return polygonShape;
   }
   b2PolygonShape.prototype.SetAsEdge = function (v1, v2) {
      this.m_vertexCount = 2;
      this.Reserve(2);
      this.m_vertices[0].SetV(v1);
      this.m_vertices[1].SetV(v2);
      this.m_centroid.x = 0.5 * (v1.x + v2.x);
      this.m_centroid.y = 0.5 * (v1.y + v2.y);
      this.m_normals[0] = b2Math.CrossVF(b2Math.SubtractVV(v2, v1), 1.0);
      this.m_normals[0].Normalize();
      this.m_normals[1].x = (-this.m_normals[0].x);
      this.m_normals[1].y = (-this.m_normals[0].y);
   }
   b2PolygonShape.AsEdge = function (v1, v2) {
      var polygonShape = new b2PolygonShape();
      polygonShape.SetAsEdge(v1, v2);
      return polygonShape;
   }
   b2PolygonShape.prototype.TestPoint = function (xf, p) {
      var tVec;
      var tMat = xf.R;
      var tX = p.x - xf.position.x;
      var tY = p.y - xf.position.y;
      var pLocalX = (tX * tMat.col1.x + tY * tMat.col1.y);
      var pLocalY = (tX * tMat.col2.x + tY * tMat.col2.y);
      for (var i = 0; i < this.m_vertexCount; ++i) {
         tVec = this.m_vertices[i];
         tX = pLocalX - tVec.x;
         tY = pLocalY - tVec.y;
         tVec = this.m_normals[i];
         var dot = (tVec.x * tX + tVec.y * tY);
         if (dot > 0.0) {
            return false;
         }
      }
      return true;
   }
   b2PolygonShape.prototype.RayCast = function (output, input, transform) {
      var lower = 0.0;
      var upper = input.maxFraction;
      var tX = 0;
      var tY = 0;
      var tMat;
      var tVec;
      tX = input.p1.x - transform.position.x;
      tY = input.p1.y - transform.position.y;
      tMat = transform.R;
      var p1X = (tX * tMat.col1.x + tY * tMat.col1.y);
      var p1Y = (tX * tMat.col2.x + tY * tMat.col2.y);
      tX = input.p2.x - transform.position.x;
      tY = input.p2.y - transform.position.y;
      tMat = transform.R;
      var p2X = (tX * tMat.col1.x + tY * tMat.col1.y);
      var p2Y = (tX * tMat.col2.x + tY * tMat.col2.y);
      var dX = p2X - p1X;
      var dY = p2Y - p1Y;
      var index = parseInt((-1));
      for (var i = 0; i < this.m_vertexCount; ++i) {
         tVec = this.m_vertices[i];
         tX = tVec.x - p1X;
         tY = tVec.y - p1Y;
         tVec = this.m_normals[i];
         var numerator = (tVec.x * tX + tVec.y * tY);
         var denominator = (tVec.x * dX + tVec.y * dY);
         if (denominator == 0.0) {
            if (numerator < 0.0) {
               return false;
            }
         }
         else {
            if (denominator < 0.0 && numerator < lower * denominator) {
               lower = numerator / denominator;
               index = i;
            }
            else if (denominator > 0.0 && numerator < upper * denominator) {
               upper = numerator / denominator;
            }
         }
         if (upper < lower - Number.MIN_VALUE) {
            return false;
         }
      }
      if (index >= 0) {
         output.fraction = lower;
         tMat = transform.R;
         tVec = this.m_normals[index];
         output.normal.x = (tMat.col1.x * tVec.x + tMat.col2.x * tVec.y);
         output.normal.y = (tMat.col1.y * tVec.x + tMat.col2.y * tVec.y);
         return true;
      }
      return false;
   }
   b2PolygonShape.prototype.ComputeAABB = function (aabb, xf) {
      var tMat = xf.R;
      var tVec = this.m_vertices[0];
      var lowerX = xf.position.x + (tMat.col1.x * tVec.x + tMat.col2.x * tVec.y);
      var lowerY = xf.position.y + (tMat.col1.y * tVec.x + tMat.col2.y * tVec.y);
      var upperX = lowerX;
      var upperY = lowerY;
      for (var i = 1; i < this.m_vertexCount; ++i) {
         tVec = this.m_vertices[i];
         var vX = xf.position.x + (tMat.col1.x * tVec.x + tMat.col2.x * tVec.y);
         var vY = xf.position.y + (tMat.col1.y * tVec.x + tMat.col2.y * tVec.y);
         lowerX = lowerX < vX ? lowerX : vX;
         lowerY = lowerY < vY ? lowerY : vY;
         upperX = upperX > vX ? upperX : vX;
         upperY = upperY > vY ? upperY : vY;
      }
      aabb.lowerBound.x = lowerX - this.m_radius;
      aabb.lowerBound.y = lowerY - this.m_radius;
      aabb.upperBound.x = upperX + this.m_radius;
      aabb.upperBound.y = upperY + this.m_radius;
   }
   b2PolygonShape.prototype.ComputeMass = function (massData, density) {
      if (density === undefined) density = 0;
      if (this.m_vertexCount == 2) {
         massData.center.x = 0.5 * (this.m_vertices[0].x + this.m_vertices[1].x);
         massData.center.y = 0.5 * (this.m_vertices[0].y + this.m_vertices[1].y);
         massData.mass = 0.0;
         massData.I = 0.0;
         return;
      }
      var centerX = 0.0;
      var centerY = 0.0;
      var area = 0.0;
      var I = 0.0;
      var p1X = 0.0;
      var p1Y = 0.0;
      var k_inv3 = 1.0 / 3.0;
      for (var i = 0; i < this.m_vertexCount; ++i) {
         var p2 = this.m_vertices[i];
         var p3 = i + 1 < this.m_vertexCount ? this.m_vertices[parseInt(i + 1)] : this.m_vertices[0];
         var e1X = p2.x - p1X;
         var e1Y = p2.y - p1Y;
         var e2X = p3.x - p1X;
         var e2Y = p3.y - p1Y;
         var D = e1X * e2Y - e1Y * e2X;
         var triangleArea = 0.5 * D;area += triangleArea;
         centerX += triangleArea * k_inv3 * (p1X + p2.x + p3.x);
         centerY += triangleArea * k_inv3 * (p1Y + p2.y + p3.y);
         var px = p1X;
         var py = p1Y;
         var ex1 = e1X;
         var ey1 = e1Y;
         var ex2 = e2X;
         var ey2 = e2Y;
         var intx2 = k_inv3 * (0.25 * (ex1 * ex1 + ex2 * ex1 + ex2 * ex2) + (px * ex1 + px * ex2)) + 0.5 * px * px;
         var inty2 = k_inv3 * (0.25 * (ey1 * ey1 + ey2 * ey1 + ey2 * ey2) + (py * ey1 + py * ey2)) + 0.5 * py * py;I += D * (intx2 + inty2);
      }
      massData.mass = density * area;
      centerX *= 1.0 / area;
      centerY *= 1.0 / area;
      massData.center.Set(centerX, centerY);
      massData.I = density * I;
   }
   b2PolygonShape.prototype.ComputeSubmergedArea = function (normal, offset, xf, c) {
      if (offset === undefined) offset = 0;
      var normalL = b2Math.MulTMV(xf.R, normal);
      var offsetL = offset - b2Math.Dot(normal, xf.position);
      var depths = new Vector_a2j_Number();
      var diveCount = 0;
      var intoIndex = parseInt((-1));
      var outoIndex = parseInt((-1));
      var lastSubmerged = false;
      var i = 0;
      for (i = 0;
      i < this.m_vertexCount; ++i) {
         depths[i] = b2Math.Dot(normalL, this.m_vertices[i]) - offsetL;
         var isSubmerged = depths[i] < (-Number.MIN_VALUE);
         if (i > 0) {
            if (isSubmerged) {
               if (!lastSubmerged) {
                  intoIndex = i - 1;
                  diveCount++;
               }
            }
            else {
               if (lastSubmerged) {
                  outoIndex = i - 1;
                  diveCount++;
               }
            }
         }
         lastSubmerged = isSubmerged;
      }
      switch (diveCount) {
      case 0:
         if (lastSubmerged) {
            var md = new b2MassData();
            this.ComputeMass(md, 1);
            c.SetV(b2Math.MulX(xf, md.center));
            return md.mass;
         }
         else {
            return 0;
         }
         break;
      case 1:
         if (intoIndex == (-1)) {
            intoIndex = this.m_vertexCount - 1;
         }
         else {
            outoIndex = this.m_vertexCount - 1;
         }
         break;
      }
      var intoIndex2 = parseInt((intoIndex + 1) % this.m_vertexCount);
      var outoIndex2 = parseInt((outoIndex + 1) % this.m_vertexCount);
      var intoLamdda = (0 - depths[intoIndex]) / (depths[intoIndex2] - depths[intoIndex]);
      var outoLamdda = (0 - depths[outoIndex]) / (depths[outoIndex2] - depths[outoIndex]);
      var intoVec = new b2Vec2(this.m_vertices[intoIndex].x * (1 - intoLamdda) + this.m_vertices[intoIndex2].x * intoLamdda, this.m_vertices[intoIndex].y * (1 - intoLamdda) + this.m_vertices[intoIndex2].y * intoLamdda);
      var outoVec = new b2Vec2(this.m_vertices[outoIndex].x * (1 - outoLamdda) + this.m_vertices[outoIndex2].x * outoLamdda, this.m_vertices[outoIndex].y * (1 - outoLamdda) + this.m_vertices[outoIndex2].y * outoLamdda);
      var area = 0;
      var center = new b2Vec2();
      var p2 = this.m_vertices[intoIndex2];
      var p3;
      i = intoIndex2;
      while (i != outoIndex2) {
         i = (i + 1) % this.m_vertexCount;
         if (i == outoIndex2) p3 = outoVec;
         else p3 = this.m_vertices[i];
         var triangleArea = 0.5 * ((p2.x - intoVec.x) * (p3.y - intoVec.y) - (p2.y - intoVec.y) * (p3.x - intoVec.x));
         area += triangleArea;
         center.x += triangleArea * (intoVec.x + p2.x + p3.x) / 3;
         center.y += triangleArea * (intoVec.y + p2.y + p3.y) / 3;
         p2 = p3;
      }
      center.Multiply(1 / area);
      c.SetV(b2Math.MulX(xf, center));
      return area;
   }
   b2PolygonShape.prototype.GetVertexCount = function () {
      return this.m_vertexCount;
   }
   b2PolygonShape.prototype.GetVertices = function () {
      return this.m_vertices;
   }
   b2PolygonShape.prototype.GetNormals = function () {
      return this.m_normals;
   }
   b2PolygonShape.prototype.GetSupport = function (d) {
      var bestIndex = 0;
      var bestValue = this.m_vertices[0].x * d.x + this.m_vertices[0].y * d.y;
      for (var i = 1; i < this.m_vertexCount; ++i) {
         var value = this.m_vertices[i].x * d.x + this.m_vertices[i].y * d.y;
         if (value > bestValue) {
            bestIndex = i;
            bestValue = value;
         }
      }
      return bestIndex;
   }
   b2PolygonShape.prototype.GetSupportVertex = function (d) {
      var bestIndex = 0;
      var bestValue = this.m_vertices[0].x * d.x + this.m_vertices[0].y * d.y;
      for (var i = 1; i < this.m_vertexCount; ++i) {
         var value = this.m_vertices[i].x * d.x + this.m_vertices[i].y * d.y;
         if (value > bestValue) {
            bestIndex = i;
            bestValue = value;
         }
      }
      return this.m_vertices[bestIndex];
   }
   b2PolygonShape.prototype.Validate = function () {
      return false;
   }
   b2PolygonShape.prototype.b2PolygonShape = function () {
      this.__super.b2Shape.call(this);
      this.m_type = b2Shape.e_polygonShape;
      this.m_centroid = new b2Vec2();
      this.m_vertices = new Vector();
      this.m_normals = new Vector();
   }
   b2PolygonShape.prototype.Reserve = function (count) {
      if (count === undefined) count = 0;
      for (var i = parseInt(this.m_vertices.length); i < count; i++) {
         this.m_vertices[i] = new b2Vec2();
         this.m_normals[i] = new b2Vec2();
      }
   }
   b2PolygonShape.ComputeCentroid = function (vs, count) {
      if (count === undefined) count = 0;
      var c = new b2Vec2();
      var area = 0.0;
      var p1X = 0.0;
      var p1Y = 0.0;
      var inv3 = 1.0 / 3.0;
      for (var i = 0; i < count; ++i) {
         var p2 = vs[i];
         var p3 = i + 1 < count ? vs[parseInt(i + 1)] : vs[0];
         var e1X = p2.x - p1X;
         var e1Y = p2.y - p1Y;
         var e2X = p3.x - p1X;
         var e2Y = p3.y - p1Y;
         var D = (e1X * e2Y - e1Y * e2X);
         var triangleArea = 0.5 * D;area += triangleArea;
         c.x += triangleArea * inv3 * (p1X + p2.x + p3.x);
         c.y += triangleArea * inv3 * (p1Y + p2.y + p3.y);
      }
      c.x *= 1.0 / area;
      c.y *= 1.0 / area;
      return c;
   }
   b2PolygonShape.ComputeOBB = function (obb, vs, count) {
      if (count === undefined) count = 0;
      var i = 0;
      var p = new Vector(count + 1);
      for (i = 0;
      i < count; ++i) {
         p[i] = vs[i];
      }
      p[count] = p[0];
      var minArea = Number.MAX_VALUE;
      for (i = 1;
      i <= count; ++i) {
         var root = p[parseInt(i - 1)];
         var uxX = p[i].x - root.x;
         var uxY = p[i].y - root.y;
         var length = Math.sqrt(uxX * uxX + uxY * uxY);
         uxX /= length;
         uxY /= length;
         var uyX = (-uxY);
         var uyY = uxX;
         var lowerX = Number.MAX_VALUE;
         var lowerY = Number.MAX_VALUE;
         var upperX = (-Number.MAX_VALUE);
         var upperY = (-Number.MAX_VALUE);
         for (var j = 0; j < count; ++j) {
            var dX = p[j].x - root.x;
            var dY = p[j].y - root.y;
            var rX = (uxX * dX + uxY * dY);
            var rY = (uyX * dX + uyY * dY);
            if (rX < lowerX) lowerX = rX;
            if (rY < lowerY) lowerY = rY;
            if (rX > upperX) upperX = rX;
            if (rY > upperY) upperY = rY;
         }
         var area = (upperX - lowerX) * (upperY - lowerY);
         if (area < 0.95 * minArea) {
            minArea = area;
            obb.R.col1.x = uxX;
            obb.R.col1.y = uxY;
            obb.R.col2.x = uyX;
            obb.R.col2.y = uyY;
            var centerX = 0.5 * (lowerX + upperX);
            var centerY = 0.5 * (lowerY + upperY);
            var tMat = obb.R;
            obb.center.x = root.x + (tMat.col1.x * centerX + tMat.col2.x * centerY);
            obb.center.y = root.y + (tMat.col1.y * centerX + tMat.col2.y * centerY);
            obb.extents.x = 0.5 * (upperX - lowerX);
            obb.extents.y = 0.5 * (upperY - lowerY);
         }
      }
   }
   Box2D.postDefs.push(function () {
      Box2D.Collision.Shapes.b2PolygonShape.s_mat = new b2Mat22();
   });
   b2Shape.b2Shape = function () {};
   b2Shape.prototype.Copy = function () {
      return null;
   }
   b2Shape.prototype.Set = function (other) {
      this.m_radius = other.m_radius;
   }
   b2Shape.prototype.GetType = function () {
      return this.m_type;
   }
   b2Shape.prototype.TestPoint = function (xf, p) {
      return false;
   }
   b2Shape.prototype.RayCast = function (output, input, transform) {
      return false;
   }
   b2Shape.prototype.ComputeAABB = function (aabb, xf) {}
   b2Shape.prototype.ComputeMass = function (massData, density) {
      if (density === undefined) density = 0;
   }
   b2Shape.prototype.ComputeSubmergedArea = function (normal, offset, xf, c) {
      if (offset === undefined) offset = 0;
      return 0;
   }
   b2Shape.TestOverlap = function (shape1, transform1, shape2, transform2) {
      var input = new b2DistanceInput();
      input.proxyA = new b2DistanceProxy();
      input.proxyA.Set(shape1);
      input.proxyB = new b2DistanceProxy();
      input.proxyB.Set(shape2);
      input.transformA = transform1;
      input.transformB = transform2;
      input.useRadii = true;
      var simplexCache = new b2SimplexCache();
      simplexCache.count = 0;
      var output = new b2DistanceOutput();
      b2Distance.Distance(output, simplexCache, input);
      return output.distance < 10.0 * Number.MIN_VALUE;
   }
   b2Shape.prototype.b2Shape = function () {
      this.m_type = b2Shape.e_unknownShape;
      this.m_radius = b2Settings.b2_linearSlop;
   }
   Box2D.postDefs.push(function () {
      Box2D.Collision.Shapes.b2Shape.e_unknownShape = parseInt((-1));
      Box2D.Collision.Shapes.b2Shape.e_circleShape = 0;
      Box2D.Collision.Shapes.b2Shape.e_polygonShape = 1;
      Box2D.Collision.Shapes.b2Shape.e_edgeShape = 2;
      Box2D.Collision.Shapes.b2Shape.e_shapeTypeCount = 3;
      Box2D.Collision.Shapes.b2Shape.e_hitCollide = 1;
      Box2D.Collision.Shapes.b2Shape.e_missCollide = 0;
      Box2D.Collision.Shapes.b2Shape.e_startsInsideCollide = parseInt((-1));
   });
})();
(function () {
   var b2Color = Box2D.Common.b2Color,
      b2internal = Box2D.Common.b2internal,
      b2Settings = Box2D.Common.b2Settings,
      b2Mat22 = Box2D.Common.Math.b2Mat22,
      b2Mat33 = Box2D.Common.Math.b2Mat33,
      b2Math = Box2D.Common.Math.b2Math,
      b2Sweep = Box2D.Common.Math.b2Sweep,
      b2Transform = Box2D.Common.Math.b2Transform,
      b2Vec2 = Box2D.Common.Math.b2Vec2,
      b2Vec3 = Box2D.Common.Math.b2Vec3;

   b2Color.b2Color = function () {
      this._r = 0;
      this._g = 0;
      this._b = 0;
   };
   b2Color.prototype.b2Color = function (rr, gg, bb) {
      if (rr === undefined) rr = 0;
      if (gg === undefined) gg = 0;
      if (bb === undefined) bb = 0;
      this._r = Box2D.parseUInt(255 * b2Math.Clamp(rr, 0.0, 1.0));
      this._g = Box2D.parseUInt(255 * b2Math.Clamp(gg, 0.0, 1.0));
      this._b = Box2D.parseUInt(255 * b2Math.Clamp(bb, 0.0, 1.0));
   }
   b2Color.prototype.Set = function (rr, gg, bb) {
      if (rr === undefined) rr = 0;
      if (gg === undefined) gg = 0;
      if (bb === undefined) bb = 0;
      this._r = Box2D.parseUInt(255 * b2Math.Clamp(rr, 0.0, 1.0));
      this._g = Box2D.parseUInt(255 * b2Math.Clamp(gg, 0.0, 1.0));
      this._b = Box2D.parseUInt(255 * b2Math.Clamp(bb, 0.0, 1.0));
   }
   Object.defineProperty(b2Color.prototype, 'r', {
      enumerable: false,
      configurable: true,
      set: function (rr) {
         if (rr === undefined) rr = 0;
         this._r = Box2D.parseUInt(255 * b2Math.Clamp(rr, 0.0, 1.0));
      }
   });
   Object.defineProperty(b2Color.prototype, 'g', {
      enumerable: false,
      configurable: true,
      set: function (gg) {
         if (gg === undefined) gg = 0;
         this._g = Box2D.parseUInt(255 * b2Math.Clamp(gg, 0.0, 1.0));
      }
   });
   Object.defineProperty(b2Color.prototype, 'b', {
      enumerable: false,
      configurable: true,
      set: function (bb) {
         if (bb === undefined) bb = 0;
         this._b = Box2D.parseUInt(255 * b2Math.Clamp(bb, 0.0, 1.0));
      }
   });
   Object.defineProperty(b2Color.prototype, 'color', {
      enumerable: false,
      configurable: true,
      get: function () {
         return (this._r << 16) | (this._g << 8) | (this._b);
      }
   });
   b2Settings.b2Settings = function () {};
   b2Settings.b2MixFriction = function (friction1, friction2) {
      if (friction1 === undefined) friction1 = 0;
      if (friction2 === undefined) friction2 = 0;
      return Math.sqrt(friction1 * friction2);
   }
   b2Settings.b2MixRestitution = function (restitution1, restitution2) {
      if (restitution1 === undefined) restitution1 = 0;
      if (restitution2 === undefined) restitution2 = 0;
      return restitution1 > restitution2 ? restitution1 : restitution2;
   }
   b2Settings.b2Assert = function (a) {
      if (!a) {
         throw "Assertion Failed";
      }
   }
   Box2D.postDefs.push(function () {
      Box2D.Common.b2Settings.VERSION = "2.1alpha";
      Box2D.Common.b2Settings.USHRT_MAX = 0x0000ffff;
      Box2D.Common.b2Settings.b2_pi = Math.PI;
      Box2D.Common.b2Settings.b2_maxManifoldPoints = 2;
      Box2D.Common.b2Settings.b2_aabbExtension = 0.1;
      Box2D.Common.b2Settings.b2_aabbMultiplier = 2.0;
      Box2D.Common.b2Settings.b2_polygonRadius = 2.0 * b2Settings.b2_linearSlop;
      Box2D.Common.b2Settings.b2_linearSlop = 0.005;
      Box2D.Common.b2Settings.b2_angularSlop = 2.0 / 180.0 * b2Settings.b2_pi;
      Box2D.Common.b2Settings.b2_toiSlop = 8.0 * b2Settings.b2_linearSlop;
      Box2D.Common.b2Settings.b2_maxTOIContactsPerIsland = 32;
      Box2D.Common.b2Settings.b2_maxTOIJointsPerIsland = 32;
      Box2D.Common.b2Settings.b2_velocityThreshold = 1.0;
      Box2D.Common.b2Settings.b2_maxLinearCorrection = 0.2;
      Box2D.Common.b2Settings.b2_maxAngularCorrection = 8.0 / 180.0 * b2Settings.b2_pi;
      Box2D.Common.b2Settings.b2_maxTranslation = 10.0;
      Box2D.Common.b2Settings.b2_maxTranslationSquared = b2Settings.b2_maxTranslation * b2Settings.b2_maxTranslation;
      Box2D.Common.b2Settings.b2_maxRotation = 0.5 * b2Settings.b2_pi;
      Box2D.Common.b2Settings.b2_maxRotationSquared = b2Settings.b2_maxRotation * b2Settings.b2_maxRotation;
      Box2D.Common.b2Settings.b2_contactBaumgarte = 0.2;
      Box2D.Common.b2Settings.b2_timeToSleep = 0.5;
      Box2D.Common.b2Settings.b2_linearSleepTolerance = 0.01;
      Box2D.Common.b2Settings.b2_angularSleepTolerance = 2.0 / 180.0 * b2Settings.b2_pi;
   });
})();
(function () {
   var b2AABB = Box2D.Collision.b2AABB,
      b2Color = Box2D.Common.b2Color,
      b2internal = Box2D.Common.b2internal,
      b2Settings = Box2D.Common.b2Settings,
      b2Mat22 = Box2D.Common.Math.b2Mat22,
      b2Mat33 = Box2D.Common.Math.b2Mat33,
      b2Math = Box2D.Common.Math.b2Math,
      b2Sweep = Box2D.Common.Math.b2Sweep,
      b2Transform = Box2D.Common.Math.b2Transform,
      b2Vec2 = Box2D.Common.Math.b2Vec2,
      b2Vec3 = Box2D.Common.Math.b2Vec3;

   b2Mat22.b2Mat22 = function () {
      this.col1 = new b2Vec2();
      this.col2 = new b2Vec2();
   };
   b2Mat22.prototype.b2Mat22 = function () {
      this.SetIdentity();
   }
   b2Mat22.FromAngle = function (angle) {
      if (angle === undefined) angle = 0;
      var mat = new b2Mat22();
      mat.Set(angle);
      return mat;
   }
   b2Mat22.FromVV = function (c1, c2) {
      var mat = new b2Mat22();
      mat.SetVV(c1, c2);
      return mat;
   }
   b2Mat22.prototype.Set = function (angle) {
      if (angle === undefined) angle = 0;
      var c = Math.cos(angle);
      var s = Math.sin(angle);
      this.col1.x = c;
      this.col2.x = (-s);
      this.col1.y = s;
      this.col2.y = c;
   }
   b2Mat22.prototype.SetVV = function (c1, c2) {
      this.col1.SetV(c1);
      this.col2.SetV(c2);
   }
   b2Mat22.prototype.Copy = function () {
      var mat = new b2Mat22();
      mat.SetM(this);
      return mat;
   }
   b2Mat22.prototype.SetM = function (m) {
      this.col1.SetV(m.col1);
      this.col2.SetV(m.col2);
   }
   b2Mat22.prototype.AddM = function (m) {
      this.col1.x += m.col1.x;
      this.col1.y += m.col1.y;
      this.col2.x += m.col2.x;
      this.col2.y += m.col2.y;
   }
   b2Mat22.prototype.SetIdentity = function () {
      this.col1.x = 1.0;
      this.col2.x = 0.0;
      this.col1.y = 0.0;
      this.col2.y = 1.0;
   }
   b2Mat22.prototype.SetZero = function () {
      this.col1.x = 0.0;
      this.col2.x = 0.0;
      this.col1.y = 0.0;
      this.col2.y = 0.0;
   }
   b2Mat22.prototype.GetAngle = function () {
      return Math.atan2(this.col1.y, this.col1.x);
   }
   b2Mat22.prototype.GetInverse = function (out) {
      var a = this.col1.x;
      var b = this.col2.x;
      var c = this.col1.y;
      var d = this.col2.y;
      var det = a * d - b * c;
      if (det != 0.0) {
         det = 1.0 / det;
      }
      out.col1.x = det * d;
      out.col2.x = (-det * b);
      out.col1.y = (-det * c);
      out.col2.y = det * a;
      return out;
   }
   b2Mat22.prototype.Solve = function (out, bX, bY) {
      if (bX === undefined) bX = 0;
      if (bY === undefined) bY = 0;
      var a11 = this.col1.x;
      var a12 = this.col2.x;
      var a21 = this.col1.y;
      var a22 = this.col2.y;
      var det = a11 * a22 - a12 * a21;
      if (det != 0.0) {
         det = 1.0 / det;
      }
      out.x = det * (a22 * bX - a12 * bY);
      out.y = det * (a11 * bY - a21 * bX);
      return out;
   }
   b2Mat22.prototype.Abs = function () {
      this.col1.Abs();
      this.col2.Abs();
   }
   b2Mat33.b2Mat33 = function () {
      this.col1 = new b2Vec3();
      this.col2 = new b2Vec3();
      this.col3 = new b2Vec3();
   };
   b2Mat33.prototype.b2Mat33 = function (c1, c2, c3) {
      if (c1 === undefined) c1 = null;
      if (c2 === undefined) c2 = null;
      if (c3 === undefined) c3 = null;
      if (!c1 && !c2 && !c3) {
         this.col1.SetZero();
         this.col2.SetZero();
         this.col3.SetZero();
      }
      else {
         this.col1.SetV(c1);
         this.col2.SetV(c2);
         this.col3.SetV(c3);
      }
   }
   b2Mat33.prototype.SetVVV = function (c1, c2, c3) {
      this.col1.SetV(c1);
      this.col2.SetV(c2);
      this.col3.SetV(c3);
   }
   b2Mat33.prototype.Copy = function () {
      return new b2Mat33(this.col1, this.col2, this.col3);
   }
   b2Mat33.prototype.SetM = function (m) {
      this.col1.SetV(m.col1);
      this.col2.SetV(m.col2);
      this.col3.SetV(m.col3);
   }
   b2Mat33.prototype.AddM = function (m) {
      this.col1.x += m.col1.x;
      this.col1.y += m.col1.y;
      this.col1.z += m.col1.z;
      this.col2.x += m.col2.x;
      this.col2.y += m.col2.y;
      this.col2.z += m.col2.z;
      this.col3.x += m.col3.x;
      this.col3.y += m.col3.y;
      this.col3.z += m.col3.z;
   }
   b2Mat33.prototype.SetIdentity = function () {
      this.col1.x = 1.0;
      this.col2.x = 0.0;
      this.col3.x = 0.0;
      this.col1.y = 0.0;
      this.col2.y = 1.0;
      this.col3.y = 0.0;
      this.col1.z = 0.0;
      this.col2.z = 0.0;
      this.col3.z = 1.0;
   }
   b2Mat33.prototype.SetZero = function () {
      this.col1.x = 0.0;
      this.col2.x = 0.0;
      this.col3.x = 0.0;
      this.col1.y = 0.0;
      this.col2.y = 0.0;
      this.col3.y = 0.0;
      this.col1.z = 0.0;
      this.col2.z = 0.0;
      this.col3.z = 0.0;
   }
   b2Mat33.prototype.Solve22 = function (out, bX, bY) {
      if (bX === undefined) bX = 0;
      if (bY === undefined) bY = 0;
      var a11 = this.col1.x;
      var a12 = this.col2.x;
      var a21 = this.col1.y;
      var a22 = this.col2.y;
      var det = a11 * a22 - a12 * a21;
      if (det != 0.0) {
         det = 1.0 / det;
      }
      out.x = det * (a22 * bX - a12 * bY);
      out.y = det * (a11 * bY - a21 * bX);
      return out;
   }
   b2Mat33.prototype.Solve33 = function (out, bX, bY, bZ) {
      if (bX === undefined) bX = 0;
      if (bY === undefined) bY = 0;
      if (bZ === undefined) bZ = 0;
      var a11 = this.col1.x;
      var a21 = this.col1.y;
      var a31 = this.col1.z;
      var a12 = this.col2.x;
      var a22 = this.col2.y;
      var a32 = this.col2.z;
      var a13 = this.col3.x;
      var a23 = this.col3.y;
      var a33 = this.col3.z;
      var det = a11 * (a22 * a33 - a32 * a23) + a21 * (a32 * a13 - a12 * a33) + a31 * (a12 * a23 - a22 * a13);
      if (det != 0.0) {
         det = 1.0 / det;
      }
      out.x = det * (bX * (a22 * a33 - a32 * a23) + bY * (a32 * a13 - a12 * a33) + bZ * (a12 * a23 - a22 * a13));
      out.y = det * (a11 * (bY * a33 - bZ * a23) + a21 * (bZ * a13 - bX * a33) + a31 * (bX * a23 - bY * a13));
      out.z = det * (a11 * (a22 * bZ - a32 * bY) + a21 * (a32 * bX - a12 * bZ) + a31 * (a12 * bY - a22 * bX));
      return out;
   }
   b2Math.b2Math = function () {};
   b2Math.IsValid = function (x) {
      if (x === undefined) x = 0;
      return isFinite(x);
   }
   b2Math.Dot = function (a, b) {
      return a.x * b.x + a.y * b.y;
   }
   b2Math.CrossVV = function (a, b) {
      return a.x * b.y - a.y * b.x;
   }
   b2Math.CrossVF = function (a, s) {
      if (s === undefined) s = 0;
      var v = new b2Vec2(s * a.y, (-s * a.x));
      return v;
   }
   b2Math.CrossFV = function (s, a) {
      if (s === undefined) s = 0;
      var v = new b2Vec2((-s * a.y), s * a.x);
      return v;
   }
   b2Math.MulMV = function (A, v) {
      var u = new b2Vec2(A.col1.x * v.x + A.col2.x * v.y, A.col1.y * v.x + A.col2.y * v.y);
      return u;
   }
   b2Math.MulTMV = function (A, v) {
      var u = new b2Vec2(b2Math.Dot(v, A.col1), b2Math.Dot(v, A.col2));
      return u;
   }
   b2Math.MulX = function (T, v) {
      var a = b2Math.MulMV(T.R, v);
      a.x += T.position.x;
      a.y += T.position.y;
      return a;
   }
   b2Math.MulXT = function (T, v) {
      var a = b2Math.SubtractVV(v, T.position);
      var tX = (a.x * T.R.col1.x + a.y * T.R.col1.y);
      a.y = (a.x * T.R.col2.x + a.y * T.R.col2.y);
      a.x = tX;
      return a;
   }
   b2Math.AddVV = function (a, b) {
      var v = new b2Vec2(a.x + b.x, a.y + b.y);
      return v;
   }
   b2Math.SubtractVV = function (a, b) {
      var v = new b2Vec2(a.x - b.x, a.y - b.y);
      return v;
   }
   b2Math.Distance = function (a, b) {
      var cX = a.x - b.x;
      var cY = a.y - b.y;
      return Math.sqrt(cX * cX + cY * cY);
   }
   b2Math.DistanceSquared = function (a, b) {
      var cX = a.x - b.x;
      var cY = a.y - b.y;
      return (cX * cX + cY * cY);
   }
   b2Math.MulFV = function (s, a) {
      if (s === undefined) s = 0;
      var v = new b2Vec2(s * a.x, s * a.y);
      return v;
   }
   b2Math.AddMM = function (A, B) {
      var C = b2Mat22.FromVV(b2Math.AddVV(A.col1, B.col1), b2Math.AddVV(A.col2, B.col2));
      return C;
   }
   b2Math.MulMM = function (A, B) {
      var C = b2Mat22.FromVV(b2Math.MulMV(A, B.col1), b2Math.MulMV(A, B.col2));
      return C;
   }
   b2Math.MulTMM = function (A, B) {
      var c1 = new b2Vec2(b2Math.Dot(A.col1, B.col1), b2Math.Dot(A.col2, B.col1));
      var c2 = new b2Vec2(b2Math.Dot(A.col1, B.col2), b2Math.Dot(A.col2, B.col2));
      var C = b2Mat22.FromVV(c1, c2);
      return C;
   }
   b2Math.Abs = function (a) {
      if (a === undefined) a = 0;
      return a > 0.0 ? a : (-a);
   }
   b2Math.AbsV = function (a) {
      var b = new b2Vec2(b2Math.Abs(a.x), b2Math.Abs(a.y));
      return b;
   }
   b2Math.AbsM = function (A) {
      var B = b2Mat22.FromVV(b2Math.AbsV(A.col1), b2Math.AbsV(A.col2));
      return B;
   }
   b2Math.Min = function (a, b) {
      if (a === undefined) a = 0;
      if (b === undefined) b = 0;
      return a < b ? a : b;
   }
   b2Math.MinV = function (a, b) {
      var c = new b2Vec2(b2Math.Min(a.x, b.x), b2Math.Min(a.y, b.y));
      return c;
   }
   b2Math.Max = function (a, b) {
      if (a === undefined) a = 0;
      if (b === undefined) b = 0;
      return a > b ? a : b;
   }
   b2Math.MaxV = function (a, b) {
      var c = new b2Vec2(b2Math.Max(a.x, b.x), b2Math.Max(a.y, b.y));
      return c;
   }
   b2Math.Clamp = function (a, low, high) {
      if (a === undefined) a = 0;
      if (low === undefined) low = 0;
      if (high === undefined) high = 0;
      return a < low ? low : a > high ? high : a;
   }
   b2Math.ClampV = function (a, low, high) {
      return b2Math.MaxV(low, b2Math.MinV(a, high));
   }
   b2Math.Swap = function (a, b) {
      var tmp = a[0];
      a[0] = b[0];
      b[0] = tmp;
   }
   b2Math.Random = function () {
      return Math.random() * 2 - 1;
   }
   b2Math.RandomRange = function (lo, hi) {
      if (lo === undefined) lo = 0;
      if (hi === undefined) hi = 0;
      var r = Math.random();
      r = (hi - lo) * r + lo;
      return r;
   }
   b2Math.NextPowerOfTwo = function (x) {
      if (x === undefined) x = 0;
      x |= (x >> 1) & 0x7FFFFFFF;
      x |= (x >> 2) & 0x3FFFFFFF;
      x |= (x >> 4) & 0x0FFFFFFF;
      x |= (x >> 8) & 0x00FFFFFF;
      x |= (x >> 16) & 0x0000FFFF;
      return x + 1;
   }
   b2Math.IsPowerOfTwo = function (x) {
      if (x === undefined) x = 0;
      var result = x > 0 && (x & (x - 1)) == 0;
      return result;
   }
   Box2D.postDefs.push(function () {
      Box2D.Common.Math.b2Math.b2Vec2_zero = new b2Vec2(0.0, 0.0);
      Box2D.Common.Math.b2Math.b2Mat22_identity = b2Mat22.FromVV(new b2Vec2(1.0, 0.0), new b2Vec2(0.0, 1.0));
      Box2D.Common.Math.b2Math.b2Transform_identity = new b2Transform(b2Math.b2Vec2_zero, b2Math.b2Mat22_identity);
   });
   b2Sweep.b2Sweep = function () {
      this.localCenter = new b2Vec2();
      this.c0 = new b2Vec2;
      this.c = new b2Vec2();
   };
   b2Sweep.prototype.Set = function (other) {
      this.localCenter.SetV(other.localCenter);
      this.c0.SetV(other.c0);
      this.c.SetV(other.c);
      this.a0 = other.a0;
      this.a = other.a;
      this.t0 = other.t0;
   }
   b2Sweep.prototype.Copy = function () {
      var copy = new b2Sweep();
      copy.localCenter.SetV(this.localCenter);
      copy.c0.SetV(this.c0);
      copy.c.SetV(this.c);
      copy.a0 = this.a0;
      copy.a = this.a;
      copy.t0 = this.t0;
      return copy;
   }
   b2Sweep.prototype.GetTransform = function (xf, alpha) {
      if (alpha === undefined) alpha = 0;
      xf.position.x = (1.0 - alpha) * this.c0.x + alpha * this.c.x;
      xf.position.y = (1.0 - alpha) * this.c0.y + alpha * this.c.y;
      var angle = (1.0 - alpha) * this.a0 + alpha * this.a;
      xf.R.Set(angle);
      var tMat = xf.R;
      xf.position.x -= (tMat.col1.x * this.localCenter.x + tMat.col2.x * this.localCenter.y);
      xf.position.y -= (tMat.col1.y * this.localCenter.x + tMat.col2.y * this.localCenter.y);
   }
   b2Sweep.prototype.Advance = function (t) {
      if (t === undefined) t = 0;
      if (this.t0 < t && 1.0 - this.t0 > Number.MIN_VALUE) {
         var alpha = (t - this.t0) / (1.0 - this.t0);
         this.c0.x = (1.0 - alpha) * this.c0.x + alpha * this.c.x;
         this.c0.y = (1.0 - alpha) * this.c0.y + alpha * this.c.y;
         this.a0 = (1.0 - alpha) * this.a0 + alpha * this.a;
         this.t0 = t;
      }
   }
   b2Transform.b2Transform = function () {
      this.position = new b2Vec2;
      this.R = new b2Mat22();
   };
   b2Transform.prototype.b2Transform = function (pos, r) {
      if (pos === undefined) pos = null;
      if (r === undefined) r = null;
      if (pos) {
         this.position.SetV(pos);
         this.R.SetM(r);
      }
   }
   b2Transform.prototype.Initialize = function (pos, r) {
      this.position.SetV(pos);
      this.R.SetM(r);
   }
   b2Transform.prototype.SetIdentity = function () {
      this.position.SetZero();
      this.R.SetIdentity();
   }
   b2Transform.prototype.Set = function (x) {
      this.position.SetV(x.position);
      this.R.SetM(x.R);
   }
   b2Transform.prototype.GetAngle = function () {
      return Math.atan2(this.R.col1.y, this.R.col1.x);
   }
   b2Vec2.b2Vec2 = function () {};
   b2Vec2.prototype.b2Vec2 = function (x_, y_) {
      if (x_ === undefined) x_ = 0;
      if (y_ === undefined) y_ = 0;
      this.x = x_;
      this.y = y_;
   }
   b2Vec2.prototype.SetZero = function () {
      this.x = 0.0;
      this.y = 0.0;
   }
   b2Vec2.prototype.Set = function (x_, y_) {
      if (x_ === undefined) x_ = 0;
      if (y_ === undefined) y_ = 0;
      this.x = x_;
      this.y = y_;
   }
   b2Vec2.prototype.SetV = function (v) {
      this.x = v.x;
      this.y = v.y;
   }
   b2Vec2.prototype.GetNegative = function () {
      return new b2Vec2((-this.x), (-this.y));
   }
   b2Vec2.prototype.NegativeSelf = function () {
      this.x = (-this.x);
      this.y = (-this.y);
   }
   b2Vec2.Make = function (x_, y_) {
      if (x_ === undefined) x_ = 0;
      if (y_ === undefined) y_ = 0;
      return new b2Vec2(x_, y_);
   }
   b2Vec2.prototype.Copy = function () {
      return new b2Vec2(this.x, this.y);
   }
   b2Vec2.prototype.Add = function (v) {
      this.x += v.x;
      this.y += v.y;
   }
   b2Vec2.prototype.Subtract = function (v) {
      this.x -= v.x;
      this.y -= v.y;
   }
   b2Vec2.prototype.Multiply = function (a) {
      if (a === undefined) a = 0;
      this.x *= a;
      this.y *= a;
   }
   b2Vec2.prototype.MulM = function (A) {
      var tX = this.x;
      this.x = A.col1.x * tX + A.col2.x * this.y;
      this.y = A.col1.y * tX + A.col2.y * this.y;
   }
   b2Vec2.prototype.MulTM = function (A) {
      var tX = b2Math.Dot(this, A.col1);
      this.y = b2Math.Dot(this, A.col2);
      this.x = tX;
   }
   b2Vec2.prototype.CrossVF = function (s) {
      if (s === undefined) s = 0;
      var tX = this.x;
      this.x = s * this.y;
      this.y = (-s * tX);
   }
   b2Vec2.prototype.CrossFV = function (s) {
      if (s === undefined) s = 0;
      var tX = this.x;
      this.x = (-s * this.y);
      this.y = s * tX;
   }
   b2Vec2.prototype.MinV = function (b) {
      this.x = this.x < b.x ? this.x : b.x;
      this.y = this.y < b.y ? this.y : b.y;
   }
   b2Vec2.prototype.MaxV = function (b) {
      this.x = this.x > b.x ? this.x : b.x;
      this.y = this.y > b.y ? this.y : b.y;
   }
   b2Vec2.prototype.Abs = function () {
      if (this.x < 0) this.x = (-this.x);
      if (this.y < 0) this.y = (-this.y);
   }
   b2Vec2.prototype.Length = function () {
      return Math.sqrt(this.x * this.x + this.y * this.y);
   }
   b2Vec2.prototype.LengthSquared = function () {
      return (this.x * this.x + this.y * this.y);
   }
   b2Vec2.prototype.Normalize = function () {
      var length = Math.sqrt(this.x * this.x + this.y * this.y);
      if (length < Number.MIN_VALUE) {
         return 0.0;
      }
      var invLength = 1.0 / length;
      this.x *= invLength;
      this.y *= invLength;
      return length;
   }
   b2Vec2.prototype.IsValid = function () {
      return b2Math.IsValid(this.x) && b2Math.IsValid(this.y);
   }
   b2Vec3.b2Vec3 = function () {};
   b2Vec3.prototype.b2Vec3 = function (x, y, z) {
      if (x === undefined) x = 0;
      if (y === undefined) y = 0;
      if (z === undefined) z = 0;
      this.x = x;
      this.y = y;
      this.z = z;
   }
   b2Vec3.prototype.SetZero = function () {
      this.x = this.y = this.z = 0.0;
   }
   b2Vec3.prototype.Set = function (x, y, z) {
      if (x === undefined) x = 0;
      if (y === undefined) y = 0;
      if (z === undefined) z = 0;
      this.x = x;
      this.y = y;
      this.z = z;
   }
   b2Vec3.prototype.SetV = function (v) {
      this.x = v.x;
      this.y = v.y;
      this.z = v.z;
   }
   b2Vec3.prototype.GetNegative = function () {
      return new b2Vec3((-this.x), (-this.y), (-this.z));
   }
   b2Vec3.prototype.NegativeSelf = function () {
      this.x = (-this.x);
      this.y = (-this.y);
      this.z = (-this.z);
   }
   b2Vec3.prototype.Copy = function () {
      return new b2Vec3(this.x, this.y, this.z);
   }
   b2Vec3.prototype.Add = function (v) {
      this.x += v.x;
      this.y += v.y;
      this.z += v.z;
   }
   b2Vec3.prototype.Subtract = function (v) {
      this.x -= v.x;
      this.y -= v.y;
      this.z -= v.z;
   }
   b2Vec3.prototype.Multiply = function (a) {
      if (a === undefined) a = 0;
      this.x *= a;
      this.y *= a;
      this.z *= a;
   }
})();
(function () {
   var b2ControllerEdge = Box2D.Dynamics.Controllers.b2ControllerEdge,
      b2Mat22 = Box2D.Common.Math.b2Mat22,
      b2Mat33 = Box2D.Common.Math.b2Mat33,
      b2Math = Box2D.Common.Math.b2Math,
      b2Sweep = Box2D.Common.Math.b2Sweep,
      b2Transform = Box2D.Common.Math.b2Transform,
      b2Vec2 = Box2D.Common.Math.b2Vec2,
      b2Vec3 = Box2D.Common.Math.b2Vec3,
      b2Color = Box2D.Common.b2Color,
      b2internal = Box2D.Common.b2internal,
      b2Settings = Box2D.Common.b2Settings,
      b2AABB = Box2D.Collision.b2AABB,
      b2Bound = Box2D.Collision.b2Bound,
      b2BoundValues = Box2D.Collision.b2BoundValues,
      b2Collision = Box2D.Collision.b2Collision,
      b2ContactID = Box2D.Collision.b2ContactID,
      b2ContactPoint = Box2D.Collision.b2ContactPoint,
      b2Distance = Box2D.Collision.b2Distance,
      b2DistanceInput = Box2D.Collision.b2DistanceInput,
      b2DistanceOutput = Box2D.Collision.b2DistanceOutput,
      b2DistanceProxy = Box2D.Collision.b2DistanceProxy,
      b2DynamicTree = Box2D.Collision.b2DynamicTree,
      b2DynamicTreeBroadPhase = Box2D.Collision.b2DynamicTreeBroadPhase,
      b2DynamicTreeNode = Box2D.Collision.b2DynamicTreeNode,
      b2DynamicTreePair = Box2D.Collision.b2DynamicTreePair,
      b2Manifold = Box2D.Collision.b2Manifold,
      b2ManifoldPoint = Box2D.Collision.b2ManifoldPoint,
      b2Point = Box2D.Collision.b2Point,
      b2RayCastInput = Box2D.Collision.b2RayCastInput,
      b2RayCastOutput = Box2D.Collision.b2RayCastOutput,
      b2Segment = Box2D.Collision.b2Segment,
      b2SeparationFunction = Box2D.Collision.b2SeparationFunction,
      b2Simplex = Box2D.Collision.b2Simplex,
      b2SimplexCache = Box2D.Collision.b2SimplexCache,
      b2SimplexVertex = Box2D.Collision.b2SimplexVertex,
      b2TimeOfImpact = Box2D.Collision.b2TimeOfImpact,
      b2TOIInput = Box2D.Collision.b2TOIInput,
      b2WorldManifold = Box2D.Collision.b2WorldManifold,
      ClipVertex = Box2D.Collision.ClipVertex,
      Features = Box2D.Collision.Features,
      IBroadPhase = Box2D.Collision.IBroadPhase,
      b2CircleShape = Box2D.Collision.Shapes.b2CircleShape,
      b2EdgeChainDef = Box2D.Collision.Shapes.b2EdgeChainDef,
      b2EdgeShape = Box2D.Collision.Shapes.b2EdgeShape,
      b2MassData = Box2D.Collision.Shapes.b2MassData,
      b2PolygonShape = Box2D.Collision.Shapes.b2PolygonShape,
      b2Shape = Box2D.Collision.Shapes.b2Shape,
      b2Body = Box2D.Dynamics.b2Body,
      b2BodyDef = Box2D.Dynamics.b2BodyDef,
      b2ContactFilter = Box2D.Dynamics.b2ContactFilter,
      b2ContactImpulse = Box2D.Dynamics.b2ContactImpulse,
      b2ContactListener = Box2D.Dynamics.b2ContactListener,
      b2ContactManager = Box2D.Dynamics.b2ContactManager,
      b2DebugDraw = Box2D.Dynamics.b2DebugDraw,
      b2DestructionListener = Box2D.Dynamics.b2DestructionListener,
      b2FilterData = Box2D.Dynamics.b2FilterData,
      b2Fixture = Box2D.Dynamics.b2Fixture,
      b2FixtureDef = Box2D.Dynamics.b2FixtureDef,
      b2Island = Box2D.Dynamics.b2Island,
      b2TimeStep = Box2D.Dynamics.b2TimeStep,
      b2World = Box2D.Dynamics.b2World,
      b2CircleContact = Box2D.Dynamics.Contacts.b2CircleContact,
      b2Contact = Box2D.Dynamics.Contacts.b2Contact,
      b2ContactConstraint = Box2D.Dynamics.Contacts.b2ContactConstraint,
      b2ContactConstraintPoint = Box2D.Dynamics.Contacts.b2ContactConstraintPoint,
      b2ContactEdge = Box2D.Dynamics.Contacts.b2ContactEdge,
      b2ContactFactory = Box2D.Dynamics.Contacts.b2ContactFactory,
      b2ContactRegister = Box2D.Dynamics.Contacts.b2ContactRegister,
      b2ContactResult = Box2D.Dynamics.Contacts.b2ContactResult,
      b2ContactSolver = Box2D.Dynamics.Contacts.b2ContactSolver,
      b2EdgeAndCircleContact = Box2D.Dynamics.Contacts.b2EdgeAndCircleContact,
      b2NullContact = Box2D.Dynamics.Contacts.b2NullContact,
      b2PolyAndCircleContact = Box2D.Dynamics.Contacts.b2PolyAndCircleContact,
      b2PolyAndEdgeContact = Box2D.Dynamics.Contacts.b2PolyAndEdgeContact,
      b2PolygonContact = Box2D.Dynamics.Contacts.b2PolygonContact,
      b2PositionSolverManifold = Box2D.Dynamics.Contacts.b2PositionSolverManifold,
      b2Controller = Box2D.Dynamics.Controllers.b2Controller,
      b2DistanceJoint = Box2D.Dynamics.Joints.b2DistanceJoint,
      b2DistanceJointDef = Box2D.Dynamics.Joints.b2DistanceJointDef,
      b2FrictionJoint = Box2D.Dynamics.Joints.b2FrictionJoint,
      b2FrictionJointDef = Box2D.Dynamics.Joints.b2FrictionJointDef,
      b2GearJoint = Box2D.Dynamics.Joints.b2GearJoint,
      b2GearJointDef = Box2D.Dynamics.Joints.b2GearJointDef,
      b2Jacobian = Box2D.Dynamics.Joints.b2Jacobian,
      b2Joint = Box2D.Dynamics.Joints.b2Joint,
      b2JointDef = Box2D.Dynamics.Joints.b2JointDef,
      b2JointEdge = Box2D.Dynamics.Joints.b2JointEdge,
      b2LineJoint = Box2D.Dynamics.Joints.b2LineJoint,
      b2LineJointDef = Box2D.Dynamics.Joints.b2LineJointDef,
      b2MouseJoint = Box2D.Dynamics.Joints.b2MouseJoint,
      b2MouseJointDef = Box2D.Dynamics.Joints.b2MouseJointDef,
      b2PrismaticJoint = Box2D.Dynamics.Joints.b2PrismaticJoint,
      b2PrismaticJointDef = Box2D.Dynamics.Joints.b2PrismaticJointDef,
      b2PulleyJoint = Box2D.Dynamics.Joints.b2PulleyJoint,
      b2PulleyJointDef = Box2D.Dynamics.Joints.b2PulleyJointDef,
      b2RevoluteJoint = Box2D.Dynamics.Joints.b2RevoluteJoint,
      b2RevoluteJointDef = Box2D.Dynamics.Joints.b2RevoluteJointDef,
      b2WeldJoint = Box2D.Dynamics.Joints.b2WeldJoint,
      b2WeldJointDef = Box2D.Dynamics.Joints.b2WeldJointDef;

   b2Body.b2Body = function () {
      this.m_xf = new b2Transform();
      this.m_sweep = new b2Sweep();
      this.m_linearVelocity = new b2Vec2();
      this.m_force = new b2Vec2();
   };
   b2Body.prototype.connectEdges = function (s1, s2, angle1) {
      if (angle1 === undefined) angle1 = 0;
      var angle2 = Math.atan2(s2.GetDirectionVector().y, s2.GetDirectionVector().x);
      var coreOffset = Math.tan((angle2 - angle1) * 0.5);
      var core = b2Math.MulFV(coreOffset, s2.GetDirectionVector());
      core = b2Math.SubtractVV(core, s2.GetNormalVector());
      core = b2Math.MulFV(b2Settings.b2_toiSlop, core);
      core = b2Math.AddVV(core, s2.GetVertex1());
      var cornerDir = b2Math.AddVV(s1.GetDirectionVector(), s2.GetDirectionVector());
      cornerDir.Normalize();
      var convex = b2Math.Dot(s1.GetDirectionVector(), s2.GetNormalVector()) > 0.0;
      s1.SetNextEdge(s2, core, cornerDir, convex);
      s2.SetPrevEdge(s1, core, cornerDir, convex);
      return angle2;
   }
   b2Body.prototype.CreateFixture = function (def) {
      if (this.m_world.IsLocked() == true) {
         return null;
      }
      var fixture = new b2Fixture();
      fixture.Create(this, this.m_xf, def);
      if (this.m_flags & b2Body.e_activeFlag) {
         var broadPhase = this.m_world.m_contactManager.m_broadPhase;
         fixture.CreateProxy(broadPhase, this.m_xf);
      }
      fixture.m_next = this.m_fixtureList;
      this.m_fixtureList = fixture;
      ++this.m_fixtureCount;
      fixture.m_body = this;
      if (fixture.m_density > 0.0) {
         this.ResetMassData();
      }
      this.m_world.m_flags |= b2World.e_newFixture;
      return fixture;
   }
   b2Body.prototype.CreateFixture2 = function (shape, density) {
      if (density === undefined) density = 0.0;
      var def = new b2FixtureDef();
      def.shape = shape;
      def.density = density;
      return this.CreateFixture(def);
   }
   b2Body.prototype.DestroyFixture = function (fixture) {
      if (this.m_world.IsLocked() == true) {
         return;
      }
      var node = this.m_fixtureList;
      var ppF = null;
      var found = false;
      while (node != null) {
         if (node == fixture) {
            if (ppF) ppF.m_next = fixture.m_next;
            else this.m_fixtureList = fixture.m_next;
            found = true;
            break;
         }
         ppF = node;
         node = node.m_next;
      }
      var edge = this.m_contactList;
      while (edge) {
         var c = edge.contact;
         edge = edge.next;
         var fixtureA = c.GetFixtureA();
         var fixtureB = c.GetFixtureB();
         if (fixture == fixtureA || fixture == fixtureB) {
            this.m_world.m_contactManager.Destroy(c);
         }
      }
      if (this.m_flags & b2Body.e_activeFlag) {
         var broadPhase = this.m_world.m_contactManager.m_broadPhase;
         fixture.DestroyProxy(broadPhase);
      }
      else {}
      fixture.Destroy();
      fixture.m_body = null;
      fixture.m_next = null;
      --this.m_fixtureCount;
      this.ResetMassData();
   }
   b2Body.prototype.SetPositionAndAngle = function (position, angle) {
      if (angle === undefined) angle = 0;
      var f;
      if (this.m_world.IsLocked() == true) {
         return;
      }
      this.m_xf.R.Set(angle);
      this.m_xf.position.SetV(position);
      var tMat = this.m_xf.R;
      var tVec = this.m_sweep.localCenter;
      this.m_sweep.c.x = (tMat.col1.x * tVec.x + tMat.col2.x * tVec.y);
      this.m_sweep.c.y = (tMat.col1.y * tVec.x + tMat.col2.y * tVec.y);
      this.m_sweep.c.x += this.m_xf.position.x;
      this.m_sweep.c.y += this.m_xf.position.y;
      this.m_sweep.c0.SetV(this.m_sweep.c);
      this.m_sweep.a0 = this.m_sweep.a = angle;
      var broadPhase = this.m_world.m_contactManager.m_broadPhase;
      for (f = this.m_fixtureList;
      f; f = f.m_next) {
         f.Synchronize(broadPhase, this.m_xf, this.m_xf);
      }
      this.m_world.m_contactManager.FindNewContacts();
   }
   b2Body.prototype.SetTransform = function (xf) {
      this.SetPositionAndAngle(xf.position, xf.GetAngle());
   }
   b2Body.prototype.GetTransform = function () {
      return this.m_xf;
   }
   b2Body.prototype.GetPosition = function () {
      return this.m_xf.position;
   }
   b2Body.prototype.SetPosition = function (position) {
      this.SetPositionAndAngle(position, this.GetAngle());
   }
   b2Body.prototype.GetAngle = function () {
      return this.m_sweep.a;
   }
   b2Body.prototype.SetAngle = function (angle) {
      if (angle === undefined) angle = 0;
      this.SetPositionAndAngle(this.GetPosition(), angle);
   }
   b2Body.prototype.GetWorldCenter = function () {
      return this.m_sweep.c;
   }
   b2Body.prototype.GetLocalCenter = function () {
      return this.m_sweep.localCenter;
   }
   b2Body.prototype.SetLinearVelocity = function (v) {
      if (this.m_type == b2Body.b2_staticBody) {
         return;
      }
      this.m_linearVelocity.SetV(v);
   }
   b2Body.prototype.GetLinearVelocity = function () {
      return this.m_linearVelocity;
   }
   b2Body.prototype.SetAngularVelocity = function (omega) {
      if (omega === undefined) omega = 0;
      if (this.m_type == b2Body.b2_staticBody) {
         return;
      }
      this.m_angularVelocity = omega;
   }
   b2Body.prototype.GetAngularVelocity = function () {
      return this.m_angularVelocity;
   }
   b2Body.prototype.GetDefinition = function () {
      var bd = new b2BodyDef();
      bd.type = this.GetType();
      bd.allowSleep = (this.m_flags & b2Body.e_allowSleepFlag) == b2Body.e_allowSleepFlag;
      bd.angle = this.GetAngle();
      bd.angularDamping = this.m_angularDamping;
      bd.angularVelocity = this.m_angularVelocity;
      bd.fixedRotation = (this.m_flags & b2Body.e_fixedRotationFlag) == b2Body.e_fixedRotationFlag;
      bd.bullet = (this.m_flags & b2Body.e_bulletFlag) == b2Body.e_bulletFlag;
      bd.awake = (this.m_flags & b2Body.e_awakeFlag) == b2Body.e_awakeFlag;
      bd.linearDamping = this.m_linearDamping;
      bd.linearVelocity.SetV(this.GetLinearVelocity());
      bd.position = this.GetPosition();
      bd.userData = this.GetUserData();
      return bd;
   }
   b2Body.prototype.ApplyForce = function (force, point) {
      if (this.m_type != b2Body.b2_dynamicBody) {
         return;
      }
      if (this.IsAwake() == false) {
         this.SetAwake(true);
      }
      this.m_force.x += force.x;
      this.m_force.y += force.y;
      this.m_torque += ((point.x - this.m_sweep.c.x) * force.y - (point.y - this.m_sweep.c.y) * force.x);
   }
   b2Body.prototype.ApplyTorque = function (torque) {
      if (torque === undefined) torque = 0;
      if (this.m_type != b2Body.b2_dynamicBody) {
         return;
      }
      if (this.IsAwake() == false) {
         this.SetAwake(true);
      }
      this.m_torque += torque;
   }
   b2Body.prototype.ApplyImpulse = function (impulse, point) {
      if (this.m_type != b2Body.b2_dynamicBody) {
         return;
      }
      if (this.IsAwake() == false) {
         this.SetAwake(true);
      }
      this.m_linearVelocity.x += this.m_invMass * impulse.x;
      this.m_linearVelocity.y += this.m_invMass * impulse.y;
      this.m_angularVelocity += this.m_invI * ((point.x - this.m_sweep.c.x) * impulse.y - (point.y - this.m_sweep.c.y) * impulse.x);
   }
   b2Body.prototype.Split = function (callback) {
      var linearVelocity = this.GetLinearVelocity().Copy();
      var angularVelocity = this.GetAngularVelocity();
      var center = this.GetWorldCenter();
      var body1 = this;
      var body2 = this.m_world.CreateBody(this.GetDefinition());
      var prev;
      for (var f = body1.m_fixtureList; f;) {
         if (callback(f)) {
            var next = f.m_next;
            if (prev) {
               prev.m_next = next;
            }
            else {
               body1.m_fixtureList = next;
            }
            body1.m_fixtureCount--;
            f.m_next = body2.m_fixtureList;
            body2.m_fixtureList = f;
            body2.m_fixtureCount++;
            f.m_body = body2;
            f = next;
         }
         else {
            prev = f;
            f = f.m_next;
         }
      }
      body1.ResetMassData();
      body2.ResetMassData();
      var center1 = body1.GetWorldCenter();
      var center2 = body2.GetWorldCenter();
      var velocity1 = b2Math.AddVV(linearVelocity, b2Math.CrossFV(angularVelocity, b2Math.SubtractVV(center1, center)));
      var velocity2 = b2Math.AddVV(linearVelocity, b2Math.CrossFV(angularVelocity, b2Math.SubtractVV(center2, center)));
      body1.SetLinearVelocity(velocity1);
      body2.SetLinearVelocity(velocity2);
      body1.SetAngularVelocity(angularVelocity);
      body2.SetAngularVelocity(angularVelocity);
      body1.SynchronizeFixtures();
      body2.SynchronizeFixtures();
      return body2;
   }
   b2Body.prototype.Merge = function (other) {
      var f;
      for (f = other.m_fixtureList;
      f;) {
         var next = f.m_next;
         other.m_fixtureCount--;
         f.m_next = this.m_fixtureList;
         this.m_fixtureList = f;
         this.m_fixtureCount++;
         f.m_body = body2;
         f = next;
      }
      body1.m_fixtureCount = 0;
      var body1 = this;
      var body2 = other;
      var center1 = body1.GetWorldCenter();
      var center2 = body2.GetWorldCenter();
      var velocity1 = body1.GetLinearVelocity().Copy();
      var velocity2 = body2.GetLinearVelocity().Copy();
      var angular1 = body1.GetAngularVelocity();
      var angular = body2.GetAngularVelocity();
      body1.ResetMassData();
      this.SynchronizeFixtures();
   }
   b2Body.prototype.GetMass = function () {
      return this.m_mass;
   }
   b2Body.prototype.GetInertia = function () {
      return this.m_I;
   }
   b2Body.prototype.GetMassData = function (data) {
      data.mass = this.m_mass;
      data.I = this.m_I;
      data.center.SetV(this.m_sweep.localCenter);
   }
   b2Body.prototype.SetMassData = function (massData) {
      b2Settings.b2Assert(this.m_world.IsLocked() == false);
      if (this.m_world.IsLocked() == true) {
         return;
      }
      if (this.m_type != b2Body.b2_dynamicBody) {
         return;
      }
      this.m_invMass = 0.0;
      this.m_I = 0.0;
      this.m_invI = 0.0;
      this.m_mass = massData.mass;
      if (this.m_mass <= 0.0) {
         this.m_mass = 1.0;
      }
      this.m_invMass = 1.0 / this.m_mass;
      if (massData.I > 0.0 && (this.m_flags & b2Body.e_fixedRotationFlag) == 0) {
         this.m_I = massData.I - this.m_mass * (massData.center.x * massData.center.x + massData.center.y * massData.center.y);
         this.m_invI = 1.0 / this.m_I;
      }
      var oldCenter = this.m_sweep.c.Copy();
      this.m_sweep.localCenter.SetV(massData.center);
      this.m_sweep.c0.SetV(b2Math.MulX(this.m_xf, this.m_sweep.localCenter));
      this.m_sweep.c.SetV(this.m_sweep.c0);
      this.m_linearVelocity.x += this.m_angularVelocity * (-(this.m_sweep.c.y - oldCenter.y));
      this.m_linearVelocity.y += this.m_angularVelocity * (+(this.m_sweep.c.x - oldCenter.x));
   }
   b2Body.prototype.ResetMassData = function () {
      this.m_mass = 0.0;
      this.m_invMass = 0.0;
      this.m_I = 0.0;
      this.m_invI = 0.0;
      this.m_sweep.localCenter.SetZero();
      if (this.m_type == b2Body.b2_staticBody || this.m_type == b2Body.b2_kinematicBody) {
         return;
      }
      var center = b2Vec2.Make(0, 0);
      for (var f = this.m_fixtureList; f; f = f.m_next) {
         if (f.m_density == 0.0) {
            continue;
         }
         var massData = f.GetMassData();
         this.m_mass += massData.mass;
         center.x += massData.center.x * massData.mass;
         center.y += massData.center.y * massData.mass;
         this.m_I += massData.I;
      }
      if (this.m_mass > 0.0) {
         this.m_invMass = 1.0 / this.m_mass;
         center.x *= this.m_invMass;
         center.y *= this.m_invMass;
      }
      else {
         this.m_mass = 1.0;
         this.m_invMass = 1.0;
      }
      if (this.m_I > 0.0 && (this.m_flags & b2Body.e_fixedRotationFlag) == 0) {
         this.m_I -= this.m_mass * (center.x * center.x + center.y * center.y);
         this.m_I *= this.m_inertiaScale;
         b2Settings.b2Assert(this.m_I > 0);
         this.m_invI = 1.0 / this.m_I;
      }
      else {
         this.m_I = 0.0;
         this.m_invI = 0.0;
      }
      var oldCenter = this.m_sweep.c.Copy();
      this.m_sweep.localCenter.SetV(center);
      this.m_sweep.c0.SetV(b2Math.MulX(this.m_xf, this.m_sweep.localCenter));
      this.m_sweep.c.SetV(this.m_sweep.c0);
      this.m_linearVelocity.x += this.m_angularVelocity * (-(this.m_sweep.c.y - oldCenter.y));
      this.m_linearVelocity.y += this.m_angularVelocity * (+(this.m_sweep.c.x - oldCenter.x));
   }
   b2Body.prototype.GetWorldPoint = function (localPoint) {
      var A = this.m_xf.R;
      var u = new b2Vec2(A.col1.x * localPoint.x + A.col2.x * localPoint.y, A.col1.y * localPoint.x + A.col2.y * localPoint.y);
      u.x += this.m_xf.position.x;
      u.y += this.m_xf.position.y;
      return u;
   }
   b2Body.prototype.GetWorldVector = function (localVector) {
      return b2Math.MulMV(this.m_xf.R, localVector);
   }
   b2Body.prototype.GetLocalPoint = function (worldPoint) {
      return b2Math.MulXT(this.m_xf, worldPoint);
   }
   b2Body.prototype.GetLocalVector = function (worldVector) {
      return b2Math.MulTMV(this.m_xf.R, worldVector);
   }
   b2Body.prototype.GetLinearVelocityFromWorldPoint = function (worldPoint) {
      return new b2Vec2(this.m_linearVelocity.x - this.m_angularVelocity * (worldPoint.y - this.m_sweep.c.y), this.m_linearVelocity.y + this.m_angularVelocity * (worldPoint.x - this.m_sweep.c.x));
   }
   b2Body.prototype.GetLinearVelocityFromLocalPoint = function (localPoint) {
      var A = this.m_xf.R;
      var worldPoint = new b2Vec2(A.col1.x * localPoint.x + A.col2.x * localPoint.y, A.col1.y * localPoint.x + A.col2.y * localPoint.y);
      worldPoint.x += this.m_xf.position.x;
      worldPoint.y += this.m_xf.position.y;
      return new b2Vec2(this.m_linearVelocity.x - this.m_angularVelocity * (worldPoint.y - this.m_sweep.c.y), this.m_linearVelocity.y + this.m_angularVelocity * (worldPoint.x - this.m_sweep.c.x));
   }
   b2Body.prototype.GetLinearDamping = function () {
      return this.m_linearDamping;
   }
   b2Body.prototype.SetLinearDamping = function (linearDamping) {
      if (linearDamping === undefined) linearDamping = 0;
      this.m_linearDamping = linearDamping;
   }
   b2Body.prototype.GetAngularDamping = function () {
      return this.m_angularDamping;
   }
   b2Body.prototype.SetAngularDamping = function (angularDamping) {
      if (angularDamping === undefined) angularDamping = 0;
      this.m_angularDamping = angularDamping;
   }
   b2Body.prototype.SetType = function (type) {
      if (type === undefined) type = 0;
      if (this.m_type == type) {
         return;
      }
      this.m_type = type;
      this.ResetMassData();
      if (this.m_type == b2Body.b2_staticBody) {
         this.m_linearVelocity.SetZero();
         this.m_angularVelocity = 0.0;
      }
      this.SetAwake(true);
      this.m_force.SetZero();
      this.m_torque = 0.0;
      for (var ce = this.m_contactList; ce; ce = ce.next) {
         ce.contact.FlagForFiltering();
      }
   }
   b2Body.prototype.GetType = function () {
      return this.m_type;
   }
   b2Body.prototype.SetBullet = function (flag) {
      if (flag) {
         this.m_flags |= b2Body.e_bulletFlag;
      }
      else {
         this.m_flags &= ~b2Body.e_bulletFlag;
      }
   }
   b2Body.prototype.IsBullet = function () {
      return (this.m_flags & b2Body.e_bulletFlag) == b2Body.e_bulletFlag;
   }
   b2Body.prototype.SetSleepingAllowed = function (flag) {
      if (flag) {
         this.m_flags |= b2Body.e_allowSleepFlag;
      }
      else {
         this.m_flags &= ~b2Body.e_allowSleepFlag;
         this.SetAwake(true);
      }
   }
   b2Body.prototype.SetAwake = function (flag) {
      if (flag) {
         this.m_flags |= b2Body.e_awakeFlag;
         this.m_sleepTime = 0.0;
      }
      else {
         this.m_flags &= ~b2Body.e_awakeFlag;
         this.m_sleepTime = 0.0;
         this.m_linearVelocity.SetZero();
         this.m_angularVelocity = 0.0;
         this.m_force.SetZero();
         this.m_torque = 0.0;
      }
   }
   b2Body.prototype.IsAwake = function () {
      return (this.m_flags & b2Body.e_awakeFlag) == b2Body.e_awakeFlag;
   }
   b2Body.prototype.SetFixedRotation = function (fixed) {
      if (fixed) {
         this.m_flags |= b2Body.e_fixedRotationFlag;
      }
      else {
         this.m_flags &= ~b2Body.e_fixedRotationFlag;
      }
      this.ResetMassData();
   }
   b2Body.prototype.IsFixedRotation = function () {
      return (this.m_flags & b2Body.e_fixedRotationFlag) == b2Body.e_fixedRotationFlag;
   }
   b2Body.prototype.SetActive = function (flag) {
      if (flag == this.IsActive()) {
         return;
      }
      var broadPhase;
      var f;
      if (flag) {
         this.m_flags |= b2Body.e_activeFlag;
         broadPhase = this.m_world.m_contactManager.m_broadPhase;
         for (f = this.m_fixtureList;
         f; f = f.m_next) {
            f.CreateProxy(broadPhase, this.m_xf);
         }
      }
      else {
         this.m_flags &= ~b2Body.e_activeFlag;
         broadPhase = this.m_world.m_contactManager.m_broadPhase;
         for (f = this.m_fixtureList;
         f; f = f.m_next) {
            f.DestroyProxy(broadPhase);
         }
         var ce = this.m_contactList;
         while (ce) {
            var ce0 = ce;
            ce = ce.next;
            this.m_world.m_contactManager.Destroy(ce0.contact);
         }
         this.m_contactList = null;
      }
   }
   b2Body.prototype.IsActive = function () {
      return (this.m_flags & b2Body.e_activeFlag) == b2Body.e_activeFlag;
   }
   b2Body.prototype.IsSleepingAllowed = function () {
      return (this.m_flags & b2Body.e_allowSleepFlag) == b2Body.e_allowSleepFlag;
   }
   b2Body.prototype.GetFixtureList = function () {
      return this.m_fixtureList;
   }
   b2Body.prototype.GetJointList = function () {
      return this.m_jointList;
   }
   b2Body.prototype.GetControllerList = function () {
      return this.m_controllerList;
   }
   b2Body.prototype.GetContactList = function () {
      return this.m_contactList;
   }
   b2Body.prototype.GetNext = function () {
      return this.m_next;
   }
   b2Body.prototype.GetUserData = function () {
      return this.m_userData;
   }
   b2Body.prototype.SetUserData = function (data) {
      this.m_userData = data;
   }
   b2Body.prototype.GetWorld = function () {
      return this.m_world;
   }
   b2Body.prototype.b2Body = function (bd, world) {
      this.m_flags = 0;
      if (bd.bullet) {
         this.m_flags |= b2Body.e_bulletFlag;
      }
      if (bd.fixedRotation) {
         this.m_flags |= b2Body.e_fixedRotationFlag;
      }
      if (bd.allowSleep) {
         this.m_flags |= b2Body.e_allowSleepFlag;
      }
      if (bd.awake) {
         this.m_flags |= b2Body.e_awakeFlag;
      }
      if (bd.active) {
         this.m_flags |= b2Body.e_activeFlag;
      }
      this.m_world = world;
      this.m_xf.position.SetV(bd.position);
      this.m_xf.R.Set(bd.angle);
      this.m_sweep.localCenter.SetZero();
      this.m_sweep.t0 = 1.0;
      this.m_sweep.a0 = this.m_sweep.a = bd.angle;
      var tMat = this.m_xf.R;
      var tVec = this.m_sweep.localCenter;
      this.m_sweep.c.x = (tMat.col1.x * tVec.x + tMat.col2.x * tVec.y);
      this.m_sweep.c.y = (tMat.col1.y * tVec.x + tMat.col2.y * tVec.y);
      this.m_sweep.c.x += this.m_xf.position.x;
      this.m_sweep.c.y += this.m_xf.position.y;
      this.m_sweep.c0.SetV(this.m_sweep.c);
      this.m_jointList = null;
      this.m_controllerList = null;
      this.m_contactList = null;
      this.m_controllerCount = 0;
      this.m_prev = null;
      this.m_next = null;
      this.m_linearVelocity.SetV(bd.linearVelocity);
      this.m_angularVelocity = bd.angularVelocity;
      this.m_linearDamping = bd.linearDamping;
      this.m_angularDamping = bd.angularDamping;
      this.m_force.Set(0.0, 0.0);
      this.m_torque = 0.0;
      this.m_sleepTime = 0.0;
      this.m_type = bd.type;
      if (this.m_type == b2Body.b2_dynamicBody) {
         this.m_mass = 1.0;
         this.m_invMass = 1.0;
      }
      else {
         this.m_mass = 0.0;
         this.m_invMass = 0.0;
      }
      this.m_I = 0.0;
      this.m_invI = 0.0;
      this.m_inertiaScale = bd.inertiaScale;
      this.m_userData = bd.userData;
      this.m_fixtureList = null;
      this.m_fixtureCount = 0;
   }
   b2Body.prototype.SynchronizeFixtures = function () {
      var xf1 = b2Body.s_xf1;
      xf1.R.Set(this.m_sweep.a0);
      var tMat = xf1.R;
      var tVec = this.m_sweep.localCenter;
      xf1.position.x = this.m_sweep.c0.x - (tMat.col1.x * tVec.x + tMat.col2.x * tVec.y);
      xf1.position.y = this.m_sweep.c0.y - (tMat.col1.y * tVec.x + tMat.col2.y * tVec.y);
      var f;
      var broadPhase = this.m_world.m_contactManager.m_broadPhase;
      for (f = this.m_fixtureList;
      f; f = f.m_next) {
         f.Synchronize(broadPhase, xf1, this.m_xf);
      }
   }
   b2Body.prototype.SynchronizeTransform = function () {
      this.m_xf.R.Set(this.m_sweep.a);
      var tMat = this.m_xf.R;
      var tVec = this.m_sweep.localCenter;
      this.m_xf.position.x = this.m_sweep.c.x - (tMat.col1.x * tVec.x + tMat.col2.x * tVec.y);
      this.m_xf.position.y = this.m_sweep.c.y - (tMat.col1.y * tVec.x + tMat.col2.y * tVec.y);
   }
   b2Body.prototype.ShouldCollide = function (other) {
      if (this.m_type != b2Body.b2_dynamicBody && other.m_type != b2Body.b2_dynamicBody) {
         return false;
      }
      for (var jn = this.m_jointList; jn; jn = jn.next) {
         if (jn.other == other) if (jn.joint.m_collideConnected == false) {
            return false;
         }
      }
      return true;
   }
   b2Body.prototype.Advance = function (t) {
      if (t === undefined) t = 0;
      this.m_sweep.Advance(t);
      this.m_sweep.c.SetV(this.m_sweep.c0);
      this.m_sweep.a = this.m_sweep.a0;
      this.SynchronizeTransform();
   }
   Box2D.postDefs.push(function () {
      Box2D.Dynamics.b2Body.s_xf1 = new b2Transform();
      Box2D.Dynamics.b2Body.e_islandFlag = 0x0001;
      Box2D.Dynamics.b2Body.e_awakeFlag = 0x0002;
      Box2D.Dynamics.b2Body.e_allowSleepFlag = 0x0004;
      Box2D.Dynamics.b2Body.e_bulletFlag = 0x0008;
      Box2D.Dynamics.b2Body.e_fixedRotationFlag = 0x0010;
      Box2D.Dynamics.b2Body.e_activeFlag = 0x0020;
      Box2D.Dynamics.b2Body.b2_staticBody = 0;
      Box2D.Dynamics.b2Body.b2_kinematicBody = 1;
      Box2D.Dynamics.b2Body.b2_dynamicBody = 2;
   });
   b2BodyDef.b2BodyDef = function () {
      this.position = new b2Vec2();
      this.linearVelocity = new b2Vec2();
   };
   b2BodyDef.prototype.b2BodyDef = function () {
      this.userData = null;
      this.position.Set(0.0, 0.0);
      this.angle = 0.0;
      this.linearVelocity.Set(0, 0);
      this.angularVelocity = 0.0;
      this.linearDamping = 0.0;
      this.angularDamping = 0.0;
      this.allowSleep = true;
      this.awake = true;
      this.fixedRotation = false;
      this.bullet = false;
      this.type = b2Body.b2_staticBody;
      this.active = true;
      this.inertiaScale = 1.0;
   }
   b2ContactFilter.b2ContactFilter = function () {};
   b2ContactFilter.prototype.ShouldCollide = function (fixtureA, fixtureB) {
      var filter1 = fixtureA.GetFilterData();
      var filter2 = fixtureB.GetFilterData();
      if (filter1.groupIndex == filter2.groupIndex && filter1.groupIndex != 0) {
         return filter1.groupIndex > 0;
      }
      var collide = (filter1.maskBits & filter2.categoryBits) != 0 && (filter1.categoryBits & filter2.maskBits) != 0;
      return collide;
   }
   b2ContactFilter.prototype.RayCollide = function (userData, fixture) {
      if (!userData) return true;
      return this.ShouldCollide((userData instanceof b2Fixture ? userData : null), fixture);
   }
   Box2D.postDefs.push(function () {
      Box2D.Dynamics.b2ContactFilter.b2_defaultFilter = new b2ContactFilter();
   });
   b2ContactImpulse.b2ContactImpulse = function () {
      this.normalImpulses = new Vector_a2j_Number(b2Settings.b2_maxManifoldPoints);
      this.tangentImpulses = new Vector_a2j_Number(b2Settings.b2_maxManifoldPoints);
   };
   b2ContactListener.b2ContactListener = function () {};
   b2ContactListener.prototype.BeginContact = function (contact) {}
   b2ContactListener.prototype.EndContact = function (contact) {}
   b2ContactListener.prototype.PreSolve = function (contact, oldManifold) {}
   b2ContactListener.prototype.PostSolve = function (contact, impulse) {}
   Box2D.postDefs.push(function () {
      Box2D.Dynamics.b2ContactListener.b2_defaultListener = new b2ContactListener();
   });
   b2ContactManager.b2ContactManager = function () {};
   b2ContactManager.prototype.b2ContactManager = function () {
      this.m_world = null;
      this.m_contactCount = 0;
      this.m_contactFilter = b2ContactFilter.b2_defaultFilter;
      this.m_contactListener = b2ContactListener.b2_defaultListener;
      this.m_contactFactory = new b2ContactFactory(this.m_allocator);
      this.m_broadPhase = new b2DynamicTreeBroadPhase();
   }
   b2ContactManager.prototype.AddPair = function (proxyUserDataA, proxyUserDataB) {
      var fixtureA = (proxyUserDataA instanceof b2Fixture ? proxyUserDataA : null);
      var fixtureB = (proxyUserDataB instanceof b2Fixture ? proxyUserDataB : null);
      var bodyA = fixtureA.GetBody();
      var bodyB = fixtureB.GetBody();
      if (bodyA == bodyB) return;
      var edge = bodyB.GetContactList();
      while (edge) {
         if (edge.other == bodyA) {
            var fA = edge.contact.GetFixtureA();
            var fB = edge.contact.GetFixtureB();
            if (fA == fixtureA && fB == fixtureB) return;
            if (fA == fixtureB && fB == fixtureA) return;
         }
         edge = edge.next;
      }
      if (bodyB.ShouldCollide(bodyA) == false) {
         return;
      }
      if (this.m_contactFilter.ShouldCollide(fixtureA, fixtureB) == false) {
         return;
      }
      var c = this.m_contactFactory.Create(fixtureA, fixtureB);
      fixtureA = c.GetFixtureA();
      fixtureB = c.GetFixtureB();
      bodyA = fixtureA.m_body;
      bodyB = fixtureB.m_body;
      c.m_prev = null;
      c.m_next = this.m_world.m_contactList;
      if (this.m_world.m_contactList != null) {
         this.m_world.m_contactList.m_prev = c;
      }
      this.m_world.m_contactList = c;
      c.m_nodeA.contact = c;
      c.m_nodeA.other = bodyB;
      c.m_nodeA.prev = null;
      c.m_nodeA.next = bodyA.m_contactList;
      if (bodyA.m_contactList != null) {
         bodyA.m_contactList.prev = c.m_nodeA;
      }
      bodyA.m_contactList = c.m_nodeA;
      c.m_nodeB.contact = c;
      c.m_nodeB.other = bodyA;
      c.m_nodeB.prev = null;
      c.m_nodeB.next = bodyB.m_contactList;
      if (bodyB.m_contactList != null) {
         bodyB.m_contactList.prev = c.m_nodeB;
      }
      bodyB.m_contactList = c.m_nodeB;
      ++this.m_world.m_contactCount;
      return;
   }
   b2ContactManager.prototype.FindNewContacts = function () {
      this.m_broadPhase.UpdatePairs(Box2D.generateCallback(this, this.AddPair));
   }
   b2ContactManager.prototype.Destroy = function (c) {
      var fixtureA = c.GetFixtureA();
      var fixtureB = c.GetFixtureB();
      var bodyA = fixtureA.GetBody();
      var bodyB = fixtureB.GetBody();
      if (c.IsTouching()) {
         this.m_contactListener.EndContact(c);
      }
      if (c.m_prev) {
         c.m_prev.m_next = c.m_next;
      }
      if (c.m_next) {
         c.m_next.m_prev = c.m_prev;
      }
      if (c == this.m_world.m_contactList) {
         this.m_world.m_contactList = c.m_next;
      }
      if (c.m_nodeA.prev) {
         c.m_nodeA.prev.next = c.m_nodeA.next;
      }
      if (c.m_nodeA.next) {
         c.m_nodeA.next.prev = c.m_nodeA.prev;
      }
      if (c.m_nodeA == bodyA.m_contactList) {
         bodyA.m_contactList = c.m_nodeA.next;
      }
      if (c.m_nodeB.prev) {
         c.m_nodeB.prev.next = c.m_nodeB.next;
      }
      if (c.m_nodeB.next) {
         c.m_nodeB.next.prev = c.m_nodeB.prev;
      }
      if (c.m_nodeB == bodyB.m_contactList) {
         bodyB.m_contactList = c.m_nodeB.next;
      }
      this.m_contactFactory.Destroy(c);
      --this.m_contactCount;
   }
   b2ContactManager.prototype.Collide = function () {
      var c = this.m_world.m_contactList;
      while (c) {
         var fixtureA = c.GetFixtureA();
         var fixtureB = c.GetFixtureB();
         var bodyA = fixtureA.GetBody();
         var bodyB = fixtureB.GetBody();
         if (bodyA.IsAwake() == false && bodyB.IsAwake() == false) {
            c = c.GetNext();
            continue;
         }
         if (c.m_flags & b2Contact.e_filterFlag) {
            if (bodyB.ShouldCollide(bodyA) == false) {
               var cNuke = c;
               c = cNuke.GetNext();
               this.Destroy(cNuke);
               continue;
            }
            if (this.m_contactFilter.ShouldCollide(fixtureA, fixtureB) == false) {
               cNuke = c;
               c = cNuke.GetNext();
               this.Destroy(cNuke);
               continue;
            }
            c.m_flags &= ~b2Contact.e_filterFlag;
         }
         var proxyA = fixtureA.m_proxy;
         var proxyB = fixtureB.m_proxy;
         var overlap = this.m_broadPhase.TestOverlap(proxyA, proxyB);
         if (overlap == false) {
            cNuke = c;
            c = cNuke.GetNext();
            this.Destroy(cNuke);
            continue;
         }
         c.Update(this.m_contactListener);
         c = c.GetNext();
      }
   }
   Box2D.postDefs.push(function () {
      Box2D.Dynamics.b2ContactManager.s_evalCP = new b2ContactPoint();
   });
   b2DebugDraw.b2DebugDraw = function () {};
   b2DebugDraw.prototype.b2DebugDraw = function () {}
   b2DebugDraw.prototype.SetFlags = function (flags) {
      if (flags === undefined) flags = 0;
   }
   b2DebugDraw.prototype.GetFlags = function () {}
   b2DebugDraw.prototype.AppendFlags = function (flags) {
      if (flags === undefined) flags = 0;
   }
   b2DebugDraw.prototype.ClearFlags = function (flags) {
      if (flags === undefined) flags = 0;
   }
   b2DebugDraw.prototype.SetSprite = function (sprite) {}
   b2DebugDraw.prototype.GetSprite = function () {}
   b2DebugDraw.prototype.SetDrawScale = function (drawScale) {
      if (drawScale === undefined) drawScale = 0;
   }
   b2DebugDraw.prototype.GetDrawScale = function () {}
   b2DebugDraw.prototype.SetLineThickness = function (lineThickness) {
      if (lineThickness === undefined) lineThickness = 0;
   }
   b2DebugDraw.prototype.GetLineThickness = function () {}
   b2DebugDraw.prototype.SetAlpha = function (alpha) {
      if (alpha === undefined) alpha = 0;
   }
   b2DebugDraw.prototype.GetAlpha = function () {}
   b2DebugDraw.prototype.SetFillAlpha = function (alpha) {
      if (alpha === undefined) alpha = 0;
   }
   b2DebugDraw.prototype.GetFillAlpha = function () {}
   b2DebugDraw.prototype.SetXFormScale = function (xformScale) {
      if (xformScale === undefined) xformScale = 0;
   }
   b2DebugDraw.prototype.GetXFormScale = function () {}
   b2DebugDraw.prototype.DrawPolygon = function (vertices, vertexCount, color) {
      if (vertexCount === undefined) vertexCount = 0;
   }
   b2DebugDraw.prototype.DrawSolidPolygon = function (vertices, vertexCount, color) {
      if (vertexCount === undefined) vertexCount = 0;
   }
   b2DebugDraw.prototype.DrawCircle = function (center, radius, color) {
      if (radius === undefined) radius = 0;
   }
   b2DebugDraw.prototype.DrawSolidCircle = function (center, radius, axis, color) {
      if (radius === undefined) radius = 0;
   }
   b2DebugDraw.prototype.DrawSegment = function (p1, p2, color) {}
   b2DebugDraw.prototype.DrawTransform = function (xf) {}
   Box2D.postDefs.push(function () {
      Box2D.Dynamics.b2DebugDraw.e_shapeBit = 0x0001;
      Box2D.Dynamics.b2DebugDraw.e_jointBit = 0x0002;
      Box2D.Dynamics.b2DebugDraw.e_aabbBit = 0x0004;
      Box2D.Dynamics.b2DebugDraw.e_pairBit = 0x0008;
      Box2D.Dynamics.b2DebugDraw.e_centerOfMassBit = 0x0010;
      Box2D.Dynamics.b2DebugDraw.e_controllerBit = 0x0020;
   });
   b2DestructionListener.b2DestructionListener = function () {};
   b2DestructionListener.prototype.SayGoodbyeJoint = function (joint) {}
   b2DestructionListener.prototype.SayGoodbyeFixture = function (fixture) {}
   b2FilterData.b2FilterData = function () {
      this.categoryBits = 0x0001;
      this.maskBits = 0xFFFF;
      this.groupIndex = 0;
   };
   b2FilterData.prototype.Copy = function () {
      var copy = new b2FilterData();
      copy.categoryBits = this.categoryBits;
      copy.maskBits = this.maskBits;
      copy.groupIndex = this.groupIndex;
      return copy;
   }
   b2Fixture.b2Fixture = function () {
      this.m_filter = new b2FilterData();
   };
   b2Fixture.prototype.GetType = function () {
      return this.m_shape.GetType();
   }
   b2Fixture.prototype.GetShape = function () {
      return this.m_shape;
   }
   b2Fixture.prototype.SetSensor = function (sensor) {
      if (this.m_isSensor == sensor) return;
      this.m_isSensor = sensor;
      if (this.m_body == null) return;
      var edge = this.m_body.GetContactList();
      while (edge) {
         var contact = edge.contact;
         var fixtureA = contact.GetFixtureA();
         var fixtureB = contact.GetFixtureB();
         if (fixtureA == this || fixtureB == this) contact.SetSensor(fixtureA.IsSensor() || fixtureB.IsSensor());
         edge = edge.next;
      }
   }
   b2Fixture.prototype.IsSensor = function () {
      return this.m_isSensor;
   }
   b2Fixture.prototype.SetFilterData = function (filter) {
      this.m_filter = filter.Copy();
      if (this.m_body) return;
      var edge = this.m_body.GetContactList();
      while (edge) {
         var contact = edge.contact;
         var fixtureA = contact.GetFixtureA();
         var fixtureB = contact.GetFixtureB();
         if (fixtureA == this || fixtureB == this) contact.FlagForFiltering();
         edge = edge.next;
      }
   }
   b2Fixture.prototype.GetFilterData = function () {
      return this.m_filter.Copy();
   }
   b2Fixture.prototype.GetBody = function () {
      return this.m_body;
   }
   b2Fixture.prototype.GetNext = function () {
      return this.m_next;
   }
   b2Fixture.prototype.GetUserData = function () {
      return this.m_userData;
   }
   b2Fixture.prototype.SetUserData = function (data) {
      this.m_userData = data;
   }
   b2Fixture.prototype.TestPoint = function (p) {
      return this.m_shape.TestPoint(this.m_body.GetTransform(), p);
   }
   b2Fixture.prototype.RayCast = function (output, input) {
      return this.m_shape.RayCast(output, input, this.m_body.GetTransform());
   }
   b2Fixture.prototype.GetMassData = function (massData) {
      if (massData === undefined) massData = null;
      if (massData == null) {
         massData = new b2MassData();
      }
      this.m_shape.ComputeMass(massData, this.m_density);
      return massData;
   }
   b2Fixture.prototype.SetDensity = function (density) {
      if (density === undefined) density = 0;
      this.m_density = density;
   }
   b2Fixture.prototype.GetDensity = function () {
      return this.m_density;
   }
   b2Fixture.prototype.GetFriction = function () {
      return this.m_friction;
   }
   b2Fixture.prototype.SetFriction = function (friction) {
      if (friction === undefined) friction = 0;
      this.m_friction = friction;
   }
   b2Fixture.prototype.GetRestitution = function () {
      return this.m_restitution;
   }
   b2Fixture.prototype.SetRestitution = function (restitution) {
      if (restitution === undefined) restitution = 0;
      this.m_restitution = restitution;
   }
   b2Fixture.prototype.GetAABB = function () {
      return this.m_aabb;
   }
   b2Fixture.prototype.b2Fixture = function () {
      this.m_aabb = new b2AABB();
      this.m_userData = null;
      this.m_body = null;
      this.m_next = null;
      this.m_shape = null;
      this.m_density = 0.0;
      this.m_friction = 0.0;
      this.m_restitution = 0.0;
   }
   b2Fixture.prototype.Create = function (body, xf, def) {
      this.m_userData = def.userData;
      this.m_friction = def.friction;
      this.m_restitution = def.restitution;
      this.m_body = body;
      this.m_next = null;
      this.m_filter = def.filter.Copy();
      this.m_isSensor = def.isSensor;
      this.m_shape = def.shape.Copy();
      this.m_density = def.density;
   }
   b2Fixture.prototype.Destroy = function () {
      this.m_shape = null;
   }
   b2Fixture.prototype.CreateProxy = function (broadPhase, xf) {
      this.m_shape.ComputeAABB(this.m_aabb, xf);
      this.m_proxy = broadPhase.CreateProxy(this.m_aabb, this);
   }
   b2Fixture.prototype.DestroyProxy = function (broadPhase) {
      if (this.m_proxy == null) {
         return;
      }
      broadPhase.DestroyProxy(this.m_proxy);
      this.m_proxy = null;
   }
   b2Fixture.prototype.Synchronize = function (broadPhase, transform1, transform2) {
      if (!this.m_proxy) return;
      var aabb1 = new b2AABB();
      var aabb2 = new b2AABB();
      this.m_shape.ComputeAABB(aabb1, transform1);
      this.m_shape.ComputeAABB(aabb2, transform2);
      this.m_aabb.Combine(aabb1, aabb2);
      var displacement = b2Math.SubtractVV(transform2.position, transform1.position);
      broadPhase.MoveProxy(this.m_proxy, this.m_aabb, displacement);
   }
   b2FixtureDef.b2FixtureDef = function () {
      this.filter = new b2FilterData();
   };
   b2FixtureDef.prototype.b2FixtureDef = function () {
      this.shape = null;
      this.userData = null;
      this.friction = 0.2;
      this.restitution = 0.0;
      this.density = 0.0;
      this.filter.categoryBits = 0x0001;
      this.filter.maskBits = 0xFFFF;
      this.filter.groupIndex = 0;
      this.isSensor = false;
   }
   b2Island.b2Island = function () {};
   b2Island.prototype.b2Island = function () {
      this.m_bodies = new Vector();
      this.m_contacts = new Vector();
      this.m_joints = new Vector();
   }
   b2Island.prototype.Initialize = function (bodyCapacity, contactCapacity, jointCapacity, allocator, listener, contactSolver) {
      if (bodyCapacity === undefined) bodyCapacity = 0;
      if (contactCapacity === undefined) contactCapacity = 0;
      if (jointCapacity === undefined) jointCapacity = 0;
      var i = 0;
      this.m_bodyCapacity = bodyCapacity;
      this.m_contactCapacity = contactCapacity;
      this.m_jointCapacity = jointCapacity;
      this.m_bodyCount = 0;
      this.m_contactCount = 0;
      this.m_jointCount = 0;
      this.m_allocator = allocator;
      this.m_listener = listener;
      this.m_contactSolver = contactSolver;
      for (i = this.m_bodies.length;
      i < bodyCapacity; i++)
      this.m_bodies[i] = null;
      for (i = this.m_contacts.length;
      i < contactCapacity; i++)
      this.m_contacts[i] = null;
      for (i = this.m_joints.length;
      i < jointCapacity; i++)
      this.m_joints[i] = null;
   }
   b2Island.prototype.Clear = function () {
      this.m_bodyCount = 0;
      this.m_contactCount = 0;
      this.m_jointCount = 0;
   }
   b2Island.prototype.Solve = function (step, gravity, allowSleep) {
      var i = 0;
      var j = 0;
      var b;
      var joint;
      for (i = 0;
      i < this.m_bodyCount; ++i) {
         b = this.m_bodies[i];
         if (b.GetType() != b2Body.b2_dynamicBody) continue;
         b.m_linearVelocity.x += step.dt * (gravity.x + b.m_invMass * b.m_force.x);
         b.m_linearVelocity.y += step.dt * (gravity.y + b.m_invMass * b.m_force.y);
         b.m_angularVelocity += step.dt * b.m_invI * b.m_torque;
         b.m_linearVelocity.Multiply(b2Math.Clamp(1.0 - step.dt * b.m_linearDamping, 0.0, 1.0));
         b.m_angularVelocity *= b2Math.Clamp(1.0 - step.dt * b.m_angularDamping, 0.0, 1.0);
      }
      this.m_contactSolver.Initialize(step, this.m_contacts, this.m_contactCount, this.m_allocator);
      var contactSolver = this.m_contactSolver;
      contactSolver.InitVelocityConstraints(step);
      for (i = 0;
      i < this.m_jointCount; ++i) {
         joint = this.m_joints[i];
         joint.InitVelocityConstraints(step);
      }
      for (i = 0;
      i < step.velocityIterations; ++i) {
         for (j = 0;
         j < this.m_jointCount; ++j) {
            joint = this.m_joints[j];
            joint.SolveVelocityConstraints(step);
         }
         contactSolver.SolveVelocityConstraints();
      }
      for (i = 0;
      i < this.m_jointCount; ++i) {
         joint = this.m_joints[i];
         joint.FinalizeVelocityConstraints();
      }
      contactSolver.FinalizeVelocityConstraints();
      for (i = 0;
      i < this.m_bodyCount; ++i) {
         b = this.m_bodies[i];
         if (b.GetType() == b2Body.b2_staticBody) continue;
         var translationX = step.dt * b.m_linearVelocity.x;
         var translationY = step.dt * b.m_linearVelocity.y;
         if ((translationX * translationX + translationY * translationY) > b2Settings.b2_maxTranslationSquared) {
            b.m_linearVelocity.Normalize();
            b.m_linearVelocity.x *= b2Settings.b2_maxTranslation * step.inv_dt;
            b.m_linearVelocity.y *= b2Settings.b2_maxTranslation * step.inv_dt;
         }
         var rotation = step.dt * b.m_angularVelocity;
         if (rotation * rotation > b2Settings.b2_maxRotationSquared) {
            if (b.m_angularVelocity < 0.0) {
               b.m_angularVelocity = (-b2Settings.b2_maxRotation * step.inv_dt);
            }
            else {
               b.m_angularVelocity = b2Settings.b2_maxRotation * step.inv_dt;
            }
         }
         b.m_sweep.c0.SetV(b.m_sweep.c);
         b.m_sweep.a0 = b.m_sweep.a;
         b.m_sweep.c.x += step.dt * b.m_linearVelocity.x;
         b.m_sweep.c.y += step.dt * b.m_linearVelocity.y;
         b.m_sweep.a += step.dt * b.m_angularVelocity;
         b.SynchronizeTransform();
      }
      for (i = 0;
      i < step.positionIterations; ++i) {
         var contactsOkay = contactSolver.SolvePositionConstraints(b2Settings.b2_contactBaumgarte);
         var jointsOkay = true;
         for (j = 0;
         j < this.m_jointCount; ++j) {
            joint = this.m_joints[j];
            var jointOkay = joint.SolvePositionConstraints(b2Settings.b2_contactBaumgarte);
            jointsOkay = jointsOkay && jointOkay;
         }
         if (contactsOkay && jointsOkay) {
            break;
         }
      }
      this.Report(contactSolver.m_constraints);
      if (allowSleep) {
         var minSleepTime = Number.MAX_VALUE;
         var linTolSqr = b2Settings.b2_linearSleepTolerance * b2Settings.b2_linearSleepTolerance;
         var angTolSqr = b2Settings.b2_angularSleepTolerance * b2Settings.b2_angularSleepTolerance;
         for (i = 0;
         i < this.m_bodyCount; ++i) {
            b = this.m_bodies[i];
            if (b.GetType() == b2Body.b2_staticBody) {
               continue;
            }
            if ((b.m_flags & b2Body.e_allowSleepFlag) == 0) {
               b.m_sleepTime = 0.0;
               minSleepTime = 0.0;
            }
            if ((b.m_flags & b2Body.e_allowSleepFlag) == 0 || b.m_angularVelocity * b.m_angularVelocity > angTolSqr || b2Math.Dot(b.m_linearVelocity, b.m_linearVelocity) > linTolSqr) {
               b.m_sleepTime = 0.0;
               minSleepTime = 0.0;
            }
            else {
               b.m_sleepTime += step.dt;
               minSleepTime = b2Math.Min(minSleepTime, b.m_sleepTime);
            }
         }
         if (minSleepTime >= b2Settings.b2_timeToSleep) {
            for (i = 0;
            i < this.m_bodyCount; ++i) {
               b = this.m_bodies[i];
               b.SetAwake(false);
            }
         }
      }
   }
   b2Island.prototype.SolveTOI = function (subStep) {
      var i = 0;
      var j = 0;
      this.m_contactSolver.Initialize(subStep, this.m_contacts, this.m_contactCount, this.m_allocator);
      var contactSolver = this.m_contactSolver;
      for (i = 0;
      i < this.m_jointCount; ++i) {
         this.m_joints[i].InitVelocityConstraints(subStep);
      }
      for (i = 0;
      i < subStep.velocityIterations; ++i) {
         contactSolver.SolveVelocityConstraints();
         for (j = 0;
         j < this.m_jointCount; ++j) {
            this.m_joints[j].SolveVelocityConstraints(subStep);
         }
      }
      for (i = 0;
      i < this.m_bodyCount; ++i) {
         var b = this.m_bodies[i];
         if (b.GetType() == b2Body.b2_staticBody) continue;
         var translationX = subStep.dt * b.m_linearVelocity.x;
         var translationY = subStep.dt * b.m_linearVelocity.y;
         if ((translationX * translationX + translationY * translationY) > b2Settings.b2_maxTranslationSquared) {
            b.m_linearVelocity.Normalize();
            b.m_linearVelocity.x *= b2Settings.b2_maxTranslation * subStep.inv_dt;
            b.m_linearVelocity.y *= b2Settings.b2_maxTranslation * subStep.inv_dt;
         }
         var rotation = subStep.dt * b.m_angularVelocity;
         if (rotation * rotation > b2Settings.b2_maxRotationSquared) {
            if (b.m_angularVelocity < 0.0) {
               b.m_angularVelocity = (-b2Settings.b2_maxRotation * subStep.inv_dt);
            }
            else {
               b.m_angularVelocity = b2Settings.b2_maxRotation * subStep.inv_dt;
            }
         }
         b.m_sweep.c0.SetV(b.m_sweep.c);
         b.m_sweep.a0 = b.m_sweep.a;
         b.m_sweep.c.x += subStep.dt * b.m_linearVelocity.x;
         b.m_sweep.c.y += subStep.dt * b.m_linearVelocity.y;
         b.m_sweep.a += subStep.dt * b.m_angularVelocity;
         b.SynchronizeTransform();
      }
      var k_toiBaumgarte = 0.75;
      for (i = 0;
      i < subStep.positionIterations; ++i) {
         var contactsOkay = contactSolver.SolvePositionConstraints(k_toiBaumgarte);
         var jointsOkay = true;
         for (j = 0;
         j < this.m_jointCount; ++j) {
            var jointOkay = this.m_joints[j].SolvePositionConstraints(b2Settings.b2_contactBaumgarte);
            jointsOkay = jointsOkay && jointOkay;
         }
         if (contactsOkay && jointsOkay) {
            break;
         }
      }
      this.Report(contactSolver.m_constraints);
   }
   b2Island.prototype.Report = function (constraints) {
      if (this.m_listener == null) {
         return;
      }
      for (var i = 0; i < this.m_contactCount; ++i) {
         var c = this.m_contacts[i];
         var cc = constraints[i];
         for (var j = 0; j < cc.pointCount; ++j) {
            b2Island.s_impulse.normalImpulses[j] = cc.points[j].normalImpulse;
            b2Island.s_impulse.tangentImpulses[j] = cc.points[j].tangentImpulse;
         }
         this.m_listener.PostSolve(c, b2Island.s_impulse);
      }
   }
   b2Island.prototype.AddBody = function (body) {
      body.m_islandIndex = this.m_bodyCount;
      this.m_bodies[this.m_bodyCount++] = body;
   }
   b2Island.prototype.AddContact = function (contact) {
      this.m_contacts[this.m_contactCount++] = contact;
   }
   b2Island.prototype.AddJoint = function (joint) {
      this.m_joints[this.m_jointCount++] = joint;
   }
   Box2D.postDefs.push(function () {
      Box2D.Dynamics.b2Island.s_impulse = new b2ContactImpulse();
   });
   b2TimeStep.b2TimeStep = function () {};
   b2TimeStep.prototype.Set = function (step) {
      this.dt = step.dt;
      this.inv_dt = step.inv_dt;
      this.positionIterations = step.positionIterations;
      this.velocityIterations = step.velocityIterations;
      this.warmStarting = step.warmStarting;
   }
   b2World.b2World = function () {
      this.s_stack = new Vector();
      this.m_contactManager = new b2ContactManager();
      this.m_contactSolver = new b2ContactSolver();
      this.m_island = new b2Island();
   };
   b2World.prototype.b2World = function (gravity, doSleep) {
      this.m_destructionListener = null;
      this.m_debugDraw = null;
      this.m_bodyList = null;
      this.m_contactList = null;
      this.m_jointList = null;
      this.m_controllerList = null;
      this.m_bodyCount = 0;
      this.m_contactCount = 0;
      this.m_jointCount = 0;
      this.m_controllerCount = 0;
      b2World.m_warmStarting = true;
      b2World.m_continuousPhysics = true;
      this.m_allowSleep = doSleep;
      this.m_gravity = gravity;
      this.m_inv_dt0 = 0.0;
      this.m_contactManager.m_world = this;
      var bd = new b2BodyDef();
      this.m_groundBody = this.CreateBody(bd);
   }
   b2World.prototype.SetDestructionListener = function (listener) {
      this.m_destructionListener = listener;
   }
   b2World.prototype.SetContactFilter = function (filter) {
      this.m_contactManager.m_contactFilter = filter;
   }
   b2World.prototype.SetContactListener = function (listener) {
      this.m_contactManager.m_contactListener = listener;
   }
   b2World.prototype.SetDebugDraw = function (debugDraw) {
      this.m_debugDraw = debugDraw;
   }
   b2World.prototype.SetBroadPhase = function (broadPhase) {
      var oldBroadPhase = this.m_contactManager.m_broadPhase;
      this.m_contactManager.m_broadPhase = broadPhase;
      for (var b = this.m_bodyList; b; b = b.m_next) {
         for (var f = b.m_fixtureList; f; f = f.m_next) {
            f.m_proxy = broadPhase.CreateProxy(oldBroadPhase.GetFatAABB(f.m_proxy), f);
         }
      }
   }
   b2World.prototype.Validate = function () {
      this.m_contactManager.m_broadPhase.Validate();
   }
   b2World.prototype.GetProxyCount = function () {
      return this.m_contactManager.m_broadPhase.GetProxyCount();
   }
   b2World.prototype.CreateBody = function (def) {
      if (this.IsLocked() == true) {
         return null;
      }
      var b = new b2Body(def, this);
      b.m_prev = null;
      b.m_next = this.m_bodyList;
      if (this.m_bodyList) {
         this.m_bodyList.m_prev = b;
      }
      this.m_bodyList = b;
      ++this.m_bodyCount;
      return b;
   }
   b2World.prototype.DestroyBody = function (b) {
      if (this.IsLocked() == true) {
         return;
      }
      var jn = b.m_jointList;
      while (jn) {
         var jn0 = jn;
         jn = jn.next;
         if (this.m_destructionListener) {
            this.m_destructionListener.SayGoodbyeJoint(jn0.joint);
         }
         this.DestroyJoint(jn0.joint);
      }
      var coe = b.m_controllerList;
      while (coe) {
         var coe0 = coe;
         coe = coe.nextController;
         coe0.controller.RemoveBody(b);
      }
      var ce = b.m_contactList;
      while (ce) {
         var ce0 = ce;
         ce = ce.next;
         this.m_contactManager.Destroy(ce0.contact);
      }
      b.m_contactList = null;
      var f = b.m_fixtureList;
      while (f) {
         var f0 = f;
         f = f.m_next;
         if (this.m_destructionListener) {
            this.m_destructionListener.SayGoodbyeFixture(f0);
         }
         f0.DestroyProxy(this.m_contactManager.m_broadPhase);
         f0.Destroy();
      }
      b.m_fixtureList = null;
      b.m_fixtureCount = 0;
      if (b.m_prev) {
         b.m_prev.m_next = b.m_next;
      }
      if (b.m_next) {
         b.m_next.m_prev = b.m_prev;
      }
      if (b == this.m_bodyList) {
         this.m_bodyList = b.m_next;
      }--this.m_bodyCount;
   }
   b2World.prototype.CreateJoint = function (def) {
      var j = b2Joint.Create(def, null);
      j.m_prev = null;
      j.m_next = this.m_jointList;
      if (this.m_jointList) {
         this.m_jointList.m_prev = j;
      }
      this.m_jointList = j;
      ++this.m_jointCount;
      j.m_edgeA.joint = j;
      j.m_edgeA.other = j.m_bodyB;
      j.m_edgeA.prev = null;
      j.m_edgeA.next = j.m_bodyA.m_jointList;
      if (j.m_bodyA.m_jointList) j.m_bodyA.m_jointList.prev = j.m_edgeA;
      j.m_bodyA.m_jointList = j.m_edgeA;
      j.m_edgeB.joint = j;
      j.m_edgeB.other = j.m_bodyA;
      j.m_edgeB.prev = null;
      j.m_edgeB.next = j.m_bodyB.m_jointList;
      if (j.m_bodyB.m_jointList) j.m_bodyB.m_jointList.prev = j.m_edgeB;
      j.m_bodyB.m_jointList = j.m_edgeB;
      var bodyA = def.bodyA;
      var bodyB = def.bodyB;
      if (def.collideConnected == false) {
         var edge = bodyB.GetContactList();
         while (edge) {
            if (edge.other == bodyA) {
               edge.contact.FlagForFiltering();
            }
            edge = edge.next;
         }
      }
      return j;
   }
   b2World.prototype.DestroyJoint = function (j) {
      var collideConnected = j.m_collideConnected;
      if (j.m_prev) {
         j.m_prev.m_next = j.m_next;
      }
      if (j.m_next) {
         j.m_next.m_prev = j.m_prev;
      }
      if (j == this.m_jointList) {
         this.m_jointList = j.m_next;
      }
      var bodyA = j.m_bodyA;
      var bodyB = j.m_bodyB;
      bodyA.SetAwake(true);
      bodyB.SetAwake(true);
      if (j.m_edgeA.prev) {
         j.m_edgeA.prev.next = j.m_edgeA.next;
      }
      if (j.m_edgeA.next) {
         j.m_edgeA.next.prev = j.m_edgeA.prev;
      }
      if (j.m_edgeA == bodyA.m_jointList) {
         bodyA.m_jointList = j.m_edgeA.next;
      }
      j.m_edgeA.prev = null;
      j.m_edgeA.next = null;
      if (j.m_edgeB.prev) {
         j.m_edgeB.prev.next = j.m_edgeB.next;
      }
      if (j.m_edgeB.next) {
         j.m_edgeB.next.prev = j.m_edgeB.prev;
      }
      if (j.m_edgeB == bodyB.m_jointList) {
         bodyB.m_jointList = j.m_edgeB.next;
      }
      j.m_edgeB.prev = null;
      j.m_edgeB.next = null;
      b2Joint.Destroy(j, null);
      --this.m_jointCount;
      if (collideConnected == false) {
         var edge = bodyB.GetContactList();
         while (edge) {
            if (edge.other == bodyA) {
               edge.contact.FlagForFiltering();
            }
            edge = edge.next;
         }
      }
   }
   b2World.prototype.AddController = function (c) {
      c.m_next = this.m_controllerList;
      c.m_prev = null;
      this.m_controllerList = c;
      c.m_world = this;
      this.m_controllerCount++;
      return c;
   }
   b2World.prototype.RemoveController = function (c) {
      if (c.m_prev) c.m_prev.m_next = c.m_next;
      if (c.m_next) c.m_next.m_prev = c.m_prev;
      if (this.m_controllerList == c) this.m_controllerList = c.m_next;
      this.m_controllerCount--;
   }
   b2World.prototype.CreateController = function (controller) {
      if (controller.m_world != this) throw new Error("Controller can only be a member of one world");
      controller.m_next = this.m_controllerList;
      controller.m_prev = null;
      if (this.m_controllerList) this.m_controllerList.m_prev = controller;
      this.m_controllerList = controller;
      ++this.m_controllerCount;
      controller.m_world = this;
      return controller;
   }
   b2World.prototype.DestroyController = function (controller) {
      controller.Clear();
      if (controller.m_next) controller.m_next.m_prev = controller.m_prev;
      if (controller.m_prev) controller.m_prev.m_next = controller.m_next;
      if (controller == this.m_controllerList) this.m_controllerList = controller.m_next;
      --this.m_controllerCount;
   }
   b2World.prototype.SetWarmStarting = function (flag) {
      b2World.m_warmStarting = flag;
   }
   b2World.prototype.SetContinuousPhysics = function (flag) {
      b2World.m_continuousPhysics = flag;
   }
   b2World.prototype.GetBodyCount = function () {
      return this.m_bodyCount;
   }
   b2World.prototype.GetJointCount = function () {
      return this.m_jointCount;
   }
   b2World.prototype.GetContactCount = function () {
      return this.m_contactCount;
   }
   b2World.prototype.SetGravity = function (gravity) {
      this.m_gravity = gravity;
   }
   b2World.prototype.GetGravity = function () {
      return this.m_gravity;
   }
   b2World.prototype.GetGroundBody = function () {
      return this.m_groundBody;
   }
   b2World.prototype.Step = function (dt, velocityIterations, positionIterations) {
      if (dt === undefined) dt = 0;
      if (velocityIterations === undefined) velocityIterations = 0;
      if (positionIterations === undefined) positionIterations = 0;
      if (this.m_flags & b2World.e_newFixture) {
         this.m_contactManager.FindNewContacts();
         this.m_flags &= ~b2World.e_newFixture;
      }
      this.m_flags |= b2World.e_locked;
      var step = b2World.s_timestep2;
      step.dt = dt;
      step.velocityIterations = velocityIterations;
      step.positionIterations = positionIterations;
      if (dt > 0.0) {
         step.inv_dt = 1.0 / dt;
      }
      else {
         step.inv_dt = 0.0;
      }
      step.dtRatio = this.m_inv_dt0 * dt;
      step.warmStarting = b2World.m_warmStarting;
      this.m_contactManager.Collide();
      if (step.dt > 0.0) {
         this.Solve(step);
      }
      if (b2World.m_continuousPhysics && step.dt > 0.0) {
         this.SolveTOI(step);
      }
      if (step.dt > 0.0) {
         this.m_inv_dt0 = step.inv_dt;
      }
      this.m_flags &= ~b2World.e_locked;
   }
   b2World.prototype.ClearForces = function () {
      for (var body = this.m_bodyList; body; body = body.m_next) {
         body.m_force.SetZero();
         body.m_torque = 0.0;
      }
   }
   b2World.prototype.DrawDebugData = function () {
      if (this.m_debugDraw == null) {
         return;
      }
      this.m_debugDraw.m_sprite.graphics.clear();
      var flags = this.m_debugDraw.GetFlags();
      var i = 0;
      var b;
      var f;
      var s;
      var j;
      var bp;
      var invQ = new b2Vec2;
      var x1 = new b2Vec2;
      var x2 = new b2Vec2;
      var xf;
      var b1 = new b2AABB();
      var b2 = new b2AABB();
      var vs = [new b2Vec2(), new b2Vec2(), new b2Vec2(), new b2Vec2()];
      var color = new b2Color(0, 0, 0);
      if (flags & b2DebugDraw.e_shapeBit) {
         for (b = this.m_bodyList;
         b; b = b.m_next) {
            xf = b.m_xf;
            for (f = b.GetFixtureList();
            f; f = f.m_next) {
               s = f.GetShape();
               if (b.IsActive() == false) {
                  color.Set(0.5, 0.5, 0.3);
                  this.DrawShape(s, xf, color);
               }
               else if (b.GetType() == b2Body.b2_staticBody) {
                  color.Set(0.5, 0.9, 0.5);
                  this.DrawShape(s, xf, color);
               }
               else if (b.GetType() == b2Body.b2_kinematicBody) {
                  color.Set(0.5, 0.5, 0.9);
                  this.DrawShape(s, xf, color);
               }
               else if (b.IsAwake() == false) {
                  color.Set(0.6, 0.6, 0.6);
                  this.DrawShape(s, xf, color);
               }
               else {
                  color.Set(0.9, 0.7, 0.7);
                  this.DrawShape(s, xf, color);
               }
            }
         }
      }
      if (flags & b2DebugDraw.e_jointBit) {
         for (j = this.m_jointList;
         j; j = j.m_next) {
            this.DrawJoint(j);
         }
      }
      if (flags & b2DebugDraw.e_controllerBit) {
         for (var c = this.m_controllerList; c; c = c.m_next) {
            c.Draw(this.m_debugDraw);
         }
      }
      if (flags & b2DebugDraw.e_pairBit) {
         color.Set(0.3, 0.9, 0.9);
         for (var contact = this.m_contactManager.m_contactList; contact; contact = contact.GetNext()) {
            var fixtureA = contact.GetFixtureA();
            var fixtureB = contact.GetFixtureB();
            var cA = fixtureA.GetAABB().GetCenter();
            var cB = fixtureB.GetAABB().GetCenter();
            this.m_debugDraw.DrawSegment(cA, cB, color);
         }
      }
      if (flags & b2DebugDraw.e_aabbBit) {
         bp = this.m_contactManager.m_broadPhase;
         vs = [new b2Vec2(), new b2Vec2(), new b2Vec2(), new b2Vec2()];
         for (b = this.m_bodyList;
         b; b = b.GetNext()) {
            if (b.IsActive() == false) {
               continue;
            }
            for (f = b.GetFixtureList();
            f; f = f.GetNext()) {
               var aabb = bp.GetFatAABB(f.m_proxy);
               vs[0].Set(aabb.lowerBound.x, aabb.lowerBound.y);
               vs[1].Set(aabb.upperBound.x, aabb.lowerBound.y);
               vs[2].Set(aabb.upperBound.x, aabb.upperBound.y);
               vs[3].Set(aabb.lowerBound.x, aabb.upperBound.y);
               this.m_debugDraw.DrawPolygon(vs, 4, color);
            }
         }
      }
      if (flags & b2DebugDraw.e_centerOfMassBit) {
         for (b = this.m_bodyList;
         b; b = b.m_next) {
            xf = b2World.s_xf;
            xf.R = b.m_xf.R;
            xf.position = b.GetWorldCenter();
            this.m_debugDraw.DrawTransform(xf);
         }
      }
   }
   b2World.prototype.QueryAABB = function (callback, aabb) {
      var __this = this;
      var broadPhase = __this.m_contactManager.m_broadPhase;

      function WorldQueryWrapper(proxy) {
         return callback(broadPhase.GetUserData(proxy));
      };
      broadPhase.Query(WorldQueryWrapper, aabb);
   }
   b2World.prototype.QueryShape = function (callback, shape, transform) {
      var __this = this;
      if (transform === undefined) transform = null;
      if (transform == null) {
         transform = new b2Transform();
         transform.SetIdentity();
      }
      var broadPhase = __this.m_contactManager.m_broadPhase;

      function WorldQueryWrapper(proxy) {
         var fixture = (broadPhase.GetUserData(proxy) instanceof b2Fixture ? broadPhase.GetUserData(proxy) : null);
         if (b2Shape.TestOverlap(shape, transform, fixture.GetShape(), fixture.GetBody().GetTransform())) return callback(fixture);
         return true;
      };
      var aabb = new b2AABB();
      shape.ComputeAABB(aabb, transform);
      broadPhase.Query(WorldQueryWrapper, aabb);
   }
   b2World.prototype.QueryPoint = function (callback, p) {
      var __this = this;
      var broadPhase = __this.m_contactManager.m_broadPhase;

      function WorldQueryWrapper(proxy) {
         var fixture = (broadPhase.GetUserData(proxy) instanceof b2Fixture ? broadPhase.GetUserData(proxy) : null);
         if (fixture.TestPoint(p)) return callback(fixture);
         return true;
      };
      var aabb = new b2AABB();
      aabb.lowerBound.Set(p.x - b2Settings.b2_linearSlop, p.y - b2Settings.b2_linearSlop);
      aabb.upperBound.Set(p.x + b2Settings.b2_linearSlop, p.y + b2Settings.b2_linearSlop);
      broadPhase.Query(WorldQueryWrapper, aabb);
   }
   b2World.prototype.RayCast = function (callback, point1, point2) {
      var __this = this;
      var broadPhase = __this.m_contactManager.m_broadPhase;
      var output = new b2RayCastOutput;

      function RayCastWrapper(input, proxy) {
         var userData = broadPhase.GetUserData(proxy);
         var fixture = (userData instanceof b2Fixture ? userData : null);
         var hit = fixture.RayCast(output, input);
         if (hit) {
            var fraction = output.fraction;
            var point = new b2Vec2((1.0 - fraction) * point1.x + fraction * point2.x, (1.0 - fraction) * point1.y + fraction * point2.y);
            return callback(fixture, point, output.normal, fraction);
         }
         return input.maxFraction;
      };
      var input = new b2RayCastInput(point1, point2);
      broadPhase.RayCast(RayCastWrapper, input);
   }
   b2World.prototype.RayCastOne = function (point1, point2) {
      var __this = this;
      var result;

      function RayCastOneWrapper(fixture, point, normal, fraction) {
         if (fraction === undefined) fraction = 0;
         result = fixture;
         return fraction;
      };
      __this.RayCast(RayCastOneWrapper, point1, point2);
      return result;
   }
   b2World.prototype.RayCastAll = function (point1, point2) {
      var __this = this;
      var result = new Vector();

      function RayCastAllWrapper(fixture, point, normal, fraction) {
         if (fraction === undefined) fraction = 0;
         result[result.length] = fixture;
         return 1;
      };
      __this.RayCast(RayCastAllWrapper, point1, point2);
      return result;
   }
   b2World.prototype.GetBodyList = function () {
      return this.m_bodyList;
   }
   b2World.prototype.GetJointList = function () {
      return this.m_jointList;
   }
   b2World.prototype.GetContactList = function () {
      return this.m_contactList;
   }
   b2World.prototype.IsLocked = function () {
      return (this.m_flags & b2World.e_locked) > 0;
   }
   b2World.prototype.Solve = function (step) {
      var b;
      for (var controller = this.m_controllerList; controller; controller = controller.m_next) {
         controller.Step(step);
      }
      var island = this.m_island;
      island.Initialize(this.m_bodyCount, this.m_contactCount, this.m_jointCount, null, this.m_contactManager.m_contactListener, this.m_contactSolver);
      for (b = this.m_bodyList;
      b; b = b.m_next) {
         b.m_flags &= ~b2Body.e_islandFlag;
      }
      for (var c = this.m_contactList; c; c = c.m_next) {
         c.m_flags &= ~b2Contact.e_islandFlag;
      }
      for (var j = this.m_jointList; j; j = j.m_next) {
         j.m_islandFlag = false;
      }
      var stackSize = parseInt(this.m_bodyCount);
      var stack = this.s_stack;
      for (var seed = this.m_bodyList; seed; seed = seed.m_next) {
         if (seed.m_flags & b2Body.e_islandFlag) {
            continue;
         }
         if (seed.IsAwake() == false || seed.IsActive() == false) {
            continue;
         }
         if (seed.GetType() == b2Body.b2_staticBody) {
            continue;
         }
         island.Clear();
         var stackCount = 0;
         stack[stackCount++] = seed;
         seed.m_flags |= b2Body.e_islandFlag;
         while (stackCount > 0) {
            b = stack[--stackCount];
            island.AddBody(b);
            if (b.IsAwake() == false) {
               b.SetAwake(true);
            }
            if (b.GetType() == b2Body.b2_staticBody) {
               continue;
            }
            var other;
            for (var ce = b.m_contactList; ce; ce = ce.next) {
               if (ce.contact.m_flags & b2Contact.e_islandFlag) {
                  continue;
               }
               if (ce.contact.IsSensor() == true || ce.contact.IsEnabled() == false || ce.contact.IsTouching() == false) {
                  continue;
               }
               island.AddContact(ce.contact);
               ce.contact.m_flags |= b2Contact.e_islandFlag;
               other = ce.other;
               if (other.m_flags & b2Body.e_islandFlag) {
                  continue;
               }
               stack[stackCount++] = other;
               other.m_flags |= b2Body.e_islandFlag;
            }
            for (var jn = b.m_jointList; jn; jn = jn.next) {
               if (jn.joint.m_islandFlag == true) {
                  continue;
               }
               other = jn.other;
               if (other.IsActive() == false) {
                  continue;
               }
               island.AddJoint(jn.joint);
               jn.joint.m_islandFlag = true;
               if (other.m_flags & b2Body.e_islandFlag) {
                  continue;
               }
               stack[stackCount++] = other;
               other.m_flags |= b2Body.e_islandFlag;
            }
         }
         island.Solve(step, this.m_gravity, this.m_allowSleep);
         for (var i = 0; i < island.m_bodyCount; ++i) {
            b = island.m_bodies[i];
            if (b.GetType() == b2Body.b2_staticBody) {
               b.m_flags &= ~b2Body.e_islandFlag;
            }
         }
      }
      for (i = 0;
      i < stack.length; ++i) {
         if (!stack[i]) break;
         stack[i] = null;
      }
      for (b = this.m_bodyList;
      b; b = b.m_next) {
         if (b.IsAwake() == false || b.IsActive() == false) {
            continue;
         }
         if (b.GetType() == b2Body.b2_staticBody) {
            continue;
         }
         b.SynchronizeFixtures();
      }
      this.m_contactManager.FindNewContacts();
   }
   b2World.prototype.SolveTOI = function (step) {
      var b;
      var fA;
      var fB;
      var bA;
      var bB;
      var cEdge;
      var j;
      var island = this.m_island;
      island.Initialize(this.m_bodyCount, b2Settings.b2_maxTOIContactsPerIsland, b2Settings.b2_maxTOIJointsPerIsland, null, this.m_contactManager.m_contactListener, this.m_contactSolver);
      var queue = b2World.s_queue;
      for (b = this.m_bodyList;
      b; b = b.m_next) {
         b.m_flags &= ~b2Body.e_islandFlag;
         b.m_sweep.t0 = 0.0;
      }
      var c;
      for (c = this.m_contactList;
      c; c = c.m_next) {
         c.m_flags &= ~ (b2Contact.e_toiFlag | b2Contact.e_islandFlag);
      }
      for (j = this.m_jointList;
      j; j = j.m_next) {
         j.m_islandFlag = false;
      }
      for (;;) {
         var minContact = null;
         var minTOI = 1.0;
         for (c = this.m_contactList;
         c; c = c.m_next) {
            if (c.IsSensor() == true || c.IsEnabled() == false || c.IsContinuous() == false) {
               continue;
            }
            var toi = 1.0;
            if (c.m_flags & b2Contact.e_toiFlag) {
               toi = c.m_toi;
            }
            else {
               fA = c.m_fixtureA;
               fB = c.m_fixtureB;
               bA = fA.m_body;
               bB = fB.m_body;
               if ((bA.GetType() != b2Body.b2_dynamicBody || bA.IsAwake() == false) && (bB.GetType() != b2Body.b2_dynamicBody || bB.IsAwake() == false)) {
                  continue;
               }
               var t0 = bA.m_sweep.t0;
               if (bA.m_sweep.t0 < bB.m_sweep.t0) {
                  t0 = bB.m_sweep.t0;
                  bA.m_sweep.Advance(t0);
               }
               else if (bB.m_sweep.t0 < bA.m_sweep.t0) {
                  t0 = bA.m_sweep.t0;
                  bB.m_sweep.Advance(t0);
               }
               toi = c.ComputeTOI(bA.m_sweep, bB.m_sweep);
               b2Settings.b2Assert(0.0 <= toi && toi <= 1.0);
               if (toi > 0.0 && toi < 1.0) {
                  toi = (1.0 - toi) * t0 + toi;
                  if (toi > 1) toi = 1;
               }
               c.m_toi = toi;
               c.m_flags |= b2Contact.e_toiFlag;
            }
            if (Number.MIN_VALUE < toi && toi < minTOI) {
               minContact = c;
               minTOI = toi;
            }
         }
         if (minContact == null || 1.0 - 100.0 * Number.MIN_VALUE < minTOI) {
            break;
         }
         fA = minContact.m_fixtureA;
         fB = minContact.m_fixtureB;
         bA = fA.m_body;
         bB = fB.m_body;
         b2World.s_backupA.Set(bA.m_sweep);
         b2World.s_backupB.Set(bB.m_sweep);
         bA.Advance(minTOI);
         bB.Advance(minTOI);
         minContact.Update(this.m_contactManager.m_contactListener);
         minContact.m_flags &= ~b2Contact.e_toiFlag;
         if (minContact.IsSensor() == true || minContact.IsEnabled() == false) {
            bA.m_sweep.Set(b2World.s_backupA);
            bB.m_sweep.Set(b2World.s_backupB);
            bA.SynchronizeTransform();
            bB.SynchronizeTransform();
            continue;
         }
         if (minContact.IsTouching() == false) {
            continue;
         }
         var seed = bA;
         if (seed.GetType() != b2Body.b2_dynamicBody) {
            seed = bB;
         }
         island.Clear();
         var queueStart = 0;
         var queueSize = 0;
         queue[queueStart + queueSize++] = seed;
         seed.m_flags |= b2Body.e_islandFlag;
         while (queueSize > 0) {
            b = queue[queueStart++];
            --queueSize;
            island.AddBody(b);
            if (b.IsAwake() == false) {
               b.SetAwake(true);
            }
            if (b.GetType() != b2Body.b2_dynamicBody) {
               continue;
            }
            for (cEdge = b.m_contactList;
            cEdge; cEdge = cEdge.next) {
               if (island.m_contactCount == island.m_contactCapacity) {
                  break;
               }
               if (cEdge.contact.m_flags & b2Contact.e_islandFlag) {
                  continue;
               }
               if (cEdge.contact.IsSensor() == true || cEdge.contact.IsEnabled() == false || cEdge.contact.IsTouching() == false) {
                  continue;
               }
               island.AddContact(cEdge.contact);
               cEdge.contact.m_flags |= b2Contact.e_islandFlag;
               var other = cEdge.other;
               if (other.m_flags & b2Body.e_islandFlag) {
                  continue;
               }
               if (other.GetType() != b2Body.b2_staticBody) {
                  other.Advance(minTOI);
                  other.SetAwake(true);
               }
               queue[queueStart + queueSize] = other;
               ++queueSize;
               other.m_flags |= b2Body.e_islandFlag;
            }
            for (var jEdge = b.m_jointList; jEdge; jEdge = jEdge.next) {
               if (island.m_jointCount == island.m_jointCapacity) continue;
               if (jEdge.joint.m_islandFlag == true) continue;
               other = jEdge.other;
               if (other.IsActive() == false) {
                  continue;
               }
               island.AddJoint(jEdge.joint);
               jEdge.joint.m_islandFlag = true;
               if (other.m_flags & b2Body.e_islandFlag) continue;
               if (other.GetType() != b2Body.b2_staticBody) {
                  other.Advance(minTOI);
                  other.SetAwake(true);
               }
               queue[queueStart + queueSize] = other;
               ++queueSize;
               other.m_flags |= b2Body.e_islandFlag;
            }
         }
         var subStep = b2World.s_timestep;
         subStep.warmStarting = false;
         subStep.dt = (1.0 - minTOI) * step.dt;
         subStep.inv_dt = 1.0 / subStep.dt;
         subStep.dtRatio = 0.0;
         subStep.velocityIterations = step.velocityIterations;
         subStep.positionIterations = step.positionIterations;
         island.SolveTOI(subStep);
         var i = 0;
         for (i = 0;
         i < island.m_bodyCount; ++i) {
            b = island.m_bodies[i];
            b.m_flags &= ~b2Body.e_islandFlag;
            if (b.IsAwake() == false) {
               continue;
            }
            if (b.GetType() != b2Body.b2_dynamicBody) {
               continue;
            }
            b.SynchronizeFixtures();
            for (cEdge = b.m_contactList;
            cEdge; cEdge = cEdge.next) {
               cEdge.contact.m_flags &= ~b2Contact.e_toiFlag;
            }
         }
         for (i = 0;
         i < island.m_contactCount; ++i) {
            c = island.m_contacts[i];
            c.m_flags &= ~ (b2Contact.e_toiFlag | b2Contact.e_islandFlag);
         }
         for (i = 0;
         i < island.m_jointCount; ++i) {
            j = island.m_joints[i];
            j.m_islandFlag = false;
         }
         this.m_contactManager.FindNewContacts();
      }
   }
   b2World.prototype.DrawJoint = function (joint) {
      var b1 = joint.GetBodyA();
      var b2 = joint.GetBodyB();
      var xf1 = b1.m_xf;
      var xf2 = b2.m_xf;
      var x1 = xf1.position;
      var x2 = xf2.position;
      var p1 = joint.GetAnchorA();
      var p2 = joint.GetAnchorB();
      var color = b2World.s_jointColor;
      switch (joint.m_type) {
      case b2Joint.e_distanceJoint:
         this.m_debugDraw.DrawSegment(p1, p2, color);
         break;
      case b2Joint.e_pulleyJoint:
         {
            var pulley = ((joint instanceof b2PulleyJoint ? joint : null));
            var s1 = pulley.GetGroundAnchorA();
            var s2 = pulley.GetGroundAnchorB();
            this.m_debugDraw.DrawSegment(s1, p1, color);
            this.m_debugDraw.DrawSegment(s2, p2, color);
            this.m_debugDraw.DrawSegment(s1, s2, color);
         }
         break;
      case b2Joint.e_mouseJoint:
         this.m_debugDraw.DrawSegment(p1, p2, color);
         break;
      default:
         if (b1 != this.m_groundBody) this.m_debugDraw.DrawSegment(x1, p1, color);
         this.m_debugDraw.DrawSegment(p1, p2, color);
         if (b2 != this.m_groundBody) this.m_debugDraw.DrawSegment(x2, p2, color);
      }
   }
   b2World.prototype.DrawShape = function (shape, xf, color) {
      switch (shape.m_type) {
      case b2Shape.e_circleShape:
         {
            var circle = ((shape instanceof b2CircleShape ? shape : null));
            var center = b2Math.MulX(xf, circle.m_p);
            var radius = circle.m_radius;
            var axis = xf.R.col1;
            this.m_debugDraw.DrawSolidCircle(center, radius, axis, color);
         }
         break;
      case b2Shape.e_polygonShape:
         {
            var i = 0;
            var poly = ((shape instanceof b2PolygonShape ? shape : null));
            var vertexCount = parseInt(poly.GetVertexCount());
            var localVertices = poly.GetVertices();
            var vertices = new Vector(vertexCount);
            for (i = 0;
            i < vertexCount; ++i) {
               vertices[i] = b2Math.MulX(xf, localVertices[i]);
            }
            this.m_debugDraw.DrawSolidPolygon(vertices, vertexCount, color);
         }
         break;
      case b2Shape.e_edgeShape:
         {
            var edge = (shape instanceof b2EdgeShape ? shape : null);
            this.m_debugDraw.DrawSegment(b2Math.MulX(xf, edge.GetVertex1()), b2Math.MulX(xf, edge.GetVertex2()), color);
         }
         break;
      }
   }
   Box2D.postDefs.push(function () {
      Box2D.Dynamics.b2World.s_timestep2 = new b2TimeStep();
      Box2D.Dynamics.b2World.s_xf = new b2Transform();
      Box2D.Dynamics.b2World.s_backupA = new b2Sweep();
      Box2D.Dynamics.b2World.s_backupB = new b2Sweep();
      Box2D.Dynamics.b2World.s_timestep = new b2TimeStep();
      Box2D.Dynamics.b2World.s_queue = new Vector();
      Box2D.Dynamics.b2World.s_jointColor = new b2Color(0.5, 0.8, 0.8);
      Box2D.Dynamics.b2World.e_newFixture = 0x0001;
      Box2D.Dynamics.b2World.e_locked = 0x0002;
   });
})();
(function () {
   var b2CircleShape = Box2D.Collision.Shapes.b2CircleShape,
      b2EdgeChainDef = Box2D.Collision.Shapes.b2EdgeChainDef,
      b2EdgeShape = Box2D.Collision.Shapes.b2EdgeShape,
      b2MassData = Box2D.Collision.Shapes.b2MassData,
      b2PolygonShape = Box2D.Collision.Shapes.b2PolygonShape,
      b2Shape = Box2D.Collision.Shapes.b2Shape,
      b2CircleContact = Box2D.Dynamics.Contacts.b2CircleContact,
      b2Contact = Box2D.Dynamics.Contacts.b2Contact,
      b2ContactConstraint = Box2D.Dynamics.Contacts.b2ContactConstraint,
      b2ContactConstraintPoint = Box2D.Dynamics.Contacts.b2ContactConstraintPoint,
      b2ContactEdge = Box2D.Dynamics.Contacts.b2ContactEdge,
      b2ContactFactory = Box2D.Dynamics.Contacts.b2ContactFactory,
      b2ContactRegister = Box2D.Dynamics.Contacts.b2ContactRegister,
      b2ContactResult = Box2D.Dynamics.Contacts.b2ContactResult,
      b2ContactSolver = Box2D.Dynamics.Contacts.b2ContactSolver,
      b2EdgeAndCircleContact = Box2D.Dynamics.Contacts.b2EdgeAndCircleContact,
      b2NullContact = Box2D.Dynamics.Contacts.b2NullContact,
      b2PolyAndCircleContact = Box2D.Dynamics.Contacts.b2PolyAndCircleContact,
      b2PolyAndEdgeContact = Box2D.Dynamics.Contacts.b2PolyAndEdgeContact,
      b2PolygonContact = Box2D.Dynamics.Contacts.b2PolygonContact,
      b2PositionSolverManifold = Box2D.Dynamics.Contacts.b2PositionSolverManifold,
      b2Body = Box2D.Dynamics.b2Body,
      b2BodyDef = Box2D.Dynamics.b2BodyDef,
      b2ContactFilter = Box2D.Dynamics.b2ContactFilter,
      b2ContactImpulse = Box2D.Dynamics.b2ContactImpulse,
      b2ContactListener = Box2D.Dynamics.b2ContactListener,
      b2ContactManager = Box2D.Dynamics.b2ContactManager,
      b2DebugDraw = Box2D.Dynamics.b2DebugDraw,
      b2DestructionListener = Box2D.Dynamics.b2DestructionListener,
      b2FilterData = Box2D.Dynamics.b2FilterData,
      b2Fixture = Box2D.Dynamics.b2Fixture,
      b2FixtureDef = Box2D.Dynamics.b2FixtureDef,
      b2Island = Box2D.Dynamics.b2Island,
      b2TimeStep = Box2D.Dynamics.b2TimeStep,
      b2World = Box2D.Dynamics.b2World,
      b2Color = Box2D.Common.b2Color,
      b2internal = Box2D.Common.b2internal,
      b2Settings = Box2D.Common.b2Settings,
      b2Mat22 = Box2D.Common.Math.b2Mat22,
      b2Mat33 = Box2D.Common.Math.b2Mat33,
      b2Math = Box2D.Common.Math.b2Math,
      b2Sweep = Box2D.Common.Math.b2Sweep,
      b2Transform = Box2D.Common.Math.b2Transform,
      b2Vec2 = Box2D.Common.Math.b2Vec2,
      b2Vec3 = Box2D.Common.Math.b2Vec3,
      b2AABB = Box2D.Collision.b2AABB,
      b2Bound = Box2D.Collision.b2Bound,
      b2BoundValues = Box2D.Collision.b2BoundValues,
      b2Collision = Box2D.Collision.b2Collision,
      b2ContactID = Box2D.Collision.b2ContactID,
      b2ContactPoint = Box2D.Collision.b2ContactPoint,
      b2Distance = Box2D.Collision.b2Distance,
      b2DistanceInput = Box2D.Collision.b2DistanceInput,
      b2DistanceOutput = Box2D.Collision.b2DistanceOutput,
      b2DistanceProxy = Box2D.Collision.b2DistanceProxy,
      b2DynamicTree = Box2D.Collision.b2DynamicTree,
      b2DynamicTreeBroadPhase = Box2D.Collision.b2DynamicTreeBroadPhase,
      b2DynamicTreeNode = Box2D.Collision.b2DynamicTreeNode,
      b2DynamicTreePair = Box2D.Collision.b2DynamicTreePair,
      b2Manifold = Box2D.Collision.b2Manifold,
      b2ManifoldPoint = Box2D.Collision.b2ManifoldPoint,
      b2Point = Box2D.Collision.b2Point,
      b2RayCastInput = Box2D.Collision.b2RayCastInput,
      b2RayCastOutput = Box2D.Collision.b2RayCastOutput,
      b2Segment = Box2D.Collision.b2Segment,
      b2SeparationFunction = Box2D.Collision.b2SeparationFunction,
      b2Simplex = Box2D.Collision.b2Simplex,
      b2SimplexCache = Box2D.Collision.b2SimplexCache,
      b2SimplexVertex = Box2D.Collision.b2SimplexVertex,
      b2TimeOfImpact = Box2D.Collision.b2TimeOfImpact,
      b2TOIInput = Box2D.Collision.b2TOIInput,
      b2WorldManifold = Box2D.Collision.b2WorldManifold,
      ClipVertex = Box2D.Collision.ClipVertex,
      Features = Box2D.Collision.Features,
      IBroadPhase = Box2D.Collision.IBroadPhase;

   Box2D.inherit(b2CircleContact, Box2D.Dynamics.Contacts.b2Contact);
   b2CircleContact.prototype.__super = Box2D.Dynamics.Contacts.b2Contact.prototype;
   b2CircleContact.b2CircleContact = function () {
      Box2D.Dynamics.Contacts.b2Contact.b2Contact.apply(this, arguments);
   };
   b2CircleContact.Create = function (allocator) {
      return new b2CircleContact();
   }
   b2CircleContact.Destroy = function (contact, allocator) {}
   b2CircleContact.prototype.Reset = function (fixtureA, fixtureB) {
      this.__super.Reset.call(this, fixtureA, fixtureB);
   }
   b2CircleContact.prototype.Evaluate = function () {
      var bA = this.m_fixtureA.GetBody();
      var bB = this.m_fixtureB.GetBody();
      b2Collision.CollideCircles(this.m_manifold, (this.m_fixtureA.GetShape() instanceof b2CircleShape ? this.m_fixtureA.GetShape() : null), bA.m_xf, (this.m_fixtureB.GetShape() instanceof b2CircleShape ? this.m_fixtureB.GetShape() : null), bB.m_xf);
   }
   b2Contact.b2Contact = function () {
      this.m_nodeA = new b2ContactEdge();
      this.m_nodeB = new b2ContactEdge();
      this.m_manifold = new b2Manifold();
      this.m_oldManifold = new b2Manifold();
   };
   b2Contact.prototype.GetManifold = function () {
      return this.m_manifold;
   }
   b2Contact.prototype.GetWorldManifold = function (worldManifold) {
      var bodyA = this.m_fixtureA.GetBody();
      var bodyB = this.m_fixtureB.GetBody();
      var shapeA = this.m_fixtureA.GetShape();
      var shapeB = this.m_fixtureB.GetShape();
      worldManifold.Initialize(this.m_manifold, bodyA.GetTransform(), shapeA.m_radius, bodyB.GetTransform(), shapeB.m_radius);
   }
   b2Contact.prototype.IsTouching = function () {
      return (this.m_flags & b2Contact.e_touchingFlag) == b2Contact.e_touchingFlag;
   }
   b2Contact.prototype.IsContinuous = function () {
      return (this.m_flags & b2Contact.e_continuousFlag) == b2Contact.e_continuousFlag;
   }
   b2Contact.prototype.SetSensor = function (sensor) {
      if (sensor) {
         this.m_flags |= b2Contact.e_sensorFlag;
      }
      else {
         this.m_flags &= ~b2Contact.e_sensorFlag;
      }
   }
   b2Contact.prototype.IsSensor = function () {
      return (this.m_flags & b2Contact.e_sensorFlag) == b2Contact.e_sensorFlag;
   }
   b2Contact.prototype.SetEnabled = function (flag) {
      if (flag) {
         this.m_flags |= b2Contact.e_enabledFlag;
      }
      else {
         this.m_flags &= ~b2Contact.e_enabledFlag;
      }
   }
   b2Contact.prototype.IsEnabled = function () {
      return (this.m_flags & b2Contact.e_enabledFlag) == b2Contact.e_enabledFlag;
   }
   b2Contact.prototype.GetNext = function () {
      return this.m_next;
   }
   b2Contact.prototype.GetFixtureA = function () {
      return this.m_fixtureA;
   }
   b2Contact.prototype.GetFixtureB = function () {
      return this.m_fixtureB;
   }
   b2Contact.prototype.FlagForFiltering = function () {
      this.m_flags |= b2Contact.e_filterFlag;
   }
   b2Contact.prototype.b2Contact = function () {}
   b2Contact.prototype.Reset = function (fixtureA, fixtureB) {
      if (fixtureA === undefined) fixtureA = null;
      if (fixtureB === undefined) fixtureB = null;
      this.m_flags = b2Contact.e_enabledFlag;
      if (!fixtureA || !fixtureB) {
         this.m_fixtureA = null;
         this.m_fixtureB = null;
         return;
      }
      if (fixtureA.IsSensor() || fixtureB.IsSensor()) {
         this.m_flags |= b2Contact.e_sensorFlag;
      }
      var bodyA = fixtureA.GetBody();
      var bodyB = fixtureB.GetBody();
      if (bodyA.GetType() != b2Body.b2_dynamicBody || bodyA.IsBullet() || bodyB.GetType() != b2Body.b2_dynamicBody || bodyB.IsBullet()) {
         this.m_flags |= b2Contact.e_continuousFlag;
      }
      this.m_fixtureA = fixtureA;
      this.m_fixtureB = fixtureB;
      this.m_manifold.m_pointCount = 0;
      this.m_prev = null;
      this.m_next = null;
      this.m_nodeA.contact = null;
      this.m_nodeA.prev = null;
      this.m_nodeA.next = null;
      this.m_nodeA.other = null;
      this.m_nodeB.contact = null;
      this.m_nodeB.prev = null;
      this.m_nodeB.next = null;
      this.m_nodeB.other = null;
   }
   b2Contact.prototype.Update = function (listener) {
      var tManifold = this.m_oldManifold;
      this.m_oldManifold = this.m_manifold;
      this.m_manifold = tManifold;
      this.m_flags |= b2Contact.e_enabledFlag;
      var touching = false;
      var wasTouching = (this.m_flags & b2Contact.e_touchingFlag) == b2Contact.e_touchingFlag;
      var bodyA = this.m_fixtureA.m_body;
      var bodyB = this.m_fixtureB.m_body;
      var aabbOverlap = this.m_fixtureA.m_aabb.TestOverlap(this.m_fixtureB.m_aabb);
      if (this.m_flags & b2Contact.e_sensorFlag) {
         if (aabbOverlap) {
            var shapeA = this.m_fixtureA.GetShape();
            var shapeB = this.m_fixtureB.GetShape();
            var xfA = bodyA.GetTransform();
            var xfB = bodyB.GetTransform();
            touching = b2Shape.TestOverlap(shapeA, xfA, shapeB, xfB);
         }
         this.m_manifold.m_pointCount = 0;
      }
      else {
         if (bodyA.GetType() != b2Body.b2_dynamicBody || bodyA.IsBullet() || bodyB.GetType() != b2Body.b2_dynamicBody || bodyB.IsBullet()) {
            this.m_flags |= b2Contact.e_continuousFlag;
         }
         else {
            this.m_flags &= ~b2Contact.e_continuousFlag;
         }
         if (aabbOverlap) {
            this.Evaluate();
            touching = this.m_manifold.m_pointCount > 0;
            for (var i = 0; i < this.m_manifold.m_pointCount; ++i) {
               var mp2 = this.m_manifold.m_points[i];
               mp2.m_normalImpulse = 0.0;
               mp2.m_tangentImpulse = 0.0;
               var id2 = mp2.m_id;
               for (var j = 0; j < this.m_oldManifold.m_pointCount; ++j) {
                  var mp1 = this.m_oldManifold.m_points[j];
                  if (mp1.m_id.key == id2.key) {
                     mp2.m_normalImpulse = mp1.m_normalImpulse;
                     mp2.m_tangentImpulse = mp1.m_tangentImpulse;
                     break;
                  }
               }
            }
         }
         else {
            this.m_manifold.m_pointCount = 0;
         }
         if (touching != wasTouching) {
            bodyA.SetAwake(true);
            bodyB.SetAwake(true);
         }
      }
      if (touching) {
         this.m_flags |= b2Contact.e_touchingFlag;
      }
      else {
         this.m_flags &= ~b2Contact.e_touchingFlag;
      }
      if (wasTouching == false && touching == true) {
         listener.BeginContact(this);
      }
      if (wasTouching == true && touching == false) {
         listener.EndContact(this);
      }
      if ((this.m_flags & b2Contact.e_sensorFlag) == 0) {
         listener.PreSolve(this, this.m_oldManifold);
      }
   }
   b2Contact.prototype.Evaluate = function () {}
   b2Contact.prototype.ComputeTOI = function (sweepA, sweepB) {
      b2Contact.s_input.proxyA.Set(this.m_fixtureA.GetShape());
      b2Contact.s_input.proxyB.Set(this.m_fixtureB.GetShape());
      b2Contact.s_input.sweepA = sweepA;
      b2Contact.s_input.sweepB = sweepB;
      b2Contact.s_input.tolerance = b2Settings.b2_linearSlop;
      return b2TimeOfImpact.TimeOfImpact(b2Contact.s_input);
   }
   Box2D.postDefs.push(function () {
      Box2D.Dynamics.Contacts.b2Contact.e_sensorFlag = 0x0001;
      Box2D.Dynamics.Contacts.b2Contact.e_continuousFlag = 0x0002;
      Box2D.Dynamics.Contacts.b2Contact.e_islandFlag = 0x0004;
      Box2D.Dynamics.Contacts.b2Contact.e_toiFlag = 0x0008;
      Box2D.Dynamics.Contacts.b2Contact.e_touchingFlag = 0x0010;
      Box2D.Dynamics.Contacts.b2Contact.e_enabledFlag = 0x0020;
      Box2D.Dynamics.Contacts.b2Contact.e_filterFlag = 0x0040;
      Box2D.Dynamics.Contacts.b2Contact.s_input = new b2TOIInput();
   });
   b2ContactConstraint.b2ContactConstraint = function () {
      this.localPlaneNormal = new b2Vec2();
      this.localPoint = new b2Vec2();
      this.normal = new b2Vec2();
      this.normalMass = new b2Mat22();
      this.K = new b2Mat22();
   };
   b2ContactConstraint.prototype.b2ContactConstraint = function () {
      this.points = new Vector(b2Settings.b2_maxManifoldPoints);
      for (var i = 0; i < b2Settings.b2_maxManifoldPoints; i++) {
         this.points[i] = new b2ContactConstraintPoint();
      }
   }
   b2ContactConstraintPoint.b2ContactConstraintPoint = function () {
      this.localPoint = new b2Vec2();
      this.rA = new b2Vec2();
      this.rB = new b2Vec2();
   };
   b2ContactEdge.b2ContactEdge = function () {};
   b2ContactFactory.b2ContactFactory = function () {};
   b2ContactFactory.prototype.b2ContactFactory = function (allocator) {
      this.m_allocator = allocator;
      this.InitializeRegisters();
   }
   b2ContactFactory.prototype.AddType = function (createFcn, destroyFcn, type1, type2) {
      if (type1 === undefined) type1 = 0;
      if (type2 === undefined) type2 = 0;
      this.m_registers[type1][type2].createFcn = createFcn;
      this.m_registers[type1][type2].destroyFcn = destroyFcn;
      this.m_registers[type1][type2].primary = true;
      if (type1 != type2) {
         this.m_registers[type2][type1].createFcn = createFcn;
         this.m_registers[type2][type1].destroyFcn = destroyFcn;
         this.m_registers[type2][type1].primary = false;
      }
   }
   b2ContactFactory.prototype.InitializeRegisters = function () {
      this.m_registers = new Vector(b2Shape.e_shapeTypeCount);
      for (var i = 0; i < b2Shape.e_shapeTypeCount; i++) {
         this.m_registers[i] = new Vector(b2Shape.e_shapeTypeCount);
         for (var j = 0; j < b2Shape.e_shapeTypeCount; j++) {
            this.m_registers[i][j] = new b2ContactRegister();
         }
      }
      this.AddType(b2CircleContact.Create, b2CircleContact.Destroy, b2Shape.e_circleShape, b2Shape.e_circleShape);
      this.AddType(b2PolyAndCircleContact.Create, b2PolyAndCircleContact.Destroy, b2Shape.e_polygonShape, b2Shape.e_circleShape);
      this.AddType(b2PolygonContact.Create, b2PolygonContact.Destroy, b2Shape.e_polygonShape, b2Shape.e_polygonShape);
      this.AddType(b2EdgeAndCircleContact.Create, b2EdgeAndCircleContact.Destroy, b2Shape.e_edgeShape, b2Shape.e_circleShape);
      this.AddType(b2PolyAndEdgeContact.Create, b2PolyAndEdgeContact.Destroy, b2Shape.e_polygonShape, b2Shape.e_edgeShape);
   }
   b2ContactFactory.prototype.Create = function (fixtureA, fixtureB) {
      var type1 = parseInt(fixtureA.GetType());
      var type2 = parseInt(fixtureB.GetType());
      var reg = this.m_registers[type1][type2];
      var c;
      if (reg.pool) {
         c = reg.pool;
         reg.pool = c.m_next;
         reg.poolCount--;
         c.Reset(fixtureA, fixtureB);
         return c;
      }
      var createFcn = reg.createFcn;
      if (createFcn != null) {
         if (reg.primary) {
            c = createFcn(this.m_allocator);
            c.Reset(fixtureA, fixtureB);
            return c;
         }
         else {
            c = createFcn(this.m_allocator);
            c.Reset(fixtureB, fixtureA);
            return c;
         }
      }
      else {
         return null;
      }
   }
   b2ContactFactory.prototype.Destroy = function (contact) {
      if (contact.m_manifold.m_pointCount > 0) {
         contact.m_fixtureA.m_body.SetAwake(true);
         contact.m_fixtureB.m_body.SetAwake(true);
      }
      var type1 = parseInt(contact.m_fixtureA.GetType());
      var type2 = parseInt(contact.m_fixtureB.GetType());
      var reg = this.m_registers[type1][type2];
      if (true) {
         reg.poolCount++;
         contact.m_next = reg.pool;
         reg.pool = contact;
      }
      var destroyFcn = reg.destroyFcn;
      destroyFcn(contact, this.m_allocator);
   }
   b2ContactRegister.b2ContactRegister = function () {};
   b2ContactResult.b2ContactResult = function () {
      this.position = new b2Vec2();
      this.normal = new b2Vec2();
      this.id = new b2ContactID();
   };
   b2ContactSolver.b2ContactSolver = function () {
      this.m_step = new b2TimeStep();
      this.m_constraints = new Vector();
   };
   b2ContactSolver.prototype.b2ContactSolver = function () {}
   b2ContactSolver.prototype.Initialize = function (step, contacts, contactCount, allocator) {
      if (contactCount === undefined) contactCount = 0;
      var contact;
      this.m_step.Set(step);
      this.m_allocator = allocator;
      var i = 0;
      var tVec;
      var tMat;
      this.m_constraintCount = contactCount;
      while (this.m_constraints.length < this.m_constraintCount) {
         this.m_constraints[this.m_constraints.length] = new b2ContactConstraint();
      }
      for (i = 0;
      i < contactCount; ++i) {
         contact = contacts[i];
         var fixtureA = contact.m_fixtureA;
         var fixtureB = contact.m_fixtureB;
         var shapeA = fixtureA.m_shape;
         var shapeB = fixtureB.m_shape;
         var radiusA = shapeA.m_radius;
         var radiusB = shapeB.m_radius;
         var bodyA = fixtureA.m_body;
         var bodyB = fixtureB.m_body;
         var manifold = contact.GetManifold();
         var friction = b2Settings.b2MixFriction(fixtureA.GetFriction(), fixtureB.GetFriction());
         var restitution = b2Settings.b2MixRestitution(fixtureA.GetRestitution(), fixtureB.GetRestitution());
         var vAX = bodyA.m_linearVelocity.x;
         var vAY = bodyA.m_linearVelocity.y;
         var vBX = bodyB.m_linearVelocity.x;
         var vBY = bodyB.m_linearVelocity.y;
         var wA = bodyA.m_angularVelocity;
         var wB = bodyB.m_angularVelocity;
         b2Settings.b2Assert(manifold.m_pointCount > 0);
         b2ContactSolver.s_worldManifold.Initialize(manifold, bodyA.m_xf, radiusA, bodyB.m_xf, radiusB);
         var normalX = b2ContactSolver.s_worldManifold.m_normal.x;
         var normalY = b2ContactSolver.s_worldManifold.m_normal.y;
         var cc = this.m_constraints[i];
         cc.bodyA = bodyA;
         cc.bodyB = bodyB;
         cc.manifold = manifold;
         cc.normal.x = normalX;
         cc.normal.y = normalY;
         cc.pointCount = manifold.m_pointCount;
         cc.friction = friction;
         cc.restitution = restitution;
         cc.localPlaneNormal.x = manifold.m_localPlaneNormal.x;
         cc.localPlaneNormal.y = manifold.m_localPlaneNormal.y;
         cc.localPoint.x = manifold.m_localPoint.x;
         cc.localPoint.y = manifold.m_localPoint.y;
         cc.radius = radiusA + radiusB;
         cc.type = manifold.m_type;
         for (var k = 0; k < cc.pointCount; ++k) {
            var cp = manifold.m_points[k];
            var ccp = cc.points[k];
            ccp.normalImpulse = cp.m_normalImpulse;
            ccp.tangentImpulse = cp.m_tangentImpulse;
            ccp.localPoint.SetV(cp.m_localPoint);
            var rAX = ccp.rA.x = b2ContactSolver.s_worldManifold.m_points[k].x - bodyA.m_sweep.c.x;
            var rAY = ccp.rA.y = b2ContactSolver.s_worldManifold.m_points[k].y - bodyA.m_sweep.c.y;
            var rBX = ccp.rB.x = b2ContactSolver.s_worldManifold.m_points[k].x - bodyB.m_sweep.c.x;
            var rBY = ccp.rB.y = b2ContactSolver.s_worldManifold.m_points[k].y - bodyB.m_sweep.c.y;
            var rnA = rAX * normalY - rAY * normalX;
            var rnB = rBX * normalY - rBY * normalX;
            rnA *= rnA;
            rnB *= rnB;
            var kNormal = bodyA.m_invMass + bodyB.m_invMass + bodyA.m_invI * rnA + bodyB.m_invI * rnB;
            ccp.normalMass = 1.0 / kNormal;
            var kEqualized = bodyA.m_mass * bodyA.m_invMass + bodyB.m_mass * bodyB.m_invMass;
            kEqualized += bodyA.m_mass * bodyA.m_invI * rnA + bodyB.m_mass * bodyB.m_invI * rnB;
            ccp.equalizedMass = 1.0 / kEqualized;
            var tangentX = normalY;
            var tangentY = (-normalX);
            var rtA = rAX * tangentY - rAY * tangentX;
            var rtB = rBX * tangentY - rBY * tangentX;
            rtA *= rtA;
            rtB *= rtB;
            var kTangent = bodyA.m_invMass + bodyB.m_invMass + bodyA.m_invI * rtA + bodyB.m_invI * rtB;
            ccp.tangentMass = 1.0 / kTangent;
            ccp.velocityBias = 0.0;
            var tX = vBX + ((-wB * rBY)) - vAX - ((-wA * rAY));
            var tY = vBY + (wB * rBX) - vAY - (wA * rAX);
            var vRel = cc.normal.x * tX + cc.normal.y * tY;
            if (vRel < (-b2Settings.b2_velocityThreshold)) {
               ccp.velocityBias += (-cc.restitution * vRel);
            }
         }
         if (cc.pointCount == 2) {
            var ccp1 = cc.points[0];
            var ccp2 = cc.points[1];
            var invMassA = bodyA.m_invMass;
            var invIA = bodyA.m_invI;
            var invMassB = bodyB.m_invMass;
            var invIB = bodyB.m_invI;
            var rn1A = ccp1.rA.x * normalY - ccp1.rA.y * normalX;
            var rn1B = ccp1.rB.x * normalY - ccp1.rB.y * normalX;
            var rn2A = ccp2.rA.x * normalY - ccp2.rA.y * normalX;
            var rn2B = ccp2.rB.x * normalY - ccp2.rB.y * normalX;
            var k11 = invMassA + invMassB + invIA * rn1A * rn1A + invIB * rn1B * rn1B;
            var k22 = invMassA + invMassB + invIA * rn2A * rn2A + invIB * rn2B * rn2B;
            var k12 = invMassA + invMassB + invIA * rn1A * rn2A + invIB * rn1B * rn2B;
            var k_maxConditionNumber = 100.0;
            if (k11 * k11 < k_maxConditionNumber * (k11 * k22 - k12 * k12)) {
               cc.K.col1.Set(k11, k12);
               cc.K.col2.Set(k12, k22);
               cc.K.GetInverse(cc.normalMass);
            }
            else {
               cc.pointCount = 1;
            }
         }
      }
   }
   b2ContactSolver.prototype.InitVelocityConstraints = function (step) {
      var tVec;
      var tVec2;
      var tMat;
      for (var i = 0; i < this.m_constraintCount; ++i) {
         var c = this.m_constraints[i];
         var bodyA = c.bodyA;
         var bodyB = c.bodyB;
         var invMassA = bodyA.m_invMass;
         var invIA = bodyA.m_invI;
         var invMassB = bodyB.m_invMass;
         var invIB = bodyB.m_invI;
         var normalX = c.normal.x;
         var normalY = c.normal.y;
         var tangentX = normalY;
         var tangentY = (-normalX);
         var tX = 0;
         var j = 0;
         var tCount = 0;
         if (step.warmStarting) {
            tCount = c.pointCount;
            for (j = 0;
            j < tCount; ++j) {
               var ccp = c.points[j];
               ccp.normalImpulse *= step.dtRatio;
               ccp.tangentImpulse *= step.dtRatio;
               var PX = ccp.normalImpulse * normalX + ccp.tangentImpulse * tangentX;
               var PY = ccp.normalImpulse * normalY + ccp.tangentImpulse * tangentY;
               bodyA.m_angularVelocity -= invIA * (ccp.rA.x * PY - ccp.rA.y * PX);
               bodyA.m_linearVelocity.x -= invMassA * PX;
               bodyA.m_linearVelocity.y -= invMassA * PY;
               bodyB.m_angularVelocity += invIB * (ccp.rB.x * PY - ccp.rB.y * PX);
               bodyB.m_linearVelocity.x += invMassB * PX;
               bodyB.m_linearVelocity.y += invMassB * PY;
            }
         }
         else {
            tCount = c.pointCount;
            for (j = 0;
            j < tCount; ++j) {
               var ccp2 = c.points[j];
               ccp2.normalImpulse = 0.0;
               ccp2.tangentImpulse = 0.0;
            }
         }
      }
   }
   b2ContactSolver.prototype.SolveVelocityConstraints = function () {
      var j = 0;
      var ccp;
      var rAX = 0;
      var rAY = 0;
      var rBX = 0;
      var rBY = 0;
      var dvX = 0;
      var dvY = 0;
      var vn = 0;
      var vt = 0;
      var lambda = 0;
      var maxFriction = 0;
      var newImpulse = 0;
      var PX = 0;
      var PY = 0;
      var dX = 0;
      var dY = 0;
      var P1X = 0;
      var P1Y = 0;
      var P2X = 0;
      var P2Y = 0;
      var tMat;
      var tVec;
      for (var i = 0; i < this.m_constraintCount; ++i) {
         var c = this.m_constraints[i];
         var bodyA = c.bodyA;
         var bodyB = c.bodyB;
         var wA = bodyA.m_angularVelocity;
         var wB = bodyB.m_angularVelocity;
         var vA = bodyA.m_linearVelocity;
         var vB = bodyB.m_linearVelocity;
         var invMassA = bodyA.m_invMass;
         var invIA = bodyA.m_invI;
         var invMassB = bodyB.m_invMass;
         var invIB = bodyB.m_invI;
         var normalX = c.normal.x;
         var normalY = c.normal.y;
         var tangentX = normalY;
         var tangentY = (-normalX);
         var friction = c.friction;
         var tX = 0;
         for (j = 0;
         j < c.pointCount; j++) {
            ccp = c.points[j];
            dvX = vB.x - wB * ccp.rB.y - vA.x + wA * ccp.rA.y;
            dvY = vB.y + wB * ccp.rB.x - vA.y - wA * ccp.rA.x;
            vt = dvX * tangentX + dvY * tangentY;
            lambda = ccp.tangentMass * (-vt);
            maxFriction = friction * ccp.normalImpulse;
            newImpulse = b2Math.Clamp(ccp.tangentImpulse + lambda, (-maxFriction), maxFriction);
            lambda = newImpulse - ccp.tangentImpulse;
            PX = lambda * tangentX;
            PY = lambda * tangentY;
            vA.x -= invMassA * PX;
            vA.y -= invMassA * PY;
            wA -= invIA * (ccp.rA.x * PY - ccp.rA.y * PX);
            vB.x += invMassB * PX;
            vB.y += invMassB * PY;
            wB += invIB * (ccp.rB.x * PY - ccp.rB.y * PX);
            ccp.tangentImpulse = newImpulse;
         }
         var tCount = parseInt(c.pointCount);
         if (c.pointCount == 1) {
            ccp = c.points[0];
            dvX = vB.x + ((-wB * ccp.rB.y)) - vA.x - ((-wA * ccp.rA.y));
            dvY = vB.y + (wB * ccp.rB.x) - vA.y - (wA * ccp.rA.x);
            vn = dvX * normalX + dvY * normalY;
            lambda = (-ccp.normalMass * (vn - ccp.velocityBias));
            newImpulse = ccp.normalImpulse + lambda;
            newImpulse = newImpulse > 0 ? newImpulse : 0.0;
            lambda = newImpulse - ccp.normalImpulse;
            PX = lambda * normalX;
            PY = lambda * normalY;
            vA.x -= invMassA * PX;
            vA.y -= invMassA * PY;
            wA -= invIA * (ccp.rA.x * PY - ccp.rA.y * PX);
            vB.x += invMassB * PX;
            vB.y += invMassB * PY;
            wB += invIB * (ccp.rB.x * PY - ccp.rB.y * PX);
            ccp.normalImpulse = newImpulse;
         }
         else {
            var cp1 = c.points[0];
            var cp2 = c.points[1];
            var aX = cp1.normalImpulse;
            var aY = cp2.normalImpulse;
            var dv1X = vB.x - wB * cp1.rB.y - vA.x + wA * cp1.rA.y;
            var dv1Y = vB.y + wB * cp1.rB.x - vA.y - wA * cp1.rA.x;
            var dv2X = vB.x - wB * cp2.rB.y - vA.x + wA * cp2.rA.y;
            var dv2Y = vB.y + wB * cp2.rB.x - vA.y - wA * cp2.rA.x;
            var vn1 = dv1X * normalX + dv1Y * normalY;
            var vn2 = dv2X * normalX + dv2Y * normalY;
            var bX = vn1 - cp1.velocityBias;
            var bY = vn2 - cp2.velocityBias;
            tMat = c.K;
            bX -= tMat.col1.x * aX + tMat.col2.x * aY;
            bY -= tMat.col1.y * aX + tMat.col2.y * aY;
            var k_errorTol = 0.001;
            for (;;) {
               tMat = c.normalMass;
               var xX = (-(tMat.col1.x * bX + tMat.col2.x * bY));
               var xY = (-(tMat.col1.y * bX + tMat.col2.y * bY));
               if (xX >= 0.0 && xY >= 0.0) {
                  dX = xX - aX;
                  dY = xY - aY;
                  P1X = dX * normalX;
                  P1Y = dX * normalY;
                  P2X = dY * normalX;
                  P2Y = dY * normalY;
                  vA.x -= invMassA * (P1X + P2X);
                  vA.y -= invMassA * (P1Y + P2Y);
                  wA -= invIA * (cp1.rA.x * P1Y - cp1.rA.y * P1X + cp2.rA.x * P2Y - cp2.rA.y * P2X);
                  vB.x += invMassB * (P1X + P2X);
                  vB.y += invMassB * (P1Y + P2Y);
                  wB += invIB * (cp1.rB.x * P1Y - cp1.rB.y * P1X + cp2.rB.x * P2Y - cp2.rB.y * P2X);
                  cp1.normalImpulse = xX;
                  cp2.normalImpulse = xY;
                  break;
               }
               xX = (-cp1.normalMass * bX);
               xY = 0.0;
               vn1 = 0.0;
               vn2 = c.K.col1.y * xX + bY;
               if (xX >= 0.0 && vn2 >= 0.0) {
                  dX = xX - aX;
                  dY = xY - aY;
                  P1X = dX * normalX;
                  P1Y = dX * normalY;
                  P2X = dY * normalX;
                  P2Y = dY * normalY;
                  vA.x -= invMassA * (P1X + P2X);
                  vA.y -= invMassA * (P1Y + P2Y);
                  wA -= invIA * (cp1.rA.x * P1Y - cp1.rA.y * P1X + cp2.rA.x * P2Y - cp2.rA.y * P2X);
                  vB.x += invMassB * (P1X + P2X);
                  vB.y += invMassB * (P1Y + P2Y);
                  wB += invIB * (cp1.rB.x * P1Y - cp1.rB.y * P1X + cp2.rB.x * P2Y - cp2.rB.y * P2X);
                  cp1.normalImpulse = xX;
                  cp2.normalImpulse = xY;
                  break;
               }
               xX = 0.0;
               xY = (-cp2.normalMass * bY);
               vn1 = c.K.col2.x * xY + bX;
               vn2 = 0.0;
               if (xY >= 0.0 && vn1 >= 0.0) {
                  dX = xX - aX;
                  dY = xY - aY;
                  P1X = dX * normalX;
                  P1Y = dX * normalY;
                  P2X = dY * normalX;
                  P2Y = dY * normalY;
                  vA.x -= invMassA * (P1X + P2X);
                  vA.y -= invMassA * (P1Y + P2Y);
                  wA -= invIA * (cp1.rA.x * P1Y - cp1.rA.y * P1X + cp2.rA.x * P2Y - cp2.rA.y * P2X);
                  vB.x += invMassB * (P1X + P2X);
                  vB.y += invMassB * (P1Y + P2Y);
                  wB += invIB * (cp1.rB.x * P1Y - cp1.rB.y * P1X + cp2.rB.x * P2Y - cp2.rB.y * P2X);
                  cp1.normalImpulse = xX;
                  cp2.normalImpulse = xY;
                  break;
               }
               xX = 0.0;
               xY = 0.0;
               vn1 = bX;
               vn2 = bY;
               if (vn1 >= 0.0 && vn2 >= 0.0) {
                  dX = xX - aX;
                  dY = xY - aY;
                  P1X = dX * normalX;
                  P1Y = dX * normalY;
                  P2X = dY * normalX;
                  P2Y = dY * normalY;
                  vA.x -= invMassA * (P1X + P2X);
                  vA.y -= invMassA * (P1Y + P2Y);
                  wA -= invIA * (cp1.rA.x * P1Y - cp1.rA.y * P1X + cp2.rA.x * P2Y - cp2.rA.y * P2X);
                  vB.x += invMassB * (P1X + P2X);
                  vB.y += invMassB * (P1Y + P2Y);
                  wB += invIB * (cp1.rB.x * P1Y - cp1.rB.y * P1X + cp2.rB.x * P2Y - cp2.rB.y * P2X);
                  cp1.normalImpulse = xX;
                  cp2.normalImpulse = xY;
                  break;
               }
               break;
            }
         }
         bodyA.m_angularVelocity = wA;
         bodyB.m_angularVelocity = wB;
      }
   }
   b2ContactSolver.prototype.FinalizeVelocityConstraints = function () {
      for (var i = 0; i < this.m_constraintCount; ++i) {
         var c = this.m_constraints[i];
         var m = c.manifold;
         for (var j = 0; j < c.pointCount; ++j) {
            var point1 = m.m_points[j];
            var point2 = c.points[j];
            point1.m_normalImpulse = point2.normalImpulse;
            point1.m_tangentImpulse = point2.tangentImpulse;
         }
      }
   }
   b2ContactSolver.prototype.SolvePositionConstraints = function (baumgarte) {
      if (baumgarte === undefined) baumgarte = 0;
      var minSeparation = 0.0;
      for (var i = 0; i < this.m_constraintCount; i++) {
         var c = this.m_constraints[i];
         var bodyA = c.bodyA;
         var bodyB = c.bodyB;
         var invMassA = bodyA.m_mass * bodyA.m_invMass;
         var invIA = bodyA.m_mass * bodyA.m_invI;
         var invMassB = bodyB.m_mass * bodyB.m_invMass;
         var invIB = bodyB.m_mass * bodyB.m_invI;
         b2ContactSolver.s_psm.Initialize(c);
         var normal = b2ContactSolver.s_psm.m_normal;
         for (var j = 0; j < c.pointCount; j++) {
            var ccp = c.points[j];
            var point = b2ContactSolver.s_psm.m_points[j];
            var separation = b2ContactSolver.s_psm.m_separations[j];
            var rAX = point.x - bodyA.m_sweep.c.x;
            var rAY = point.y - bodyA.m_sweep.c.y;
            var rBX = point.x - bodyB.m_sweep.c.x;
            var rBY = point.y - bodyB.m_sweep.c.y;
            minSeparation = minSeparation < separation ? minSeparation : separation;
            var C = b2Math.Clamp(baumgarte * (separation + b2Settings.b2_linearSlop), (-b2Settings.b2_maxLinearCorrection), 0.0);
            var impulse = (-ccp.equalizedMass * C);
            var PX = impulse * normal.x;
            var PY = impulse * normal.y;bodyA.m_sweep.c.x -= invMassA * PX;
            bodyA.m_sweep.c.y -= invMassA * PY;
            bodyA.m_sweep.a -= invIA * (rAX * PY - rAY * PX);
            bodyA.SynchronizeTransform();
            bodyB.m_sweep.c.x += invMassB * PX;
            bodyB.m_sweep.c.y += invMassB * PY;
            bodyB.m_sweep.a += invIB * (rBX * PY - rBY * PX);
            bodyB.SynchronizeTransform();
         }
      }
      return minSeparation > (-1.5 * b2Settings.b2_linearSlop);
   }
   Box2D.postDefs.push(function () {
      Box2D.Dynamics.Contacts.b2ContactSolver.s_worldManifold = new b2WorldManifold();
      Box2D.Dynamics.Contacts.b2ContactSolver.s_psm = new b2PositionSolverManifold();
   });
   Box2D.inherit(b2EdgeAndCircleContact, Box2D.Dynamics.Contacts.b2Contact);
   b2EdgeAndCircleContact.prototype.__super = Box2D.Dynamics.Contacts.b2Contact.prototype;
   b2EdgeAndCircleContact.b2EdgeAndCircleContact = function () {
      Box2D.Dynamics.Contacts.b2Contact.b2Contact.apply(this, arguments);
   };
   b2EdgeAndCircleContact.Create = function (allocator) {
      return new b2EdgeAndCircleContact();
   }
   b2EdgeAndCircleContact.Destroy = function (contact, allocator) {}
   b2EdgeAndCircleContact.prototype.Reset = function (fixtureA, fixtureB) {
      this.__super.Reset.call(this, fixtureA, fixtureB);
   }
   b2EdgeAndCircleContact.prototype.Evaluate = function () {
      var bA = this.m_fixtureA.GetBody();
      var bB = this.m_fixtureB.GetBody();
      this.b2CollideEdgeAndCircle(this.m_manifold, (this.m_fixtureA.GetShape() instanceof b2EdgeShape ? this.m_fixtureA.GetShape() : null), bA.m_xf, (this.m_fixtureB.GetShape() instanceof b2CircleShape ? this.m_fixtureB.GetShape() : null), bB.m_xf);
   }
   b2EdgeAndCircleContact.prototype.b2CollideEdgeAndCircle = function (manifold, edge, xf1, circle, xf2) {}
   Box2D.inherit(b2NullContact, Box2D.Dynamics.Contacts.b2Contact);
   b2NullContact.prototype.__super = Box2D.Dynamics.Contacts.b2Contact.prototype;
   b2NullContact.b2NullContact = function () {
      Box2D.Dynamics.Contacts.b2Contact.b2Contact.apply(this, arguments);
   };
   b2NullContact.prototype.b2NullContact = function () {
      this.__super.b2Contact.call(this);
   }
   b2NullContact.prototype.Evaluate = function () {}
   Box2D.inherit(b2PolyAndCircleContact, Box2D.Dynamics.Contacts.b2Contact);
   b2PolyAndCircleContact.prototype.__super = Box2D.Dynamics.Contacts.b2Contact.prototype;
   b2PolyAndCircleContact.b2PolyAndCircleContact = function () {
      Box2D.Dynamics.Contacts.b2Contact.b2Contact.apply(this, arguments);
   };
   b2PolyAndCircleContact.Create = function (allocator) {
      return new b2PolyAndCircleContact();
   }
   b2PolyAndCircleContact.Destroy = function (contact, allocator) {}
   b2PolyAndCircleContact.prototype.Reset = function (fixtureA, fixtureB) {
      this.__super.Reset.call(this, fixtureA, fixtureB);
      b2Settings.b2Assert(fixtureA.GetType() == b2Shape.e_polygonShape);
      b2Settings.b2Assert(fixtureB.GetType() == b2Shape.e_circleShape);
   }
   b2PolyAndCircleContact.prototype.Evaluate = function () {
      var bA = this.m_fixtureA.m_body;
      var bB = this.m_fixtureB.m_body;
      b2Collision.CollidePolygonAndCircle(this.m_manifold, (this.m_fixtureA.GetShape() instanceof b2PolygonShape ? this.m_fixtureA.GetShape() : null), bA.m_xf, (this.m_fixtureB.GetShape() instanceof b2CircleShape ? this.m_fixtureB.GetShape() : null), bB.m_xf);
   }
   Box2D.inherit(b2PolyAndEdgeContact, Box2D.Dynamics.Contacts.b2Contact);
   b2PolyAndEdgeContact.prototype.__super = Box2D.Dynamics.Contacts.b2Contact.prototype;
   b2PolyAndEdgeContact.b2PolyAndEdgeContact = function () {
      Box2D.Dynamics.Contacts.b2Contact.b2Contact.apply(this, arguments);
   };
   b2PolyAndEdgeContact.Create = function (allocator) {
      return new b2PolyAndEdgeContact();
   }
   b2PolyAndEdgeContact.Destroy = function (contact, allocator) {}
   b2PolyAndEdgeContact.prototype.Reset = function (fixtureA, fixtureB) {
      this.__super.Reset.call(this, fixtureA, fixtureB);
      b2Settings.b2Assert(fixtureA.GetType() == b2Shape.e_polygonShape);
      b2Settings.b2Assert(fixtureB.GetType() == b2Shape.e_edgeShape);
   }
   b2PolyAndEdgeContact.prototype.Evaluate = function () {
      var bA = this.m_fixtureA.GetBody();
      var bB = this.m_fixtureB.GetBody();
      this.b2CollidePolyAndEdge(this.m_manifold, (this.m_fixtureA.GetShape() instanceof b2PolygonShape ? this.m_fixtureA.GetShape() : null), bA.m_xf, (this.m_fixtureB.GetShape() instanceof b2EdgeShape ? this.m_fixtureB.GetShape() : null), bB.m_xf);
   }
   b2PolyAndEdgeContact.prototype.b2CollidePolyAndEdge = function (manifold, polygon, xf1, edge, xf2) {}
   Box2D.inherit(b2PolygonContact, Box2D.Dynamics.Contacts.b2Contact);
   b2PolygonContact.prototype.__super = Box2D.Dynamics.Contacts.b2Contact.prototype;
   b2PolygonContact.b2PolygonContact = function () {
      Box2D.Dynamics.Contacts.b2Contact.b2Contact.apply(this, arguments);
   };
   b2PolygonContact.Create = function (allocator) {
      return new b2PolygonContact();
   }
   b2PolygonContact.Destroy = function (contact, allocator) {}
   b2PolygonContact.prototype.Reset = function (fixtureA, fixtureB) {
      this.__super.Reset.call(this, fixtureA, fixtureB);
   }
   b2PolygonContact.prototype.Evaluate = function () {
      var bA = this.m_fixtureA.GetBody();
      var bB = this.m_fixtureB.GetBody();
      b2Collision.CollidePolygons(this.m_manifold, (this.m_fixtureA.GetShape() instanceof b2PolygonShape ? this.m_fixtureA.GetShape() : null), bA.m_xf, (this.m_fixtureB.GetShape() instanceof b2PolygonShape ? this.m_fixtureB.GetShape() : null), bB.m_xf);
   }
   b2PositionSolverManifold.b2PositionSolverManifold = function () {};
   b2PositionSolverManifold.prototype.b2PositionSolverManifold = function () {
      this.m_normal = new b2Vec2();
      this.m_separations = new Vector_a2j_Number(b2Settings.b2_maxManifoldPoints);
      this.m_points = new Vector(b2Settings.b2_maxManifoldPoints);
      for (var i = 0; i < b2Settings.b2_maxManifoldPoints; i++) {
         this.m_points[i] = new b2Vec2();
      }
   }
   b2PositionSolverManifold.prototype.Initialize = function (cc) {
      b2Settings.b2Assert(cc.pointCount > 0);
      var i = 0;
      var clipPointX = 0;
      var clipPointY = 0;
      var tMat;
      var tVec;
      var planePointX = 0;
      var planePointY = 0;
      switch (cc.type) {
      case b2Manifold.e_circles:
         {
            tMat = cc.bodyA.m_xf.R;
            tVec = cc.localPoint;
            var pointAX = cc.bodyA.m_xf.position.x + (tMat.col1.x * tVec.x + tMat.col2.x * tVec.y);
            var pointAY = cc.bodyA.m_xf.position.y + (tMat.col1.y * tVec.x + tMat.col2.y * tVec.y);
            tMat = cc.bodyB.m_xf.R;
            tVec = cc.points[0].localPoint;
            var pointBX = cc.bodyB.m_xf.position.x + (tMat.col1.x * tVec.x + tMat.col2.x * tVec.y);
            var pointBY = cc.bodyB.m_xf.position.y + (tMat.col1.y * tVec.x + tMat.col2.y * tVec.y);
            var dX = pointBX - pointAX;
            var dY = pointBY - pointAY;
            var d2 = dX * dX + dY * dY;
            if (d2 > Number.MIN_VALUE * Number.MIN_VALUE) {
               var d = Math.sqrt(d2);
               this.m_normal.x = dX / d;
               this.m_normal.y = dY / d;
            }
            else {
               this.m_normal.x = 1.0;
               this.m_normal.y = 0.0;
            }
            this.m_points[0].x = 0.5 * (pointAX + pointBX);
            this.m_points[0].y = 0.5 * (pointAY + pointBY);
            this.m_separations[0] = dX * this.m_normal.x + dY * this.m_normal.y - cc.radius;
         }
         break;
      case b2Manifold.e_faceA:
         {
            tMat = cc.bodyA.m_xf.R;
            tVec = cc.localPlaneNormal;
            this.m_normal.x = tMat.col1.x * tVec.x + tMat.col2.x * tVec.y;
            this.m_normal.y = tMat.col1.y * tVec.x + tMat.col2.y * tVec.y;
            tMat = cc.bodyA.m_xf.R;
            tVec = cc.localPoint;
            planePointX = cc.bodyA.m_xf.position.x + (tMat.col1.x * tVec.x + tMat.col2.x * tVec.y);
            planePointY = cc.bodyA.m_xf.position.y + (tMat.col1.y * tVec.x + tMat.col2.y * tVec.y);
            tMat = cc.bodyB.m_xf.R;
            for (i = 0;
            i < cc.pointCount; ++i) {
               tVec = cc.points[i].localPoint;
               clipPointX = cc.bodyB.m_xf.position.x + (tMat.col1.x * tVec.x + tMat.col2.x * tVec.y);
               clipPointY = cc.bodyB.m_xf.position.y + (tMat.col1.y * tVec.x + tMat.col2.y * tVec.y);
               this.m_separations[i] = (clipPointX - planePointX) * this.m_normal.x + (clipPointY - planePointY) * this.m_normal.y - cc.radius;
               this.m_points[i].x = clipPointX;
               this.m_points[i].y = clipPointY;
            }
         }
         break;
      case b2Manifold.e_faceB:
         {
            tMat = cc.bodyB.m_xf.R;
            tVec = cc.localPlaneNormal;
            this.m_normal.x = tMat.col1.x * tVec.x + tMat.col2.x * tVec.y;
            this.m_normal.y = tMat.col1.y * tVec.x + tMat.col2.y * tVec.y;
            tMat = cc.bodyB.m_xf.R;
            tVec = cc.localPoint;
            planePointX = cc.bodyB.m_xf.position.x + (tMat.col1.x * tVec.x + tMat.col2.x * tVec.y);
            planePointY = cc.bodyB.m_xf.position.y + (tMat.col1.y * tVec.x + tMat.col2.y * tVec.y);
            tMat = cc.bodyA.m_xf.R;
            for (i = 0;
            i < cc.pointCount; ++i) {
               tVec = cc.points[i].localPoint;
               clipPointX = cc.bodyA.m_xf.position.x + (tMat.col1.x * tVec.x + tMat.col2.x * tVec.y);
               clipPointY = cc.bodyA.m_xf.position.y + (tMat.col1.y * tVec.x + tMat.col2.y * tVec.y);
               this.m_separations[i] = (clipPointX - planePointX) * this.m_normal.x + (clipPointY - planePointY) * this.m_normal.y - cc.radius;
               this.m_points[i].Set(clipPointX, clipPointY);
            }
            this.m_normal.x *= (-1);
            this.m_normal.y *= (-1);
         }
         break;
      }
   }
   Box2D.postDefs.push(function () {
      Box2D.Dynamics.Contacts.b2PositionSolverManifold.circlePointA = new b2Vec2();
      Box2D.Dynamics.Contacts.b2PositionSolverManifold.circlePointB = new b2Vec2();
   });
})();
(function () {
   var b2Body = Box2D.Dynamics.b2Body,
      b2BodyDef = Box2D.Dynamics.b2BodyDef,
      b2ContactFilter = Box2D.Dynamics.b2ContactFilter,
      b2ContactImpulse = Box2D.Dynamics.b2ContactImpulse,
      b2ContactListener = Box2D.Dynamics.b2ContactListener,
      b2ContactManager = Box2D.Dynamics.b2ContactManager,
      b2DebugDraw = Box2D.Dynamics.b2DebugDraw,
      b2DestructionListener = Box2D.Dynamics.b2DestructionListener,
      b2FilterData = Box2D.Dynamics.b2FilterData,
      b2Fixture = Box2D.Dynamics.b2Fixture,
      b2FixtureDef = Box2D.Dynamics.b2FixtureDef,
      b2Island = Box2D.Dynamics.b2Island,
      b2TimeStep = Box2D.Dynamics.b2TimeStep,
      b2World = Box2D.Dynamics.b2World,
      b2Mat22 = Box2D.Common.Math.b2Mat22,
      b2Mat33 = Box2D.Common.Math.b2Mat33,
      b2Math = Box2D.Common.Math.b2Math,
      b2Sweep = Box2D.Common.Math.b2Sweep,
      b2Transform = Box2D.Common.Math.b2Transform,
      b2Vec2 = Box2D.Common.Math.b2Vec2,
      b2Vec3 = Box2D.Common.Math.b2Vec3,
      b2Color = Box2D.Common.b2Color,
      b2internal = Box2D.Common.b2internal,
      b2Settings = Box2D.Common.b2Settings,
      b2CircleShape = Box2D.Collision.Shapes.b2CircleShape,
      b2EdgeChainDef = Box2D.Collision.Shapes.b2EdgeChainDef,
      b2EdgeShape = Box2D.Collision.Shapes.b2EdgeShape,
      b2MassData = Box2D.Collision.Shapes.b2MassData,
      b2PolygonShape = Box2D.Collision.Shapes.b2PolygonShape,
      b2Shape = Box2D.Collision.Shapes.b2Shape,
      b2BuoyancyController = Box2D.Dynamics.Controllers.b2BuoyancyController,
      b2ConstantAccelController = Box2D.Dynamics.Controllers.b2ConstantAccelController,
      b2ConstantForceController = Box2D.Dynamics.Controllers.b2ConstantForceController,
      b2Controller = Box2D.Dynamics.Controllers.b2Controller,
      b2ControllerEdge = Box2D.Dynamics.Controllers.b2ControllerEdge,
      b2GravityController = Box2D.Dynamics.Controllers.b2GravityController,
      b2TensorDampingController = Box2D.Dynamics.Controllers.b2TensorDampingController;

   Box2D.inherit(b2BuoyancyController, Box2D.Dynamics.Controllers.b2Controller);
   b2BuoyancyController.prototype.__super = Box2D.Dynamics.Controllers.b2Controller.prototype;
   b2BuoyancyController.b2BuoyancyController = function () {
      Box2D.Dynamics.Controllers.b2Controller.b2Controller.apply(this, arguments);
      this.normal = new b2Vec2(0, (-1));
      this.offset = 0;
      this.density = 0;
      this.velocity = new b2Vec2(0, 0);
      this.linearDrag = 2;
      this.angularDrag = 1;
      this.useDensity = false;
      this.useWorldGravity = true;
      this.gravity = null;
   };
   b2BuoyancyController.prototype.Step = function (step) {
      if (!this.m_bodyList) return;
      if (this.useWorldGravity) {
         this.gravity = this.GetWorld().GetGravity().Copy();
      }
      for (var i = this.m_bodyList; i; i = i.nextBody) {
         var body = i.body;
         if (body.IsAwake() == false) {
            continue;
         }
         var areac = new b2Vec2();
         var massc = new b2Vec2();
         var area = 0.0;
         var mass = 0.0;
         for (var fixture = body.GetFixtureList(); fixture; fixture = fixture.GetNext()) {
            var sc = new b2Vec2();
            var sarea = fixture.GetShape().ComputeSubmergedArea(this.normal, this.offset, body.GetTransform(), sc);
            area += sarea;
            areac.x += sarea * sc.x;
            areac.y += sarea * sc.y;
            var shapeDensity = 0;
            if (this.useDensity) {
               shapeDensity = 1;
            }
            else {
               shapeDensity = 1;
            }
            mass += sarea * shapeDensity;
            massc.x += sarea * sc.x * shapeDensity;
            massc.y += sarea * sc.y * shapeDensity;
         }
         areac.x /= area;
         areac.y /= area;
         massc.x /= mass;
         massc.y /= mass;
         if (area < Number.MIN_VALUE) continue;
         var buoyancyForce = this.gravity.GetNegative();
         buoyancyForce.Multiply(this.density * area);
         body.ApplyForce(buoyancyForce, massc);
         var dragForce = body.GetLinearVelocityFromWorldPoint(areac);
         dragForce.Subtract(this.velocity);
         dragForce.Multiply((-this.linearDrag * area));
         body.ApplyForce(dragForce, areac);
         body.ApplyTorque((-body.GetInertia() / body.GetMass() * area * body.GetAngularVelocity() * this.angularDrag));
      }
   }
   b2BuoyancyController.prototype.Draw = function (debugDraw) {
      var r = 1000;
      var p1 = new b2Vec2();
      var p2 = new b2Vec2();
      p1.x = this.normal.x * this.offset + this.normal.y * r;
      p1.y = this.normal.y * this.offset - this.normal.x * r;
      p2.x = this.normal.x * this.offset - this.normal.y * r;
      p2.y = this.normal.y * this.offset + this.normal.x * r;
      var color = new b2Color(0, 0, 1);
      debugDraw.DrawSegment(p1, p2, color);
   }
   Box2D.inherit(b2ConstantAccelController, Box2D.Dynamics.Controllers.b2Controller);
   b2ConstantAccelController.prototype.__super = Box2D.Dynamics.Controllers.b2Controller.prototype;
   b2ConstantAccelController.b2ConstantAccelController = function () {
      Box2D.Dynamics.Controllers.b2Controller.b2Controller.apply(this, arguments);
      this.A = new b2Vec2(0, 0);
   };
   b2ConstantAccelController.prototype.Step = function (step) {
      var smallA = new b2Vec2(this.A.x * step.dt, this.A.y * step.dt);
      for (var i = this.m_bodyList; i; i = i.nextBody) {
         var body = i.body;
         if (!body.IsAwake()) continue;
         body.SetLinearVelocity(new b2Vec2(body.GetLinearVelocity().x + smallA.x, body.GetLinearVelocity().y + smallA.y));
      }
   }
   Box2D.inherit(b2ConstantForceController, Box2D.Dynamics.Controllers.b2Controller);
   b2ConstantForceController.prototype.__super = Box2D.Dynamics.Controllers.b2Controller.prototype;
   b2ConstantForceController.b2ConstantForceController = function () {
      Box2D.Dynamics.Controllers.b2Controller.b2Controller.apply(this, arguments);
      this.F = new b2Vec2(0, 0);
   };
   b2ConstantForceController.prototype.Step = function (step) {
      for (var i = this.m_bodyList; i; i = i.nextBody) {
         var body = i.body;
         if (!body.IsAwake()) continue;
         body.ApplyForce(this.F, body.GetWorldCenter());
      }
   }
   b2Controller.b2Controller = function () {};
   b2Controller.prototype.Step = function (step) {}
   b2Controller.prototype.Draw = function (debugDraw) {}
   b2Controller.prototype.AddBody = function (body) {
      var edge = new b2ControllerEdge();
      edge.controller = this;
      edge.body = body;
      edge.nextBody = this.m_bodyList;
      edge.prevBody = null;
      this.m_bodyList = edge;
      if (edge.nextBody) edge.nextBody.prevBody = edge;
      this.m_bodyCount++;
      edge.nextController = body.m_controllerList;
      edge.prevController = null;
      body.m_controllerList = edge;
      if (edge.nextController) edge.nextController.prevController = edge;
      body.m_controllerCount++;
   }
   b2Controller.prototype.RemoveBody = function (body) {
      var edge = body.m_controllerList;
      while (edge && edge.controller != this)
      edge = edge.nextController;
      if (edge.prevBody) edge.prevBody.nextBody = edge.nextBody;
      if (edge.nextBody) edge.nextBody.prevBody = edge.prevBody;
      if (edge.nextController) edge.nextController.prevController = edge.prevController;
      if (edge.prevController) edge.prevController.nextController = edge.nextController;
      if (this.m_bodyList == edge) this.m_bodyList = edge.nextBody;
      if (body.m_controllerList == edge) body.m_controllerList = edge.nextController;
      body.m_controllerCount--;
      this.m_bodyCount--;
   }
   b2Controller.prototype.Clear = function () {
      while (this.m_bodyList)
      this.RemoveBody(this.m_bodyList.body);
   }
   b2Controller.prototype.GetNext = function () {
      return this.m_next;
   }
   b2Controller.prototype.GetWorld = function () {
      return this.m_world;
   }
   b2Controller.prototype.GetBodyList = function () {
      return this.m_bodyList;
   }
   b2ControllerEdge.b2ControllerEdge = function () {};
   Box2D.inherit(b2GravityController, Box2D.Dynamics.Controllers.b2Controller);
   b2GravityController.prototype.__super = Box2D.Dynamics.Controllers.b2Controller.prototype;
   b2GravityController.b2GravityController = function () {
      Box2D.Dynamics.Controllers.b2Controller.b2Controller.apply(this, arguments);
      this.G = 1;
      this.invSqr = true;
   };
   b2GravityController.prototype.Step = function (step) {
      var i = null;
      var body1 = null;
      var p1 = null;
      var mass1 = 0;
      var j = null;
      var body2 = null;
      var p2 = null;
      var dx = 0;
      var dy = 0;
      var r2 = 0;
      var f = null;
      if (this.invSqr) {
         for (i = this.m_bodyList;
         i; i = i.nextBody) {
            body1 = i.body;
            p1 = body1.GetWorldCenter();
            mass1 = body1.GetMass();
            for (j = this.m_bodyList;
            j != i; j = j.nextBody) {
               body2 = j.body;
               p2 = body2.GetWorldCenter();
               dx = p2.x - p1.x;
               dy = p2.y - p1.y;
               r2 = dx * dx + dy * dy;
               if (r2 < Number.MIN_VALUE) continue;
               f = new b2Vec2(dx, dy);
               f.Multiply(this.G / r2 / Math.sqrt(r2) * mass1 * body2.GetMass());
               if (body1.IsAwake()) body1.ApplyForce(f, p1);
               f.Multiply((-1));
               if (body2.IsAwake()) body2.ApplyForce(f, p2);
            }
         }
      }
      else {
         for (i = this.m_bodyList;
         i; i = i.nextBody) {
            body1 = i.body;
            p1 = body1.GetWorldCenter();
            mass1 = body1.GetMass();
            for (j = this.m_bodyList;
            j != i; j = j.nextBody) {
               body2 = j.body;
               p2 = body2.GetWorldCenter();
               dx = p2.x - p1.x;
               dy = p2.y - p1.y;
               r2 = dx * dx + dy * dy;
               if (r2 < Number.MIN_VALUE) continue;
               f = new b2Vec2(dx, dy);
               f.Multiply(this.G / r2 * mass1 * body2.GetMass());
               if (body1.IsAwake()) body1.ApplyForce(f, p1);
               f.Multiply((-1));
               if (body2.IsAwake()) body2.ApplyForce(f, p2);
            }
         }
      }
   }
   Box2D.inherit(b2TensorDampingController, Box2D.Dynamics.Controllers.b2Controller);
   b2TensorDampingController.prototype.__super = Box2D.Dynamics.Controllers.b2Controller.prototype;
   b2TensorDampingController.b2TensorDampingController = function () {
      Box2D.Dynamics.Controllers.b2Controller.b2Controller.apply(this, arguments);
      this.T = new b2Mat22();
      this.maxTimestep = 0;
   };
   b2TensorDampingController.prototype.SetAxisAligned = function (xDamping, yDamping) {
      if (xDamping === undefined) xDamping = 0;
      if (yDamping === undefined) yDamping = 0;
      this.T.col1.x = (-xDamping);
      this.T.col1.y = 0;
      this.T.col2.x = 0;
      this.T.col2.y = (-yDamping);
      if (xDamping > 0 || yDamping > 0) {
         this.maxTimestep = 1 / Math.max(xDamping, yDamping);
      }
      else {
         this.maxTimestep = 0;
      }
   }
   b2TensorDampingController.prototype.Step = function (step) {
      var timestep = step.dt;
      if (timestep <= Number.MIN_VALUE) return;
      if (timestep > this.maxTimestep && this.maxTimestep > 0) timestep = this.maxTimestep;
      for (var i = this.m_bodyList; i; i = i.nextBody) {
         var body = i.body;
         if (!body.IsAwake()) {
            continue;
         }
         var damping = body.GetWorldVector(b2Math.MulMV(this.T, body.GetLocalVector(body.GetLinearVelocity())));
         body.SetLinearVelocity(new b2Vec2(body.GetLinearVelocity().x + damping.x * timestep, body.GetLinearVelocity().y + damping.y * timestep));
      }
   }
})();
(function () {
   var b2Color = Box2D.Common.b2Color,
      b2internal = Box2D.Common.b2internal,
      b2Settings = Box2D.Common.b2Settings,
      b2Mat22 = Box2D.Common.Math.b2Mat22,
      b2Mat33 = Box2D.Common.Math.b2Mat33,
      b2Math = Box2D.Common.Math.b2Math,
      b2Sweep = Box2D.Common.Math.b2Sweep,
      b2Transform = Box2D.Common.Math.b2Transform,
      b2Vec2 = Box2D.Common.Math.b2Vec2,
      b2Vec3 = Box2D.Common.Math.b2Vec3,
      b2DistanceJoint = Box2D.Dynamics.Joints.b2DistanceJoint,
      b2DistanceJointDef = Box2D.Dynamics.Joints.b2DistanceJointDef,
      b2FrictionJoint = Box2D.Dynamics.Joints.b2FrictionJoint,
      b2FrictionJointDef = Box2D.Dynamics.Joints.b2FrictionJointDef,
      b2GearJoint = Box2D.Dynamics.Joints.b2GearJoint,
      b2GearJointDef = Box2D.Dynamics.Joints.b2GearJointDef,
      b2Jacobian = Box2D.Dynamics.Joints.b2Jacobian,
      b2Joint = Box2D.Dynamics.Joints.b2Joint,
      b2JointDef = Box2D.Dynamics.Joints.b2JointDef,
      b2JointEdge = Box2D.Dynamics.Joints.b2JointEdge,
      b2LineJoint = Box2D.Dynamics.Joints.b2LineJoint,
      b2LineJointDef = Box2D.Dynamics.Joints.b2LineJointDef,
      b2MouseJoint = Box2D.Dynamics.Joints.b2MouseJoint,
      b2MouseJointDef = Box2D.Dynamics.Joints.b2MouseJointDef,
      b2PrismaticJoint = Box2D.Dynamics.Joints.b2PrismaticJoint,
      b2PrismaticJointDef = Box2D.Dynamics.Joints.b2PrismaticJointDef,
      b2PulleyJoint = Box2D.Dynamics.Joints.b2PulleyJoint,
      b2PulleyJointDef = Box2D.Dynamics.Joints.b2PulleyJointDef,
      b2RevoluteJoint = Box2D.Dynamics.Joints.b2RevoluteJoint,
      b2RevoluteJointDef = Box2D.Dynamics.Joints.b2RevoluteJointDef,
      b2WeldJoint = Box2D.Dynamics.Joints.b2WeldJoint,
      b2WeldJointDef = Box2D.Dynamics.Joints.b2WeldJointDef,
      b2Body = Box2D.Dynamics.b2Body,
      b2BodyDef = Box2D.Dynamics.b2BodyDef,
      b2ContactFilter = Box2D.Dynamics.b2ContactFilter,
      b2ContactImpulse = Box2D.Dynamics.b2ContactImpulse,
      b2ContactListener = Box2D.Dynamics.b2ContactListener,
      b2ContactManager = Box2D.Dynamics.b2ContactManager,
      b2DebugDraw = Box2D.Dynamics.b2DebugDraw,
      b2DestructionListener = Box2D.Dynamics.b2DestructionListener,
      b2FilterData = Box2D.Dynamics.b2FilterData,
      b2Fixture = Box2D.Dynamics.b2Fixture,
      b2FixtureDef = Box2D.Dynamics.b2FixtureDef,
      b2Island = Box2D.Dynamics.b2Island,
      b2TimeStep = Box2D.Dynamics.b2TimeStep,
      b2World = Box2D.Dynamics.b2World;

   Box2D.inherit(b2DistanceJoint, Box2D.Dynamics.Joints.b2Joint);
   b2DistanceJoint.prototype.__super = Box2D.Dynamics.Joints.b2Joint.prototype;
   b2DistanceJoint.b2DistanceJoint = function () {
      Box2D.Dynamics.Joints.b2Joint.b2Joint.apply(this, arguments);
      this.m_localAnchor1 = new b2Vec2();
      this.m_localAnchor2 = new b2Vec2();
      this.m_u = new b2Vec2();
   };
   b2DistanceJoint.prototype.GetAnchorA = function () {
      return this.m_bodyA.GetWorldPoint(this.m_localAnchor1);
   }
   b2DistanceJoint.prototype.GetAnchorB = function () {
      return this.m_bodyB.GetWorldPoint(this.m_localAnchor2);
   }
   b2DistanceJoint.prototype.GetReactionForce = function (inv_dt) {
      if (inv_dt === undefined) inv_dt = 0;
      return new b2Vec2(inv_dt * this.m_impulse * this.m_u.x, inv_dt * this.m_impulse * this.m_u.y);
   }
   b2DistanceJoint.prototype.GetReactionTorque = function (inv_dt) {
      if (inv_dt === undefined) inv_dt = 0;
      return 0.0;
   }
   b2DistanceJoint.prototype.GetLength = function () {
      return this.m_length;
   }
   b2DistanceJoint.prototype.SetLength = function (length) {
      if (length === undefined) length = 0;
      this.m_length = length;
   }
   b2DistanceJoint.prototype.GetFrequency = function () {
      return this.m_frequencyHz;
   }
   b2DistanceJoint.prototype.SetFrequency = function (hz) {
      if (hz === undefined) hz = 0;
      this.m_frequencyHz = hz;
   }
   b2DistanceJoint.prototype.GetDampingRatio = function () {
      return this.m_dampingRatio;
   }
   b2DistanceJoint.prototype.SetDampingRatio = function (ratio) {
      if (ratio === undefined) ratio = 0;
      this.m_dampingRatio = ratio;
   }
   b2DistanceJoint.prototype.b2DistanceJoint = function (def) {
      this.__super.b2Joint.call(this, def);
      var tMat;
      var tX = 0;
      var tY = 0;
      this.m_localAnchor1.SetV(def.localAnchorA);
      this.m_localAnchor2.SetV(def.localAnchorB);
      this.m_length = def.length;
      this.m_frequencyHz = def.frequencyHz;
      this.m_dampingRatio = def.dampingRatio;
      this.m_impulse = 0.0;
      this.m_gamma = 0.0;
      this.m_bias = 0.0;
   }
   b2DistanceJoint.prototype.InitVelocityConstraints = function (step) {
      var tMat;
      var tX = 0;
      var bA = this.m_bodyA;
      var bB = this.m_bodyB;
      tMat = bA.m_xf.R;
      var r1X = this.m_localAnchor1.x - bA.m_sweep.localCenter.x;
      var r1Y = this.m_localAnchor1.y - bA.m_sweep.localCenter.y;
      tX = (tMat.col1.x * r1X + tMat.col2.x * r1Y);
      r1Y = (tMat.col1.y * r1X + tMat.col2.y * r1Y);
      r1X = tX;
      tMat = bB.m_xf.R;
      var r2X = this.m_localAnchor2.x - bB.m_sweep.localCenter.x;
      var r2Y = this.m_localAnchor2.y - bB.m_sweep.localCenter.y;
      tX = (tMat.col1.x * r2X + tMat.col2.x * r2Y);
      r2Y = (tMat.col1.y * r2X + tMat.col2.y * r2Y);
      r2X = tX;
      this.m_u.x = bB.m_sweep.c.x + r2X - bA.m_sweep.c.x - r1X;
      this.m_u.y = bB.m_sweep.c.y + r2Y - bA.m_sweep.c.y - r1Y;
      var length = Math.sqrt(this.m_u.x * this.m_u.x + this.m_u.y * this.m_u.y);
      if (length > b2Settings.b2_linearSlop) {
         this.m_u.Multiply(1.0 / length);
      }
      else {
         this.m_u.SetZero();
      }
      var cr1u = (r1X * this.m_u.y - r1Y * this.m_u.x);
      var cr2u = (r2X * this.m_u.y - r2Y * this.m_u.x);
      var invMass = bA.m_invMass + bA.m_invI * cr1u * cr1u + bB.m_invMass + bB.m_invI * cr2u * cr2u;
      this.m_mass = invMass != 0.0 ? 1.0 / invMass : 0.0;
      if (this.m_frequencyHz > 0.0) {
         var C = length - this.m_length;
         var omega = 2.0 * Math.PI * this.m_frequencyHz;
         var d = 2.0 * this.m_mass * this.m_dampingRatio * omega;
         var k = this.m_mass * omega * omega;
         this.m_gamma = step.dt * (d + step.dt * k);
         this.m_gamma = this.m_gamma != 0.0 ? 1 / this.m_gamma : 0.0;
         this.m_bias = C * step.dt * k * this.m_gamma;
         this.m_mass = invMass + this.m_gamma;
         this.m_mass = this.m_mass != 0.0 ? 1.0 / this.m_mass : 0.0;
      }
      if (step.warmStarting) {
         this.m_impulse *= step.dtRatio;
         var PX = this.m_impulse * this.m_u.x;
         var PY = this.m_impulse * this.m_u.y;
         bA.m_linearVelocity.x -= bA.m_invMass * PX;
         bA.m_linearVelocity.y -= bA.m_invMass * PY;
         bA.m_angularVelocity -= bA.m_invI * (r1X * PY - r1Y * PX);
         bB.m_linearVelocity.x += bB.m_invMass * PX;
         bB.m_linearVelocity.y += bB.m_invMass * PY;
         bB.m_angularVelocity += bB.m_invI * (r2X * PY - r2Y * PX);
      }
      else {
         this.m_impulse = 0.0;
      }
   }
   b2DistanceJoint.prototype.SolveVelocityConstraints = function (step) {
      var tMat;
      var bA = this.m_bodyA;
      var bB = this.m_bodyB;
      tMat = bA.m_xf.R;
      var r1X = this.m_localAnchor1.x - bA.m_sweep.localCenter.x;
      var r1Y = this.m_localAnchor1.y - bA.m_sweep.localCenter.y;
      var tX = (tMat.col1.x * r1X + tMat.col2.x * r1Y);
      r1Y = (tMat.col1.y * r1X + tMat.col2.y * r1Y);
      r1X = tX;
      tMat = bB.m_xf.R;
      var r2X = this.m_localAnchor2.x - bB.m_sweep.localCenter.x;
      var r2Y = this.m_localAnchor2.y - bB.m_sweep.localCenter.y;
      tX = (tMat.col1.x * r2X + tMat.col2.x * r2Y);
      r2Y = (tMat.col1.y * r2X + tMat.col2.y * r2Y);
      r2X = tX;
      var v1X = bA.m_linearVelocity.x + ((-bA.m_angularVelocity * r1Y));
      var v1Y = bA.m_linearVelocity.y + (bA.m_angularVelocity * r1X);
      var v2X = bB.m_linearVelocity.x + ((-bB.m_angularVelocity * r2Y));
      var v2Y = bB.m_linearVelocity.y + (bB.m_angularVelocity * r2X);
      var Cdot = (this.m_u.x * (v2X - v1X) + this.m_u.y * (v2Y - v1Y));
      var impulse = (-this.m_mass * (Cdot + this.m_bias + this.m_gamma * this.m_impulse));
      this.m_impulse += impulse;
      var PX = impulse * this.m_u.x;
      var PY = impulse * this.m_u.y;
      bA.m_linearVelocity.x -= bA.m_invMass * PX;
      bA.m_linearVelocity.y -= bA.m_invMass * PY;
      bA.m_angularVelocity -= bA.m_invI * (r1X * PY - r1Y * PX);
      bB.m_linearVelocity.x += bB.m_invMass * PX;
      bB.m_linearVelocity.y += bB.m_invMass * PY;
      bB.m_angularVelocity += bB.m_invI * (r2X * PY - r2Y * PX);
   }
   b2DistanceJoint.prototype.SolvePositionConstraints = function (baumgarte) {
      if (baumgarte === undefined) baumgarte = 0;
      var tMat;
      if (this.m_frequencyHz > 0.0) {
         return true;
      }
      var bA = this.m_bodyA;
      var bB = this.m_bodyB;
      tMat = bA.m_xf.R;
      var r1X = this.m_localAnchor1.x - bA.m_sweep.localCenter.x;
      var r1Y = this.m_localAnchor1.y - bA.m_sweep.localCenter.y;
      var tX = (tMat.col1.x * r1X + tMat.col2.x * r1Y);
      r1Y = (tMat.col1.y * r1X + tMat.col2.y * r1Y);
      r1X = tX;
      tMat = bB.m_xf.R;
      var r2X = this.m_localAnchor2.x - bB.m_sweep.localCenter.x;
      var r2Y = this.m_localAnchor2.y - bB.m_sweep.localCenter.y;
      tX = (tMat.col1.x * r2X + tMat.col2.x * r2Y);
      r2Y = (tMat.col1.y * r2X + tMat.col2.y * r2Y);
      r2X = tX;
      var dX = bB.m_sweep.c.x + r2X - bA.m_sweep.c.x - r1X;
      var dY = bB.m_sweep.c.y + r2Y - bA.m_sweep.c.y - r1Y;
      var length = Math.sqrt(dX * dX + dY * dY);
      dX /= length;
      dY /= length;
      var C = length - this.m_length;
      C = b2Math.Clamp(C, (-b2Settings.b2_maxLinearCorrection), b2Settings.b2_maxLinearCorrection);
      var impulse = (-this.m_mass * C);
      this.m_u.Set(dX, dY);
      var PX = impulse * this.m_u.x;
      var PY = impulse * this.m_u.y;
      bA.m_sweep.c.x -= bA.m_invMass * PX;
      bA.m_sweep.c.y -= bA.m_invMass * PY;
      bA.m_sweep.a -= bA.m_invI * (r1X * PY - r1Y * PX);
      bB.m_sweep.c.x += bB.m_invMass * PX;
      bB.m_sweep.c.y += bB.m_invMass * PY;
      bB.m_sweep.a += bB.m_invI * (r2X * PY - r2Y * PX);
      bA.SynchronizeTransform();
      bB.SynchronizeTransform();
      return b2Math.Abs(C) < b2Settings.b2_linearSlop;
   }
   Box2D.inherit(b2DistanceJointDef, Box2D.Dynamics.Joints.b2JointDef);
   b2DistanceJointDef.prototype.__super = Box2D.Dynamics.Joints.b2JointDef.prototype;
   b2DistanceJointDef.b2DistanceJointDef = function () {
      Box2D.Dynamics.Joints.b2JointDef.b2JointDef.apply(this, arguments);
      this.localAnchorA = new b2Vec2();
      this.localAnchorB = new b2Vec2();
   };
   b2DistanceJointDef.prototype.b2DistanceJointDef = function () {
      this.__super.b2JointDef.call(this);
      this.type = b2Joint.e_distanceJoint;
      this.length = 1.0;
      this.frequencyHz = 0.0;
      this.dampingRatio = 0.0;
   }
   b2DistanceJointDef.prototype.Initialize = function (bA, bB, anchorA, anchorB) {
      this.bodyA = bA;
      this.bodyB = bB;
      this.localAnchorA.SetV(this.bodyA.GetLocalPoint(anchorA));
      this.localAnchorB.SetV(this.bodyB.GetLocalPoint(anchorB));
      var dX = anchorB.x - anchorA.x;
      var dY = anchorB.y - anchorA.y;
      this.length = Math.sqrt(dX * dX + dY * dY);
      this.frequencyHz = 0.0;
      this.dampingRatio = 0.0;
   }
   Box2D.inherit(b2FrictionJoint, Box2D.Dynamics.Joints.b2Joint);
   b2FrictionJoint.prototype.__super = Box2D.Dynamics.Joints.b2Joint.prototype;
   b2FrictionJoint.b2FrictionJoint = function () {
      Box2D.Dynamics.Joints.b2Joint.b2Joint.apply(this, arguments);
      this.m_localAnchorA = new b2Vec2();
      this.m_localAnchorB = new b2Vec2();
      this.m_linearMass = new b2Mat22();
      this.m_linearImpulse = new b2Vec2();
   };
   b2FrictionJoint.prototype.GetAnchorA = function () {
      return this.m_bodyA.GetWorldPoint(this.m_localAnchorA);
   }
   b2FrictionJoint.prototype.GetAnchorB = function () {
      return this.m_bodyB.GetWorldPoint(this.m_localAnchorB);
   }
   b2FrictionJoint.prototype.GetReactionForce = function (inv_dt) {
      if (inv_dt === undefined) inv_dt = 0;
      return new b2Vec2(inv_dt * this.m_linearImpulse.x, inv_dt * this.m_linearImpulse.y);
   }
   b2FrictionJoint.prototype.GetReactionTorque = function (inv_dt) {
      if (inv_dt === undefined) inv_dt = 0;
      return inv_dt * this.m_angularImpulse;
   }
   b2FrictionJoint.prototype.SetMaxForce = function (force) {
      if (force === undefined) force = 0;
      this.m_maxForce = force;
   }
   b2FrictionJoint.prototype.GetMaxForce = function () {
      return this.m_maxForce;
   }
   b2FrictionJoint.prototype.SetMaxTorque = function (torque) {
      if (torque === undefined) torque = 0;
      this.m_maxTorque = torque;
   }
   b2FrictionJoint.prototype.GetMaxTorque = function () {
      return this.m_maxTorque;
   }
   b2FrictionJoint.prototype.b2FrictionJoint = function (def) {
      this.__super.b2Joint.call(this, def);
      this.m_localAnchorA.SetV(def.localAnchorA);
      this.m_localAnchorB.SetV(def.localAnchorB);
      this.m_linearMass.SetZero();
      this.m_angularMass = 0.0;
      this.m_linearImpulse.SetZero();
      this.m_angularImpulse = 0.0;
      this.m_maxForce = def.maxForce;
      this.m_maxTorque = def.maxTorque;
   }
   b2FrictionJoint.prototype.InitVelocityConstraints = function (step) {
      var tMat;
      var tX = 0;
      var bA = this.m_bodyA;
      var bB = this.m_bodyB;
      tMat = bA.m_xf.R;
      var rAX = this.m_localAnchorA.x - bA.m_sweep.localCenter.x;
      var rAY = this.m_localAnchorA.y - bA.m_sweep.localCenter.y;
      tX = (tMat.col1.x * rAX + tMat.col2.x * rAY);
      rAY = (tMat.col1.y * rAX + tMat.col2.y * rAY);
      rAX = tX;
      tMat = bB.m_xf.R;
      var rBX = this.m_localAnchorB.x - bB.m_sweep.localCenter.x;
      var rBY = this.m_localAnchorB.y - bB.m_sweep.localCenter.y;
      tX = (tMat.col1.x * rBX + tMat.col2.x * rBY);
      rBY = (tMat.col1.y * rBX + tMat.col2.y * rBY);
      rBX = tX;
      var mA = bA.m_invMass;
      var mB = bB.m_invMass;
      var iA = bA.m_invI;
      var iB = bB.m_invI;
      var K = new b2Mat22();
      K.col1.x = mA + mB;
      K.col2.x = 0.0;
      K.col1.y = 0.0;
      K.col2.y = mA + mB;
      K.col1.x += iA * rAY * rAY;
      K.col2.x += (-iA * rAX * rAY);
      K.col1.y += (-iA * rAX * rAY);
      K.col2.y += iA * rAX * rAX;
      K.col1.x += iB * rBY * rBY;
      K.col2.x += (-iB * rBX * rBY);
      K.col1.y += (-iB * rBX * rBY);
      K.col2.y += iB * rBX * rBX;
      K.GetInverse(this.m_linearMass);
      this.m_angularMass = iA + iB;
      if (this.m_angularMass > 0.0) {
         this.m_angularMass = 1.0 / this.m_angularMass;
      }
      if (step.warmStarting) {
         this.m_linearImpulse.x *= step.dtRatio;
         this.m_linearImpulse.y *= step.dtRatio;
         this.m_angularImpulse *= step.dtRatio;
         var P = this.m_linearImpulse;
         bA.m_linearVelocity.x -= mA * P.x;
         bA.m_linearVelocity.y -= mA * P.y;
         bA.m_angularVelocity -= iA * (rAX * P.y - rAY * P.x + this.m_angularImpulse);
         bB.m_linearVelocity.x += mB * P.x;
         bB.m_linearVelocity.y += mB * P.y;
         bB.m_angularVelocity += iB * (rBX * P.y - rBY * P.x + this.m_angularImpulse);
      }
      else {
         this.m_linearImpulse.SetZero();
         this.m_angularImpulse = 0.0;
      }
   }
   b2FrictionJoint.prototype.SolveVelocityConstraints = function (step) {
      var tMat;
      var tX = 0;
      var bA = this.m_bodyA;
      var bB = this.m_bodyB;
      var vA = bA.m_linearVelocity;
      var wA = bA.m_angularVelocity;
      var vB = bB.m_linearVelocity;
      var wB = bB.m_angularVelocity;
      var mA = bA.m_invMass;
      var mB = bB.m_invMass;
      var iA = bA.m_invI;
      var iB = bB.m_invI;
      tMat = bA.m_xf.R;
      var rAX = this.m_localAnchorA.x - bA.m_sweep.localCenter.x;
      var rAY = this.m_localAnchorA.y - bA.m_sweep.localCenter.y;
      tX = (tMat.col1.x * rAX + tMat.col2.x * rAY);
      rAY = (tMat.col1.y * rAX + tMat.col2.y * rAY);
      rAX = tX;
      tMat = bB.m_xf.R;
      var rBX = this.m_localAnchorB.x - bB.m_sweep.localCenter.x;
      var rBY = this.m_localAnchorB.y - bB.m_sweep.localCenter.y;
      tX = (tMat.col1.x * rBX + tMat.col2.x * rBY);
      rBY = (tMat.col1.y * rBX + tMat.col2.y * rBY);
      rBX = tX;
      var maxImpulse = 0; {
         var Cdot = wB - wA;
         var impulse = (-this.m_angularMass * Cdot);
         var oldImpulse = this.m_angularImpulse;
         maxImpulse = step.dt * this.m_maxTorque;
         this.m_angularImpulse = b2Math.Clamp(this.m_angularImpulse + impulse, (-maxImpulse), maxImpulse);
         impulse = this.m_angularImpulse - oldImpulse;
         wA -= iA * impulse;
         wB += iB * impulse;
      } {
         var CdotX = vB.x - wB * rBY - vA.x + wA * rAY;
         var CdotY = vB.y + wB * rBX - vA.y - wA * rAX;
         var impulseV = b2Math.MulMV(this.m_linearMass, new b2Vec2((-CdotX), (-CdotY)));
         var oldImpulseV = this.m_linearImpulse.Copy();
         this.m_linearImpulse.Add(impulseV);
         maxImpulse = step.dt * this.m_maxForce;
         if (this.m_linearImpulse.LengthSquared() > maxImpulse * maxImpulse) {
            this.m_linearImpulse.Normalize();
            this.m_linearImpulse.Multiply(maxImpulse);
         }
         impulseV = b2Math.SubtractVV(this.m_linearImpulse, oldImpulseV);
         vA.x -= mA * impulseV.x;
         vA.y -= mA * impulseV.y;
         wA -= iA * (rAX * impulseV.y - rAY * impulseV.x);
         vB.x += mB * impulseV.x;
         vB.y += mB * impulseV.y;
         wB += iB * (rBX * impulseV.y - rBY * impulseV.x);
      }
      bA.m_angularVelocity = wA;
      bB.m_angularVelocity = wB;
   }
   b2FrictionJoint.prototype.SolvePositionConstraints = function (baumgarte) {
      if (baumgarte === undefined) baumgarte = 0;
      return true;
   }
   Box2D.inherit(b2FrictionJointDef, Box2D.Dynamics.Joints.b2JointDef);
   b2FrictionJointDef.prototype.__super = Box2D.Dynamics.Joints.b2JointDef.prototype;
   b2FrictionJointDef.b2FrictionJointDef = function () {
      Box2D.Dynamics.Joints.b2JointDef.b2JointDef.apply(this, arguments);
      this.localAnchorA = new b2Vec2();
      this.localAnchorB = new b2Vec2();
   };
   b2FrictionJointDef.prototype.b2FrictionJointDef = function () {
      this.__super.b2JointDef.call(this);
      this.type = b2Joint.e_frictionJoint;
      this.maxForce = 0.0;
      this.maxTorque = 0.0;
   }
   b2FrictionJointDef.prototype.Initialize = function (bA, bB, anchor) {
      this.bodyA = bA;
      this.bodyB = bB;
      this.localAnchorA.SetV(this.bodyA.GetLocalPoint(anchor));
      this.localAnchorB.SetV(this.bodyB.GetLocalPoint(anchor));
   }
   Box2D.inherit(b2GearJoint, Box2D.Dynamics.Joints.b2Joint);
   b2GearJoint.prototype.__super = Box2D.Dynamics.Joints.b2Joint.prototype;
   b2GearJoint.b2GearJoint = function () {
      Box2D.Dynamics.Joints.b2Joint.b2Joint.apply(this, arguments);
      this.m_groundAnchor1 = new b2Vec2();
      this.m_groundAnchor2 = new b2Vec2();
      this.m_localAnchor1 = new b2Vec2();
      this.m_localAnchor2 = new b2Vec2();
      this.m_J = new b2Jacobian();
   };
   b2GearJoint.prototype.GetAnchorA = function () {
      return this.m_bodyA.GetWorldPoint(this.m_localAnchor1);
   }
   b2GearJoint.prototype.GetAnchorB = function () {
      return this.m_bodyB.GetWorldPoint(this.m_localAnchor2);
   }
   b2GearJoint.prototype.GetReactionForce = function (inv_dt) {
      if (inv_dt === undefined) inv_dt = 0;
      return new b2Vec2(inv_dt * this.m_impulse * this.m_J.linearB.x, inv_dt * this.m_impulse * this.m_J.linearB.y);
   }
   b2GearJoint.prototype.GetReactionTorque = function (inv_dt) {
      if (inv_dt === undefined) inv_dt = 0;
      var tMat = this.m_bodyB.m_xf.R;
      var rX = this.m_localAnchor1.x - this.m_bodyB.m_sweep.localCenter.x;
      var rY = this.m_localAnchor1.y - this.m_bodyB.m_sweep.localCenter.y;
      var tX = tMat.col1.x * rX + tMat.col2.x * rY;
      rY = tMat.col1.y * rX + tMat.col2.y * rY;
      rX = tX;
      var PX = this.m_impulse * this.m_J.linearB.x;
      var PY = this.m_impulse * this.m_J.linearB.y;
      return inv_dt * (this.m_impulse * this.m_J.angularB - rX * PY + rY * PX);
   }
   b2GearJoint.prototype.GetRatio = function () {
      return this.m_ratio;
   }
   b2GearJoint.prototype.SetRatio = function (ratio) {
      if (ratio === undefined) ratio = 0;
      this.m_ratio = ratio;
   }
   b2GearJoint.prototype.b2GearJoint = function (def) {
      this.__super.b2Joint.call(this, def);
      var type1 = parseInt(def.joint1.m_type);
      var type2 = parseInt(def.joint2.m_type);
      this.m_revolute1 = null;
      this.m_prismatic1 = null;
      this.m_revolute2 = null;
      this.m_prismatic2 = null;
      var coordinate1 = 0;
      var coordinate2 = 0;
      this.m_ground1 = def.joint1.GetBodyA();
      this.m_bodyA = def.joint1.GetBodyB();
      if (type1 == b2Joint.e_revoluteJoint) {
         this.m_revolute1 = (def.joint1 instanceof b2RevoluteJoint ? def.joint1 : null);
         this.m_groundAnchor1.SetV(this.m_revolute1.m_localAnchor1);
         this.m_localAnchor1.SetV(this.m_revolute1.m_localAnchor2);
         coordinate1 = this.m_revolute1.GetJointAngle();
      }
      else {
         this.m_prismatic1 = (def.joint1 instanceof b2PrismaticJoint ? def.joint1 : null);
         this.m_groundAnchor1.SetV(this.m_prismatic1.m_localAnchor1);
         this.m_localAnchor1.SetV(this.m_prismatic1.m_localAnchor2);
         coordinate1 = this.m_prismatic1.GetJointTranslation();
      }
      this.m_ground2 = def.joint2.GetBodyA();
      this.m_bodyB = def.joint2.GetBodyB();
      if (type2 == b2Joint.e_revoluteJoint) {
         this.m_revolute2 = (def.joint2 instanceof b2RevoluteJoint ? def.joint2 : null);
         this.m_groundAnchor2.SetV(this.m_revolute2.m_localAnchor1);
         this.m_localAnchor2.SetV(this.m_revolute2.m_localAnchor2);
         coordinate2 = this.m_revolute2.GetJointAngle();
      }
      else {
         this.m_prismatic2 = (def.joint2 instanceof b2PrismaticJoint ? def.joint2 : null);
         this.m_groundAnchor2.SetV(this.m_prismatic2.m_localAnchor1);
         this.m_localAnchor2.SetV(this.m_prismatic2.m_localAnchor2);
         coordinate2 = this.m_prismatic2.GetJointTranslation();
      }
      this.m_ratio = def.ratio;
      this.m_constant = coordinate1 + this.m_ratio * coordinate2;
      this.m_impulse = 0.0;
   }
   b2GearJoint.prototype.InitVelocityConstraints = function (step) {
      var g1 = this.m_ground1;
      var g2 = this.m_ground2;
      var bA = this.m_bodyA;
      var bB = this.m_bodyB;
      var ugX = 0;
      var ugY = 0;
      var rX = 0;
      var rY = 0;
      var tMat;
      var tVec;
      var crug = 0;
      var tX = 0;
      var K = 0.0;
      this.m_J.SetZero();
      if (this.m_revolute1) {
         this.m_J.angularA = (-1.0);
         K += bA.m_invI;
      }
      else {
         tMat = g1.m_xf.R;
         tVec = this.m_prismatic1.m_localXAxis1;
         ugX = tMat.col1.x * tVec.x + tMat.col2.x * tVec.y;
         ugY = tMat.col1.y * tVec.x + tMat.col2.y * tVec.y;
         tMat = bA.m_xf.R;
         rX = this.m_localAnchor1.x - bA.m_sweep.localCenter.x;
         rY = this.m_localAnchor1.y - bA.m_sweep.localCenter.y;
         tX = tMat.col1.x * rX + tMat.col2.x * rY;
         rY = tMat.col1.y * rX + tMat.col2.y * rY;
         rX = tX;
         crug = rX * ugY - rY * ugX;
         this.m_J.linearA.Set((-ugX), (-ugY));
         this.m_J.angularA = (-crug);
         K += bA.m_invMass + bA.m_invI * crug * crug;
      }
      if (this.m_revolute2) {
         this.m_J.angularB = (-this.m_ratio);
         K += this.m_ratio * this.m_ratio * bB.m_invI;
      }
      else {
         tMat = g2.m_xf.R;
         tVec = this.m_prismatic2.m_localXAxis1;
         ugX = tMat.col1.x * tVec.x + tMat.col2.x * tVec.y;
         ugY = tMat.col1.y * tVec.x + tMat.col2.y * tVec.y;
         tMat = bB.m_xf.R;
         rX = this.m_localAnchor2.x - bB.m_sweep.localCenter.x;
         rY = this.m_localAnchor2.y - bB.m_sweep.localCenter.y;
         tX = tMat.col1.x * rX + tMat.col2.x * rY;
         rY = tMat.col1.y * rX + tMat.col2.y * rY;
         rX = tX;
         crug = rX * ugY - rY * ugX;
         this.m_J.linearB.Set((-this.m_ratio * ugX), (-this.m_ratio * ugY));
         this.m_J.angularB = (-this.m_ratio * crug);
         K += this.m_ratio * this.m_ratio * (bB.m_invMass + bB.m_invI * crug * crug);
      }
      this.m_mass = K > 0.0 ? 1.0 / K : 0.0;
      if (step.warmStarting) {
         bA.m_linearVelocity.x += bA.m_invMass * this.m_impulse * this.m_J.linearA.x;
         bA.m_linearVelocity.y += bA.m_invMass * this.m_impulse * this.m_J.linearA.y;
         bA.m_angularVelocity += bA.m_invI * this.m_impulse * this.m_J.angularA;
         bB.m_linearVelocity.x += bB.m_invMass * this.m_impulse * this.m_J.linearB.x;
         bB.m_linearVelocity.y += bB.m_invMass * this.m_impulse * this.m_J.linearB.y;
         bB.m_angularVelocity += bB.m_invI * this.m_impulse * this.m_J.angularB;
      }
      else {
         this.m_impulse = 0.0;
      }
   }
   b2GearJoint.prototype.SolveVelocityConstraints = function (step) {
      var bA = this.m_bodyA;
      var bB = this.m_bodyB;
      var Cdot = this.m_J.Compute(bA.m_linearVelocity, bA.m_angularVelocity, bB.m_linearVelocity, bB.m_angularVelocity);
      var impulse = (-this.m_mass * Cdot);
      this.m_impulse += impulse;
      bA.m_linearVelocity.x += bA.m_invMass * impulse * this.m_J.linearA.x;
      bA.m_linearVelocity.y += bA.m_invMass * impulse * this.m_J.linearA.y;
      bA.m_angularVelocity += bA.m_invI * impulse * this.m_J.angularA;
      bB.m_linearVelocity.x += bB.m_invMass * impulse * this.m_J.linearB.x;
      bB.m_linearVelocity.y += bB.m_invMass * impulse * this.m_J.linearB.y;
      bB.m_angularVelocity += bB.m_invI * impulse * this.m_J.angularB;
   }
   b2GearJoint.prototype.SolvePositionConstraints = function (baumgarte) {
      if (baumgarte === undefined) baumgarte = 0;
      var linearError = 0.0;
      var bA = this.m_bodyA;
      var bB = this.m_bodyB;
      var coordinate1 = 0;
      var coordinate2 = 0;
      if (this.m_revolute1) {
         coordinate1 = this.m_revolute1.GetJointAngle();
      }
      else {
         coordinate1 = this.m_prismatic1.GetJointTranslation();
      }
      if (this.m_revolute2) {
         coordinate2 = this.m_revolute2.GetJointAngle();
      }
      else {
         coordinate2 = this.m_prismatic2.GetJointTranslation();
      }
      var C = this.m_constant - (coordinate1 + this.m_ratio * coordinate2);
      var impulse = (-this.m_mass * C);
      bA.m_sweep.c.x += bA.m_invMass * impulse * this.m_J.linearA.x;
      bA.m_sweep.c.y += bA.m_invMass * impulse * this.m_J.linearA.y;
      bA.m_sweep.a += bA.m_invI * impulse * this.m_J.angularA;
      bB.m_sweep.c.x += bB.m_invMass * impulse * this.m_J.linearB.x;
      bB.m_sweep.c.y += bB.m_invMass * impulse * this.m_J.linearB.y;
      bB.m_sweep.a += bB.m_invI * impulse * this.m_J.angularB;
      bA.SynchronizeTransform();
      bB.SynchronizeTransform();
      return linearError < b2Settings.b2_linearSlop;
   }
   Box2D.inherit(b2GearJointDef, Box2D.Dynamics.Joints.b2JointDef);
   b2GearJointDef.prototype.__super = Box2D.Dynamics.Joints.b2JointDef.prototype;
   b2GearJointDef.b2GearJointDef = function () {
      Box2D.Dynamics.Joints.b2JointDef.b2JointDef.apply(this, arguments);
   };
   b2GearJointDef.prototype.b2GearJointDef = function () {
      this.__super.b2JointDef.call(this);
      this.type = b2Joint.e_gearJoint;
      this.joint1 = null;
      this.joint2 = null;
      this.ratio = 1.0;
   }
   b2Jacobian.b2Jacobian = function () {
      this.linearA = new b2Vec2();
      this.linearB = new b2Vec2();
   };
   b2Jacobian.prototype.SetZero = function () {
      this.linearA.SetZero();
      this.angularA = 0.0;
      this.linearB.SetZero();
      this.angularB = 0.0;
   }
   b2Jacobian.prototype.Set = function (x1, a1, x2, a2) {
      if (a1 === undefined) a1 = 0;
      if (a2 === undefined) a2 = 0;
      this.linearA.SetV(x1);
      this.angularA = a1;
      this.linearB.SetV(x2);
      this.angularB = a2;
   }
   b2Jacobian.prototype.Compute = function (x1, a1, x2, a2) {
      if (a1 === undefined) a1 = 0;
      if (a2 === undefined) a2 = 0;
      return (this.linearA.x * x1.x + this.linearA.y * x1.y) + this.angularA * a1 + (this.linearB.x * x2.x + this.linearB.y * x2.y) + this.angularB * a2;
   }
   b2Joint.b2Joint = function () {
      this.m_edgeA = new b2JointEdge();
      this.m_edgeB = new b2JointEdge();
      this.m_localCenterA = new b2Vec2();
      this.m_localCenterB = new b2Vec2();
   };
   b2Joint.prototype.GetType = function () {
      return this.m_type;
   }
   b2Joint.prototype.GetAnchorA = function () {
      return null;
   }
   b2Joint.prototype.GetAnchorB = function () {
      return null;
   }
   b2Joint.prototype.GetReactionForce = function (inv_dt) {
      if (inv_dt === undefined) inv_dt = 0;
      return null;
   }
   b2Joint.prototype.GetReactionTorque = function (inv_dt) {
      if (inv_dt === undefined) inv_dt = 0;
      return 0.0;
   }
   b2Joint.prototype.GetBodyA = function () {
      return this.m_bodyA;
   }
   b2Joint.prototype.GetBodyB = function () {
      return this.m_bodyB;
   }
   b2Joint.prototype.GetNext = function () {
      return this.m_next;
   }
   b2Joint.prototype.GetUserData = function () {
      return this.m_userData;
   }
   b2Joint.prototype.SetUserData = function (data) {
      this.m_userData = data;
   }
   b2Joint.prototype.IsActive = function () {
      return this.m_bodyA.IsActive() && this.m_bodyB.IsActive();
   }
   b2Joint.Create = function (def, allocator) {
      var joint = null;
      switch (def.type) {
      case b2Joint.e_distanceJoint:
         {
            joint = new b2DistanceJoint((def instanceof b2DistanceJointDef ? def : null));
         }
         break;
      case b2Joint.e_mouseJoint:
         {
            joint = new b2MouseJoint((def instanceof b2MouseJointDef ? def : null));
         }
         break;
      case b2Joint.e_prismaticJoint:
         {
            joint = new b2PrismaticJoint((def instanceof b2PrismaticJointDef ? def : null));
         }
         break;
      case b2Joint.e_revoluteJoint:
         {
            joint = new b2RevoluteJoint((def instanceof b2RevoluteJointDef ? def : null));
         }
         break;
      case b2Joint.e_pulleyJoint:
         {
            joint = new b2PulleyJoint((def instanceof b2PulleyJointDef ? def : null));
         }
         break;
      case b2Joint.e_gearJoint:
         {
            joint = new b2GearJoint((def instanceof b2GearJointDef ? def : null));
         }
         break;
      case b2Joint.e_lineJoint:
         {
            joint = new b2LineJoint((def instanceof b2LineJointDef ? def : null));
         }
         break;
      case b2Joint.e_weldJoint:
         {
            joint = new b2WeldJoint((def instanceof b2WeldJointDef ? def : null));
         }
         break;
      case b2Joint.e_frictionJoint:
         {
            joint = new b2FrictionJoint((def instanceof b2FrictionJointDef ? def : null));
         }
         break;
      default:
         break;
      }
      return joint;
   }
   b2Joint.Destroy = function (joint, allocator) {}
   b2Joint.prototype.b2Joint = function (def) {
      b2Settings.b2Assert(def.bodyA != def.bodyB);
      this.m_type = def.type;
      this.m_prev = null;
      this.m_next = null;
      this.m_bodyA = def.bodyA;
      this.m_bodyB = def.bodyB;
      this.m_collideConnected = def.collideConnected;
      this.m_islandFlag = false;
      this.m_userData = def.userData;
   }
   b2Joint.prototype.InitVelocityConstraints = function (step) {}
   b2Joint.prototype.SolveVelocityConstraints = function (step) {}
   b2Joint.prototype.FinalizeVelocityConstraints = function () {}
   b2Joint.prototype.SolvePositionConstraints = function (baumgarte) {
      if (baumgarte === undefined) baumgarte = 0;
      return false;
   }
   Box2D.postDefs.push(function () {
      Box2D.Dynamics.Joints.b2Joint.e_unknownJoint = 0;
      Box2D.Dynamics.Joints.b2Joint.e_revoluteJoint = 1;
      Box2D.Dynamics.Joints.b2Joint.e_prismaticJoint = 2;
      Box2D.Dynamics.Joints.b2Joint.e_distanceJoint = 3;
      Box2D.Dynamics.Joints.b2Joint.e_pulleyJoint = 4;
      Box2D.Dynamics.Joints.b2Joint.e_mouseJoint = 5;
      Box2D.Dynamics.Joints.b2Joint.e_gearJoint = 6;
      Box2D.Dynamics.Joints.b2Joint.e_lineJoint = 7;
      Box2D.Dynamics.Joints.b2Joint.e_weldJoint = 8;
      Box2D.Dynamics.Joints.b2Joint.e_frictionJoint = 9;
      Box2D.Dynamics.Joints.b2Joint.e_inactiveLimit = 0;
      Box2D.Dynamics.Joints.b2Joint.e_atLowerLimit = 1;
      Box2D.Dynamics.Joints.b2Joint.e_atUpperLimit = 2;
      Box2D.Dynamics.Joints.b2Joint.e_equalLimits = 3;
   });
   b2JointDef.b2JointDef = function () {};
   b2JointDef.prototype.b2JointDef = function () {
      this.type = b2Joint.e_unknownJoint;
      this.userData = null;
      this.bodyA = null;
      this.bodyB = null;
      this.collideConnected = false;
   }
   b2JointEdge.b2JointEdge = function () {};
   Box2D.inherit(b2LineJoint, Box2D.Dynamics.Joints.b2Joint);
   b2LineJoint.prototype.__super = Box2D.Dynamics.Joints.b2Joint.prototype;
   b2LineJoint.b2LineJoint = function () {
      Box2D.Dynamics.Joints.b2Joint.b2Joint.apply(this, arguments);
      this.m_localAnchor1 = new b2Vec2();
      this.m_localAnchor2 = new b2Vec2();
      this.m_localXAxis1 = new b2Vec2();
      this.m_localYAxis1 = new b2Vec2();
      this.m_axis = new b2Vec2();
      this.m_perp = new b2Vec2();
      this.m_K = new b2Mat22();
      this.m_impulse = new b2Vec2();
   };
   b2LineJoint.prototype.GetAnchorA = function () {
      return this.m_bodyA.GetWorldPoint(this.m_localAnchor1);
   }
   b2LineJoint.prototype.GetAnchorB = function () {
      return this.m_bodyB.GetWorldPoint(this.m_localAnchor2);
   }
   b2LineJoint.prototype.GetReactionForce = function (inv_dt) {
      if (inv_dt === undefined) inv_dt = 0;
      return new b2Vec2(inv_dt * (this.m_impulse.x * this.m_perp.x + (this.m_motorImpulse + this.m_impulse.y) * this.m_axis.x), inv_dt * (this.m_impulse.x * this.m_perp.y + (this.m_motorImpulse + this.m_impulse.y) * this.m_axis.y));
   }
   b2LineJoint.prototype.GetReactionTorque = function (inv_dt) {
      if (inv_dt === undefined) inv_dt = 0;
      return inv_dt * this.m_impulse.y;
   }
   b2LineJoint.prototype.GetJointTranslation = function () {
      var bA = this.m_bodyA;
      var bB = this.m_bodyB;
      var tMat;
      var p1 = bA.GetWorldPoint(this.m_localAnchor1);
      var p2 = bB.GetWorldPoint(this.m_localAnchor2);
      var dX = p2.x - p1.x;
      var dY = p2.y - p1.y;
      var axis = bA.GetWorldVector(this.m_localXAxis1);
      var translation = axis.x * dX + axis.y * dY;
      return translation;
   }
   b2LineJoint.prototype.GetJointSpeed = function () {
      var bA = this.m_bodyA;
      var bB = this.m_bodyB;
      var tMat;
      tMat = bA.m_xf.R;
      var r1X = this.m_localAnchor1.x - bA.m_sweep.localCenter.x;
      var r1Y = this.m_localAnchor1.y - bA.m_sweep.localCenter.y;
      var tX = (tMat.col1.x * r1X + tMat.col2.x * r1Y);
      r1Y = (tMat.col1.y * r1X + tMat.col2.y * r1Y);
      r1X = tX;
      tMat = bB.m_xf.R;
      var r2X = this.m_localAnchor2.x - bB.m_sweep.localCenter.x;
      var r2Y = this.m_localAnchor2.y - bB.m_sweep.localCenter.y;
      tX = (tMat.col1.x * r2X + tMat.col2.x * r2Y);
      r2Y = (tMat.col1.y * r2X + tMat.col2.y * r2Y);
      r2X = tX;
      var p1X = bA.m_sweep.c.x + r1X;
      var p1Y = bA.m_sweep.c.y + r1Y;
      var p2X = bB.m_sweep.c.x + r2X;
      var p2Y = bB.m_sweep.c.y + r2Y;
      var dX = p2X - p1X;
      var dY = p2Y - p1Y;
      var axis = bA.GetWorldVector(this.m_localXAxis1);
      var v1 = bA.m_linearVelocity;
      var v2 = bB.m_linearVelocity;
      var w1 = bA.m_angularVelocity;
      var w2 = bB.m_angularVelocity;
      var speed = (dX * ((-w1 * axis.y)) + dY * (w1 * axis.x)) + (axis.x * (((v2.x + ((-w2 * r2Y))) - v1.x) - ((-w1 * r1Y))) + axis.y * (((v2.y + (w2 * r2X)) - v1.y) - (w1 * r1X)));
      return speed;
   }
   b2LineJoint.prototype.IsLimitEnabled = function () {
      return this.m_enableLimit;
   }
   b2LineJoint.prototype.EnableLimit = function (flag) {
      this.m_bodyA.SetAwake(true);
      this.m_bodyB.SetAwake(true);
      this.m_enableLimit = flag;
   }
   b2LineJoint.prototype.GetLowerLimit = function () {
      return this.m_lowerTranslation;
   }
   b2LineJoint.prototype.GetUpperLimit = function () {
      return this.m_upperTranslation;
   }
   b2LineJoint.prototype.SetLimits = function (lower, upper) {
      if (lower === undefined) lower = 0;
      if (upper === undefined) upper = 0;
      this.m_bodyA.SetAwake(true);
      this.m_bodyB.SetAwake(true);
      this.m_lowerTranslation = lower;
      this.m_upperTranslation = upper;
   }
   b2LineJoint.prototype.IsMotorEnabled = function () {
      return this.m_enableMotor;
   }
   b2LineJoint.prototype.EnableMotor = function (flag) {
      this.m_bodyA.SetAwake(true);
      this.m_bodyB.SetAwake(true);
      this.m_enableMotor = flag;
   }
   b2LineJoint.prototype.SetMotorSpeed = function (speed) {
      if (speed === undefined) speed = 0;
      this.m_bodyA.SetAwake(true);
      this.m_bodyB.SetAwake(true);
      this.m_motorSpeed = speed;
   }
   b2LineJoint.prototype.GetMotorSpeed = function () {
      return this.m_motorSpeed;
   }
   b2LineJoint.prototype.SetMaxMotorForce = function (force) {
      if (force === undefined) force = 0;
      this.m_bodyA.SetAwake(true);
      this.m_bodyB.SetAwake(true);
      this.m_maxMotorForce = force;
   }
   b2LineJoint.prototype.GetMaxMotorForce = function () {
      return this.m_maxMotorForce;
   }
   b2LineJoint.prototype.GetMotorForce = function () {
      return this.m_motorImpulse;
   }
   b2LineJoint.prototype.b2LineJoint = function (def) {
      this.__super.b2Joint.call(this, def);
      var tMat;
      var tX = 0;
      var tY = 0;
      this.m_localAnchor1.SetV(def.localAnchorA);
      this.m_localAnchor2.SetV(def.localAnchorB);
      this.m_localXAxis1.SetV(def.localAxisA);
      this.m_localYAxis1.x = (-this.m_localXAxis1.y);
      this.m_localYAxis1.y = this.m_localXAxis1.x;
      this.m_impulse.SetZero();
      this.m_motorMass = 0.0;
      this.m_motorImpulse = 0.0;
      this.m_lowerTranslation = def.lowerTranslation;
      this.m_upperTranslation = def.upperTranslation;
      this.m_maxMotorForce = def.maxMotorForce;
      this.m_motorSpeed = def.motorSpeed;
      this.m_enableLimit = def.enableLimit;
      this.m_enableMotor = def.enableMotor;
      this.m_limitState = b2Joint.e_inactiveLimit;
      this.m_axis.SetZero();
      this.m_perp.SetZero();
   }
   b2LineJoint.prototype.InitVelocityConstraints = function (step) {
      var bA = this.m_bodyA;
      var bB = this.m_bodyB;
      var tMat;
      var tX = 0;
      this.m_localCenterA.SetV(bA.GetLocalCenter());
      this.m_localCenterB.SetV(bB.GetLocalCenter());
      var xf1 = bA.GetTransform();
      var xf2 = bB.GetTransform();
      tMat = bA.m_xf.R;
      var r1X = this.m_localAnchor1.x - this.m_localCenterA.x;
      var r1Y = this.m_localAnchor1.y - this.m_localCenterA.y;
      tX = (tMat.col1.x * r1X + tMat.col2.x * r1Y);
      r1Y = (tMat.col1.y * r1X + tMat.col2.y * r1Y);
      r1X = tX;
      tMat = bB.m_xf.R;
      var r2X = this.m_localAnchor2.x - this.m_localCenterB.x;
      var r2Y = this.m_localAnchor2.y - this.m_localCenterB.y;
      tX = (tMat.col1.x * r2X + tMat.col2.x * r2Y);
      r2Y = (tMat.col1.y * r2X + tMat.col2.y * r2Y);
      r2X = tX;
      var dX = bB.m_sweep.c.x + r2X - bA.m_sweep.c.x - r1X;
      var dY = bB.m_sweep.c.y + r2Y - bA.m_sweep.c.y - r1Y;
      this.m_invMassA = bA.m_invMass;
      this.m_invMassB = bB.m_invMass;
      this.m_invIA = bA.m_invI;
      this.m_invIB = bB.m_invI; {
         this.m_axis.SetV(b2Math.MulMV(xf1.R, this.m_localXAxis1));
         this.m_a1 = (dX + r1X) * this.m_axis.y - (dY + r1Y) * this.m_axis.x;
         this.m_a2 = r2X * this.m_axis.y - r2Y * this.m_axis.x;
         this.m_motorMass = this.m_invMassA + this.m_invMassB + this.m_invIA * this.m_a1 * this.m_a1 + this.m_invIB * this.m_a2 * this.m_a2;
         this.m_motorMass = this.m_motorMass > Number.MIN_VALUE ? 1.0 / this.m_motorMass : 0.0;
      } {
         this.m_perp.SetV(b2Math.MulMV(xf1.R, this.m_localYAxis1));
         this.m_s1 = (dX + r1X) * this.m_perp.y - (dY + r1Y) * this.m_perp.x;
         this.m_s2 = r2X * this.m_perp.y - r2Y * this.m_perp.x;
         var m1 = this.m_invMassA;
         var m2 = this.m_invMassB;
         var i1 = this.m_invIA;
         var i2 = this.m_invIB;
         this.m_K.col1.x = m1 + m2 + i1 * this.m_s1 * this.m_s1 + i2 * this.m_s2 * this.m_s2;
         this.m_K.col1.y = i1 * this.m_s1 * this.m_a1 + i2 * this.m_s2 * this.m_a2;
         this.m_K.col2.x = this.m_K.col1.y;
         this.m_K.col2.y = m1 + m2 + i1 * this.m_a1 * this.m_a1 + i2 * this.m_a2 * this.m_a2;
      }
      if (this.m_enableLimit) {
         var jointTransition = this.m_axis.x * dX + this.m_axis.y * dY;
         if (b2Math.Abs(this.m_upperTranslation - this.m_lowerTranslation) < 2.0 * b2Settings.b2_linearSlop) {
            this.m_limitState = b2Joint.e_equalLimits;
         }
         else if (jointTransition <= this.m_lowerTranslation) {
            if (this.m_limitState != b2Joint.e_atLowerLimit) {
               this.m_limitState = b2Joint.e_atLowerLimit;
               this.m_impulse.y = 0.0;
            }
         }
         else if (jointTransition >= this.m_upperTranslation) {
            if (this.m_limitState != b2Joint.e_atUpperLimit) {
               this.m_limitState = b2Joint.e_atUpperLimit;
               this.m_impulse.y = 0.0;
            }
         }
         else {
            this.m_limitState = b2Joint.e_inactiveLimit;
            this.m_impulse.y = 0.0;
         }
      }
      else {
         this.m_limitState = b2Joint.e_inactiveLimit;
      }
      if (this.m_enableMotor == false) {
         this.m_motorImpulse = 0.0;
      }
      if (step.warmStarting) {
         this.m_impulse.x *= step.dtRatio;
         this.m_impulse.y *= step.dtRatio;
         this.m_motorImpulse *= step.dtRatio;
         var PX = this.m_impulse.x * this.m_perp.x + (this.m_motorImpulse + this.m_impulse.y) * this.m_axis.x;
         var PY = this.m_impulse.x * this.m_perp.y + (this.m_motorImpulse + this.m_impulse.y) * this.m_axis.y;
         var L1 = this.m_impulse.x * this.m_s1 + (this.m_motorImpulse + this.m_impulse.y) * this.m_a1;
         var L2 = this.m_impulse.x * this.m_s2 + (this.m_motorImpulse + this.m_impulse.y) * this.m_a2;
         bA.m_linearVelocity.x -= this.m_invMassA * PX;
         bA.m_linearVelocity.y -= this.m_invMassA * PY;
         bA.m_angularVelocity -= this.m_invIA * L1;
         bB.m_linearVelocity.x += this.m_invMassB * PX;
         bB.m_linearVelocity.y += this.m_invMassB * PY;
         bB.m_angularVelocity += this.m_invIB * L2;
      }
      else {
         this.m_impulse.SetZero();
         this.m_motorImpulse = 0.0;
      }
   }
   b2LineJoint.prototype.SolveVelocityConstraints = function (step) {
      var bA = this.m_bodyA;
      var bB = this.m_bodyB;
      var v1 = bA.m_linearVelocity;
      var w1 = bA.m_angularVelocity;
      var v2 = bB.m_linearVelocity;
      var w2 = bB.m_angularVelocity;
      var PX = 0;
      var PY = 0;
      var L1 = 0;
      var L2 = 0;
      if (this.m_enableMotor && this.m_limitState != b2Joint.e_equalLimits) {
         var Cdot = this.m_axis.x * (v2.x - v1.x) + this.m_axis.y * (v2.y - v1.y) + this.m_a2 * w2 - this.m_a1 * w1;
         var impulse = this.m_motorMass * (this.m_motorSpeed - Cdot);
         var oldImpulse = this.m_motorImpulse;
         var maxImpulse = step.dt * this.m_maxMotorForce;
         this.m_motorImpulse = b2Math.Clamp(this.m_motorImpulse + impulse, (-maxImpulse), maxImpulse);
         impulse = this.m_motorImpulse - oldImpulse;
         PX = impulse * this.m_axis.x;
         PY = impulse * this.m_axis.y;
         L1 = impulse * this.m_a1;
         L2 = impulse * this.m_a2;
         v1.x -= this.m_invMassA * PX;
         v1.y -= this.m_invMassA * PY;
         w1 -= this.m_invIA * L1;
         v2.x += this.m_invMassB * PX;
         v2.y += this.m_invMassB * PY;
         w2 += this.m_invIB * L2;
      }
      var Cdot1 = this.m_perp.x * (v2.x - v1.x) + this.m_perp.y * (v2.y - v1.y) + this.m_s2 * w2 - this.m_s1 * w1;
      if (this.m_enableLimit && this.m_limitState != b2Joint.e_inactiveLimit) {
         var Cdot2 = this.m_axis.x * (v2.x - v1.x) + this.m_axis.y * (v2.y - v1.y) + this.m_a2 * w2 - this.m_a1 * w1;
         var f1 = this.m_impulse.Copy();
         var df = this.m_K.Solve(new b2Vec2(), (-Cdot1), (-Cdot2));
         this.m_impulse.Add(df);
         if (this.m_limitState == b2Joint.e_atLowerLimit) {
            this.m_impulse.y = b2Math.Max(this.m_impulse.y, 0.0);
         }
         else if (this.m_limitState == b2Joint.e_atUpperLimit) {
            this.m_impulse.y = b2Math.Min(this.m_impulse.y, 0.0);
         }
         var b = (-Cdot1) - (this.m_impulse.y - f1.y) * this.m_K.col2.x;
         var f2r = 0;
         if (this.m_K.col1.x != 0.0) {
            f2r = b / this.m_K.col1.x + f1.x;
         }
         else {
            f2r = f1.x;
         }
         this.m_impulse.x = f2r;
         df.x = this.m_impulse.x - f1.x;
         df.y = this.m_impulse.y - f1.y;
         PX = df.x * this.m_perp.x + df.y * this.m_axis.x;
         PY = df.x * this.m_perp.y + df.y * this.m_axis.y;
         L1 = df.x * this.m_s1 + df.y * this.m_a1;
         L2 = df.x * this.m_s2 + df.y * this.m_a2;
         v1.x -= this.m_invMassA * PX;
         v1.y -= this.m_invMassA * PY;
         w1 -= this.m_invIA * L1;
         v2.x += this.m_invMassB * PX;
         v2.y += this.m_invMassB * PY;
         w2 += this.m_invIB * L2;
      }
      else {
         var df2 = 0;
         if (this.m_K.col1.x != 0.0) {
            df2 = ((-Cdot1)) / this.m_K.col1.x;
         }
         else {
            df2 = 0.0;
         }
         this.m_impulse.x += df2;
         PX = df2 * this.m_perp.x;
         PY = df2 * this.m_perp.y;
         L1 = df2 * this.m_s1;
         L2 = df2 * this.m_s2;
         v1.x -= this.m_invMassA * PX;
         v1.y -= this.m_invMassA * PY;
         w1 -= this.m_invIA * L1;
         v2.x += this.m_invMassB * PX;
         v2.y += this.m_invMassB * PY;
         w2 += this.m_invIB * L2;
      }
      bA.m_linearVelocity.SetV(v1);
      bA.m_angularVelocity = w1;
      bB.m_linearVelocity.SetV(v2);
      bB.m_angularVelocity = w2;
   }
   b2LineJoint.prototype.SolvePositionConstraints = function (baumgarte) {
      if (baumgarte === undefined) baumgarte = 0;
      var limitC = 0;
      var oldLimitImpulse = 0;
      var bA = this.m_bodyA;
      var bB = this.m_bodyB;
      var c1 = bA.m_sweep.c;
      var a1 = bA.m_sweep.a;
      var c2 = bB.m_sweep.c;
      var a2 = bB.m_sweep.a;
      var tMat;
      var tX = 0;
      var m1 = 0;
      var m2 = 0;
      var i1 = 0;
      var i2 = 0;
      var linearError = 0.0;
      var angularError = 0.0;
      var active = false;
      var C2 = 0.0;
      var R1 = b2Mat22.FromAngle(a1);
      var R2 = b2Mat22.FromAngle(a2);
      tMat = R1;
      var r1X = this.m_localAnchor1.x - this.m_localCenterA.x;
      var r1Y = this.m_localAnchor1.y - this.m_localCenterA.y;
      tX = (tMat.col1.x * r1X + tMat.col2.x * r1Y);
      r1Y = (tMat.col1.y * r1X + tMat.col2.y * r1Y);
      r1X = tX;
      tMat = R2;
      var r2X = this.m_localAnchor2.x - this.m_localCenterB.x;
      var r2Y = this.m_localAnchor2.y - this.m_localCenterB.y;
      tX = (tMat.col1.x * r2X + tMat.col2.x * r2Y);
      r2Y = (tMat.col1.y * r2X + tMat.col2.y * r2Y);
      r2X = tX;
      var dX = c2.x + r2X - c1.x - r1X;
      var dY = c2.y + r2Y - c1.y - r1Y;
      if (this.m_enableLimit) {
         this.m_axis = b2Math.MulMV(R1, this.m_localXAxis1);
         this.m_a1 = (dX + r1X) * this.m_axis.y - (dY + r1Y) * this.m_axis.x;
         this.m_a2 = r2X * this.m_axis.y - r2Y * this.m_axis.x;
         var translation = this.m_axis.x * dX + this.m_axis.y * dY;
         if (b2Math.Abs(this.m_upperTranslation - this.m_lowerTranslation) < 2.0 * b2Settings.b2_linearSlop) {
            C2 = b2Math.Clamp(translation, (-b2Settings.b2_maxLinearCorrection), b2Settings.b2_maxLinearCorrection);
            linearError = b2Math.Abs(translation);
            active = true;
         }
         else if (translation <= this.m_lowerTranslation) {
            C2 = b2Math.Clamp(translation - this.m_lowerTranslation + b2Settings.b2_linearSlop, (-b2Settings.b2_maxLinearCorrection), 0.0);
            linearError = this.m_lowerTranslation - translation;
            active = true;
         }
         else if (translation >= this.m_upperTranslation) {
            C2 = b2Math.Clamp(translation - this.m_upperTranslation + b2Settings.b2_linearSlop, 0.0, b2Settings.b2_maxLinearCorrection);
            linearError = translation - this.m_upperTranslation;
            active = true;
         }
      }
      this.m_perp = b2Math.MulMV(R1, this.m_localYAxis1);
      this.m_s1 = (dX + r1X) * this.m_perp.y - (dY + r1Y) * this.m_perp.x;
      this.m_s2 = r2X * this.m_perp.y - r2Y * this.m_perp.x;
      var impulse = new b2Vec2();
      var C1 = this.m_perp.x * dX + this.m_perp.y * dY;
      linearError = b2Math.Max(linearError, b2Math.Abs(C1));
      angularError = 0.0;
      if (active) {
         m1 = this.m_invMassA;
         m2 = this.m_invMassB;
         i1 = this.m_invIA;
         i2 = this.m_invIB;
         this.m_K.col1.x = m1 + m2 + i1 * this.m_s1 * this.m_s1 + i2 * this.m_s2 * this.m_s2;
         this.m_K.col1.y = i1 * this.m_s1 * this.m_a1 + i2 * this.m_s2 * this.m_a2;
         this.m_K.col2.x = this.m_K.col1.y;
         this.m_K.col2.y = m1 + m2 + i1 * this.m_a1 * this.m_a1 + i2 * this.m_a2 * this.m_a2;
         this.m_K.Solve(impulse, (-C1), (-C2));
      }
      else {
         m1 = this.m_invMassA;
         m2 = this.m_invMassB;
         i1 = this.m_invIA;
         i2 = this.m_invIB;
         var k11 = m1 + m2 + i1 * this.m_s1 * this.m_s1 + i2 * this.m_s2 * this.m_s2;
         var impulse1 = 0;
         if (k11 != 0.0) {
            impulse1 = ((-C1)) / k11;
         }
         else {
            impulse1 = 0.0;
         }
         impulse.x = impulse1;
         impulse.y = 0.0;
      }
      var PX = impulse.x * this.m_perp.x + impulse.y * this.m_axis.x;
      var PY = impulse.x * this.m_perp.y + impulse.y * this.m_axis.y;
      var L1 = impulse.x * this.m_s1 + impulse.y * this.m_a1;
      var L2 = impulse.x * this.m_s2 + impulse.y * this.m_a2;
      c1.x -= this.m_invMassA * PX;
      c1.y -= this.m_invMassA * PY;
      a1 -= this.m_invIA * L1;
      c2.x += this.m_invMassB * PX;
      c2.y += this.m_invMassB * PY;
      a2 += this.m_invIB * L2;
      bA.m_sweep.a = a1;
      bB.m_sweep.a = a2;
      bA.SynchronizeTransform();
      bB.SynchronizeTransform();
      return linearError <= b2Settings.b2_linearSlop && angularError <= b2Settings.b2_angularSlop;
   }
   Box2D.inherit(b2LineJointDef, Box2D.Dynamics.Joints.b2JointDef);
   b2LineJointDef.prototype.__super = Box2D.Dynamics.Joints.b2JointDef.prototype;
   b2LineJointDef.b2LineJointDef = function () {
      Box2D.Dynamics.Joints.b2JointDef.b2JointDef.apply(this, arguments);
      this.localAnchorA = new b2Vec2();
      this.localAnchorB = new b2Vec2();
      this.localAxisA = new b2Vec2();
   };
   b2LineJointDef.prototype.b2LineJointDef = function () {
      this.__super.b2JointDef.call(this);
      this.type = b2Joint.e_lineJoint;
      this.localAxisA.Set(1.0, 0.0);
      this.enableLimit = false;
      this.lowerTranslation = 0.0;
      this.upperTranslation = 0.0;
      this.enableMotor = false;
      this.maxMotorForce = 0.0;
      this.motorSpeed = 0.0;
   }
   b2LineJointDef.prototype.Initialize = function (bA, bB, anchor, axis) {
      this.bodyA = bA;
      this.bodyB = bB;
      this.localAnchorA = this.bodyA.GetLocalPoint(anchor);
      this.localAnchorB = this.bodyB.GetLocalPoint(anchor);
      this.localAxisA = this.bodyA.GetLocalVector(axis);
   }
   Box2D.inherit(b2MouseJoint, Box2D.Dynamics.Joints.b2Joint);
   b2MouseJoint.prototype.__super = Box2D.Dynamics.Joints.b2Joint.prototype;
   b2MouseJoint.b2MouseJoint = function () {
      Box2D.Dynamics.Joints.b2Joint.b2Joint.apply(this, arguments);
      this.K = new b2Mat22();
      this.K1 = new b2Mat22();
      this.K2 = new b2Mat22();
      this.m_localAnchor = new b2Vec2();
      this.m_target = new b2Vec2();
      this.m_impulse = new b2Vec2();
      this.m_mass = new b2Mat22();
      this.m_C = new b2Vec2();
   };
   b2MouseJoint.prototype.GetAnchorA = function () {
      return this.m_target;
   }
   b2MouseJoint.prototype.GetAnchorB = function () {
      return this.m_bodyB.GetWorldPoint(this.m_localAnchor);
   }
   b2MouseJoint.prototype.GetReactionForce = function (inv_dt) {
      if (inv_dt === undefined) inv_dt = 0;
      return new b2Vec2(inv_dt * this.m_impulse.x, inv_dt * this.m_impulse.y);
   }
   b2MouseJoint.prototype.GetReactionTorque = function (inv_dt) {
      if (inv_dt === undefined) inv_dt = 0;
      return 0.0;
   }
   b2MouseJoint.prototype.GetTarget = function () {
      return this.m_target;
   }
   b2MouseJoint.prototype.SetTarget = function (target) {
      if (this.m_bodyB.IsAwake() == false) {
         this.m_bodyB.SetAwake(true);
      }
      this.m_target = target;
   }
   b2MouseJoint.prototype.GetMaxForce = function () {
      return this.m_maxForce;
   }
   b2MouseJoint.prototype.SetMaxForce = function (maxForce) {
      if (maxForce === undefined) maxForce = 0;
      this.m_maxForce = maxForce;
   }
   b2MouseJoint.prototype.GetFrequency = function () {
      return this.m_frequencyHz;
   }
   b2MouseJoint.prototype.SetFrequency = function (hz) {
      if (hz === undefined) hz = 0;
      this.m_frequencyHz = hz;
   }
   b2MouseJoint.prototype.GetDampingRatio = function () {
      return this.m_dampingRatio;
   }
   b2MouseJoint.prototype.SetDampingRatio = function (ratio) {
      if (ratio === undefined) ratio = 0;
      this.m_dampingRatio = ratio;
   }
   b2MouseJoint.prototype.b2MouseJoint = function (def) {
      this.__super.b2Joint.call(this, def);
      this.m_target.SetV(def.target);
      var tX = this.m_target.x - this.m_bodyB.m_xf.position.x;
      var tY = this.m_target.y - this.m_bodyB.m_xf.position.y;
      var tMat = this.m_bodyB.m_xf.R;
      this.m_localAnchor.x = (tX * tMat.col1.x + tY * tMat.col1.y);
      this.m_localAnchor.y = (tX * tMat.col2.x + tY * tMat.col2.y);
      this.m_maxForce = def.maxForce;
      this.m_impulse.SetZero();
      this.m_frequencyHz = def.frequencyHz;
      this.m_dampingRatio = def.dampingRatio;
      this.m_beta = 0.0;
      this.m_gamma = 0.0;
   }
   b2MouseJoint.prototype.InitVelocityConstraints = function (step) {
      var b = this.m_bodyB;
      var mass = b.GetMass();
      var omega = 2.0 * Math.PI * this.m_frequencyHz;
      var d = 2.0 * mass * this.m_dampingRatio * omega;
      var k = mass * omega * omega;
      this.m_gamma = step.dt * (d + step.dt * k);
      this.m_gamma = this.m_gamma != 0 ? 1 / this.m_gamma : 0.0;
      this.m_beta = step.dt * k * this.m_gamma;
      var tMat;tMat = b.m_xf.R;
      var rX = this.m_localAnchor.x - b.m_sweep.localCenter.x;
      var rY = this.m_localAnchor.y - b.m_sweep.localCenter.y;
      var tX = (tMat.col1.x * rX + tMat.col2.x * rY);rY = (tMat.col1.y * rX + tMat.col2.y * rY);
      rX = tX;
      var invMass = b.m_invMass;
      var invI = b.m_invI;this.K1.col1.x = invMass;
      this.K1.col2.x = 0.0;
      this.K1.col1.y = 0.0;
      this.K1.col2.y = invMass;
      this.K2.col1.x = invI * rY * rY;
      this.K2.col2.x = (-invI * rX * rY);
      this.K2.col1.y = (-invI * rX * rY);
      this.K2.col2.y = invI * rX * rX;
      this.K.SetM(this.K1);
      this.K.AddM(this.K2);
      this.K.col1.x += this.m_gamma;
      this.K.col2.y += this.m_gamma;
      this.K.GetInverse(this.m_mass);
      this.m_C.x = b.m_sweep.c.x + rX - this.m_target.x;
      this.m_C.y = b.m_sweep.c.y + rY - this.m_target.y;
      b.m_angularVelocity *= 0.98;
      this.m_impulse.x *= step.dtRatio;
      this.m_impulse.y *= step.dtRatio;
      b.m_linearVelocity.x += invMass * this.m_impulse.x;
      b.m_linearVelocity.y += invMass * this.m_impulse.y;
      b.m_angularVelocity += invI * (rX * this.m_impulse.y - rY * this.m_impulse.x);
   }
   b2MouseJoint.prototype.SolveVelocityConstraints = function (step) {
      var b = this.m_bodyB;
      var tMat;
      var tX = 0;
      var tY = 0;
      tMat = b.m_xf.R;
      var rX = this.m_localAnchor.x - b.m_sweep.localCenter.x;
      var rY = this.m_localAnchor.y - b.m_sweep.localCenter.y;
      tX = (tMat.col1.x * rX + tMat.col2.x * rY);
      rY = (tMat.col1.y * rX + tMat.col2.y * rY);
      rX = tX;
      var CdotX = b.m_linearVelocity.x + ((-b.m_angularVelocity * rY));
      var CdotY = b.m_linearVelocity.y + (b.m_angularVelocity * rX);
      tMat = this.m_mass;
      tX = CdotX + this.m_beta * this.m_C.x + this.m_gamma * this.m_impulse.x;
      tY = CdotY + this.m_beta * this.m_C.y + this.m_gamma * this.m_impulse.y;
      var impulseX = (-(tMat.col1.x * tX + tMat.col2.x * tY));
      var impulseY = (-(tMat.col1.y * tX + tMat.col2.y * tY));
      var oldImpulseX = this.m_impulse.x;
      var oldImpulseY = this.m_impulse.y;
      this.m_impulse.x += impulseX;
      this.m_impulse.y += impulseY;
      var maxImpulse = step.dt * this.m_maxForce;
      if (this.m_impulse.LengthSquared() > maxImpulse * maxImpulse) {
         this.m_impulse.Multiply(maxImpulse / this.m_impulse.Length());
      }
      impulseX = this.m_impulse.x - oldImpulseX;
      impulseY = this.m_impulse.y - oldImpulseY;
      b.m_linearVelocity.x += b.m_invMass * impulseX;
      b.m_linearVelocity.y += b.m_invMass * impulseY;
      b.m_angularVelocity += b.m_invI * (rX * impulseY - rY * impulseX);
   }
   b2MouseJoint.prototype.SolvePositionConstraints = function (baumgarte) {
      if (baumgarte === undefined) baumgarte = 0;
      return true;
   }
   Box2D.inherit(b2MouseJointDef, Box2D.Dynamics.Joints.b2JointDef);
   b2MouseJointDef.prototype.__super = Box2D.Dynamics.Joints.b2JointDef.prototype;
   b2MouseJointDef.b2MouseJointDef = function () {
      Box2D.Dynamics.Joints.b2JointDef.b2JointDef.apply(this, arguments);
      this.target = new b2Vec2();
   };
   b2MouseJointDef.prototype.b2MouseJointDef = function () {
      this.__super.b2JointDef.call(this);
      this.type = b2Joint.e_mouseJoint;
      this.maxForce = 0.0;
      this.frequencyHz = 5.0;
      this.dampingRatio = 0.7;
   }
   Box2D.inherit(b2PrismaticJoint, Box2D.Dynamics.Joints.b2Joint);
   b2PrismaticJoint.prototype.__super = Box2D.Dynamics.Joints.b2Joint.prototype;
   b2PrismaticJoint.b2PrismaticJoint = function () {
      Box2D.Dynamics.Joints.b2Joint.b2Joint.apply(this, arguments);
      this.m_localAnchor1 = new b2Vec2();
      this.m_localAnchor2 = new b2Vec2();
      this.m_localXAxis1 = new b2Vec2();
      this.m_localYAxis1 = new b2Vec2();
      this.m_axis = new b2Vec2();
      this.m_perp = new b2Vec2();
      this.m_K = new b2Mat33();
      this.m_impulse = new b2Vec3();
   };
   b2PrismaticJoint.prototype.GetAnchorA = function () {
      return this.m_bodyA.GetWorldPoint(this.m_localAnchor1);
   }
   b2PrismaticJoint.prototype.GetAnchorB = function () {
      return this.m_bodyB.GetWorldPoint(this.m_localAnchor2);
   }
   b2PrismaticJoint.prototype.GetReactionForce = function (inv_dt) {
      if (inv_dt === undefined) inv_dt = 0;
      return new b2Vec2(inv_dt * (this.m_impulse.x * this.m_perp.x + (this.m_motorImpulse + this.m_impulse.z) * this.m_axis.x), inv_dt * (this.m_impulse.x * this.m_perp.y + (this.m_motorImpulse + this.m_impulse.z) * this.m_axis.y));
   }
   b2PrismaticJoint.prototype.GetReactionTorque = function (inv_dt) {
      if (inv_dt === undefined) inv_dt = 0;
      return inv_dt * this.m_impulse.y;
   }
   b2PrismaticJoint.prototype.GetJointTranslation = function () {
      var bA = this.m_bodyA;
      var bB = this.m_bodyB;
      var tMat;
      var p1 = bA.GetWorldPoint(this.m_localAnchor1);
      var p2 = bB.GetWorldPoint(this.m_localAnchor2);
      var dX = p2.x - p1.x;
      var dY = p2.y - p1.y;
      var axis = bA.GetWorldVector(this.m_localXAxis1);
      var translation = axis.x * dX + axis.y * dY;
      return translation;
   }
   b2PrismaticJoint.prototype.GetJointSpeed = function () {
      var bA = this.m_bodyA;
      var bB = this.m_bodyB;
      var tMat;
      tMat = bA.m_xf.R;
      var r1X = this.m_localAnchor1.x - bA.m_sweep.localCenter.x;
      var r1Y = this.m_localAnchor1.y - bA.m_sweep.localCenter.y;
      var tX = (tMat.col1.x * r1X + tMat.col2.x * r1Y);
      r1Y = (tMat.col1.y * r1X + tMat.col2.y * r1Y);
      r1X = tX;
      tMat = bB.m_xf.R;
      var r2X = this.m_localAnchor2.x - bB.m_sweep.localCenter.x;
      var r2Y = this.m_localAnchor2.y - bB.m_sweep.localCenter.y;
      tX = (tMat.col1.x * r2X + tMat.col2.x * r2Y);
      r2Y = (tMat.col1.y * r2X + tMat.col2.y * r2Y);
      r2X = tX;
      var p1X = bA.m_sweep.c.x + r1X;
      var p1Y = bA.m_sweep.c.y + r1Y;
      var p2X = bB.m_sweep.c.x + r2X;
      var p2Y = bB.m_sweep.c.y + r2Y;
      var dX = p2X - p1X;
      var dY = p2Y - p1Y;
      var axis = bA.GetWorldVector(this.m_localXAxis1);
      var v1 = bA.m_linearVelocity;
      var v2 = bB.m_linearVelocity;
      var w1 = bA.m_angularVelocity;
      var w2 = bB.m_angularVelocity;
      var speed = (dX * ((-w1 * axis.y)) + dY * (w1 * axis.x)) + (axis.x * (((v2.x + ((-w2 * r2Y))) - v1.x) - ((-w1 * r1Y))) + axis.y * (((v2.y + (w2 * r2X)) - v1.y) - (w1 * r1X)));
      return speed;
   }
   b2PrismaticJoint.prototype.IsLimitEnabled = function () {
      return this.m_enableLimit;
   }
   b2PrismaticJoint.prototype.EnableLimit = function (flag) {
      this.m_bodyA.SetAwake(true);
      this.m_bodyB.SetAwake(true);
      this.m_enableLimit = flag;
   }
   b2PrismaticJoint.prototype.GetLowerLimit = function () {
      return this.m_lowerTranslation;
   }
   b2PrismaticJoint.prototype.GetUpperLimit = function () {
      return this.m_upperTranslation;
   }
   b2PrismaticJoint.prototype.SetLimits = function (lower, upper) {
      if (lower === undefined) lower = 0;
      if (upper === undefined) upper = 0;
      this.m_bodyA.SetAwake(true);
      this.m_bodyB.SetAwake(true);
      this.m_lowerTranslation = lower;
      this.m_upperTranslation = upper;
   }
   b2PrismaticJoint.prototype.IsMotorEnabled = function () {
      return this.m_enableMotor;
   }
   b2PrismaticJoint.prototype.EnableMotor = function (flag) {
      this.m_bodyA.SetAwake(true);
      this.m_bodyB.SetAwake(true);
      this.m_enableMotor = flag;
   }
   b2PrismaticJoint.prototype.SetMotorSpeed = function (speed) {
      if (speed === undefined) speed = 0;
      this.m_bodyA.SetAwake(true);
      this.m_bodyB.SetAwake(true);
      this.m_motorSpeed = speed;
   }
   b2PrismaticJoint.prototype.GetMotorSpeed = function () {
      return this.m_motorSpeed;
   }
   b2PrismaticJoint.prototype.SetMaxMotorForce = function (force) {
      if (force === undefined) force = 0;
      this.m_bodyA.SetAwake(true);
      this.m_bodyB.SetAwake(true);
      this.m_maxMotorForce = force;
   }
   b2PrismaticJoint.prototype.GetMotorForce = function () {
      return this.m_motorImpulse;
   }
   b2PrismaticJoint.prototype.b2PrismaticJoint = function (def) {
      this.__super.b2Joint.call(this, def);
      var tMat;
      var tX = 0;
      var tY = 0;
      this.m_localAnchor1.SetV(def.localAnchorA);
      this.m_localAnchor2.SetV(def.localAnchorB);
      this.m_localXAxis1.SetV(def.localAxisA);
      this.m_localYAxis1.x = (-this.m_localXAxis1.y);
      this.m_localYAxis1.y = this.m_localXAxis1.x;
      this.m_refAngle = def.referenceAngle;
      this.m_impulse.SetZero();
      this.m_motorMass = 0.0;
      this.m_motorImpulse = 0.0;
      this.m_lowerTranslation = def.lowerTranslation;
      this.m_upperTranslation = def.upperTranslation;
      this.m_maxMotorForce = def.maxMotorForce;
      this.m_motorSpeed = def.motorSpeed;
      this.m_enableLimit = def.enableLimit;
      this.m_enableMotor = def.enableMotor;
      this.m_limitState = b2Joint.e_inactiveLimit;
      this.m_axis.SetZero();
      this.m_perp.SetZero();
   }
   b2PrismaticJoint.prototype.InitVelocityConstraints = function (step) {
      var bA = this.m_bodyA;
      var bB = this.m_bodyB;
      var tMat;
      var tX = 0;
      this.m_localCenterA.SetV(bA.GetLocalCenter());
      this.m_localCenterB.SetV(bB.GetLocalCenter());
      var xf1 = bA.GetTransform();
      var xf2 = bB.GetTransform();
      tMat = bA.m_xf.R;
      var r1X = this.m_localAnchor1.x - this.m_localCenterA.x;
      var r1Y = this.m_localAnchor1.y - this.m_localCenterA.y;
      tX = (tMat.col1.x * r1X + tMat.col2.x * r1Y);
      r1Y = (tMat.col1.y * r1X + tMat.col2.y * r1Y);
      r1X = tX;
      tMat = bB.m_xf.R;
      var r2X = this.m_localAnchor2.x - this.m_localCenterB.x;
      var r2Y = this.m_localAnchor2.y - this.m_localCenterB.y;
      tX = (tMat.col1.x * r2X + tMat.col2.x * r2Y);
      r2Y = (tMat.col1.y * r2X + tMat.col2.y * r2Y);
      r2X = tX;
      var dX = bB.m_sweep.c.x + r2X - bA.m_sweep.c.x - r1X;
      var dY = bB.m_sweep.c.y + r2Y - bA.m_sweep.c.y - r1Y;
      this.m_invMassA = bA.m_invMass;
      this.m_invMassB = bB.m_invMass;
      this.m_invIA = bA.m_invI;
      this.m_invIB = bB.m_invI; {
         this.m_axis.SetV(b2Math.MulMV(xf1.R, this.m_localXAxis1));
         this.m_a1 = (dX + r1X) * this.m_axis.y - (dY + r1Y) * this.m_axis.x;
         this.m_a2 = r2X * this.m_axis.y - r2Y * this.m_axis.x;
         this.m_motorMass = this.m_invMassA + this.m_invMassB + this.m_invIA * this.m_a1 * this.m_a1 + this.m_invIB * this.m_a2 * this.m_a2;
         if (this.m_motorMass > Number.MIN_VALUE) this.m_motorMass = 1.0 / this.m_motorMass;
      } {
         this.m_perp.SetV(b2Math.MulMV(xf1.R, this.m_localYAxis1));
         this.m_s1 = (dX + r1X) * this.m_perp.y - (dY + r1Y) * this.m_perp.x;
         this.m_s2 = r2X * this.m_perp.y - r2Y * this.m_perp.x;
         var m1 = this.m_invMassA;
         var m2 = this.m_invMassB;
         var i1 = this.m_invIA;
         var i2 = this.m_invIB;
         this.m_K.col1.x = m1 + m2 + i1 * this.m_s1 * this.m_s1 + i2 * this.m_s2 * this.m_s2;
         this.m_K.col1.y = i1 * this.m_s1 + i2 * this.m_s2;
         this.m_K.col1.z = i1 * this.m_s1 * this.m_a1 + i2 * this.m_s2 * this.m_a2;
         this.m_K.col2.x = this.m_K.col1.y;
         this.m_K.col2.y = i1 + i2;
         this.m_K.col2.z = i1 * this.m_a1 + i2 * this.m_a2;
         this.m_K.col3.x = this.m_K.col1.z;
         this.m_K.col3.y = this.m_K.col2.z;
         this.m_K.col3.z = m1 + m2 + i1 * this.m_a1 * this.m_a1 + i2 * this.m_a2 * this.m_a2;
      }
      if (this.m_enableLimit) {
         var jointTransition = this.m_axis.x * dX + this.m_axis.y * dY;
         if (b2Math.Abs(this.m_upperTranslation - this.m_lowerTranslation) < 2.0 * b2Settings.b2_linearSlop) {
            this.m_limitState = b2Joint.e_equalLimits;
         }
         else if (jointTransition <= this.m_lowerTranslation) {
            if (this.m_limitState != b2Joint.e_atLowerLimit) {
               this.m_limitState = b2Joint.e_atLowerLimit;
               this.m_impulse.z = 0.0;
            }
         }
         else if (jointTransition >= this.m_upperTranslation) {
            if (this.m_limitState != b2Joint.e_atUpperLimit) {
               this.m_limitState = b2Joint.e_atUpperLimit;
               this.m_impulse.z = 0.0;
            }
         }
         else {
            this.m_limitState = b2Joint.e_inactiveLimit;
            this.m_impulse.z = 0.0;
         }
      }
      else {
         this.m_limitState = b2Joint.e_inactiveLimit;
      }
      if (this.m_enableMotor == false) {
         this.m_motorImpulse = 0.0;
      }
      if (step.warmStarting) {
         this.m_impulse.x *= step.dtRatio;
         this.m_impulse.y *= step.dtRatio;
         this.m_motorImpulse *= step.dtRatio;
         var PX = this.m_impulse.x * this.m_perp.x + (this.m_motorImpulse + this.m_impulse.z) * this.m_axis.x;
         var PY = this.m_impulse.x * this.m_perp.y + (this.m_motorImpulse + this.m_impulse.z) * this.m_axis.y;
         var L1 = this.m_impulse.x * this.m_s1 + this.m_impulse.y + (this.m_motorImpulse + this.m_impulse.z) * this.m_a1;
         var L2 = this.m_impulse.x * this.m_s2 + this.m_impulse.y + (this.m_motorImpulse + this.m_impulse.z) * this.m_a2;
         bA.m_linearVelocity.x -= this.m_invMassA * PX;
         bA.m_linearVelocity.y -= this.m_invMassA * PY;
         bA.m_angularVelocity -= this.m_invIA * L1;
         bB.m_linearVelocity.x += this.m_invMassB * PX;
         bB.m_linearVelocity.y += this.m_invMassB * PY;
         bB.m_angularVelocity += this.m_invIB * L2;
      }
      else {
         this.m_impulse.SetZero();
         this.m_motorImpulse = 0.0;
      }
   }
   b2PrismaticJoint.prototype.SolveVelocityConstraints = function (step) {
      var bA = this.m_bodyA;
      var bB = this.m_bodyB;
      var v1 = bA.m_linearVelocity;
      var w1 = bA.m_angularVelocity;
      var v2 = bB.m_linearVelocity;
      var w2 = bB.m_angularVelocity;
      var PX = 0;
      var PY = 0;
      var L1 = 0;
      var L2 = 0;
      if (this.m_enableMotor && this.m_limitState != b2Joint.e_equalLimits) {
         var Cdot = this.m_axis.x * (v2.x - v1.x) + this.m_axis.y * (v2.y - v1.y) + this.m_a2 * w2 - this.m_a1 * w1;
         var impulse = this.m_motorMass * (this.m_motorSpeed - Cdot);
         var oldImpulse = this.m_motorImpulse;
         var maxImpulse = step.dt * this.m_maxMotorForce;
         this.m_motorImpulse = b2Math.Clamp(this.m_motorImpulse + impulse, (-maxImpulse), maxImpulse);
         impulse = this.m_motorImpulse - oldImpulse;
         PX = impulse * this.m_axis.x;
         PY = impulse * this.m_axis.y;
         L1 = impulse * this.m_a1;
         L2 = impulse * this.m_a2;
         v1.x -= this.m_invMassA * PX;
         v1.y -= this.m_invMassA * PY;
         w1 -= this.m_invIA * L1;
         v2.x += this.m_invMassB * PX;
         v2.y += this.m_invMassB * PY;
         w2 += this.m_invIB * L2;
      }
      var Cdot1X = this.m_perp.x * (v2.x - v1.x) + this.m_perp.y * (v2.y - v1.y) + this.m_s2 * w2 - this.m_s1 * w1;
      var Cdot1Y = w2 - w1;
      if (this.m_enableLimit && this.m_limitState != b2Joint.e_inactiveLimit) {
         var Cdot2 = this.m_axis.x * (v2.x - v1.x) + this.m_axis.y * (v2.y - v1.y) + this.m_a2 * w2 - this.m_a1 * w1;
         var f1 = this.m_impulse.Copy();
         var df = this.m_K.Solve33(new b2Vec3(), (-Cdot1X), (-Cdot1Y), (-Cdot2));
         this.m_impulse.Add(df);
         if (this.m_limitState == b2Joint.e_atLowerLimit) {
            this.m_impulse.z = b2Math.Max(this.m_impulse.z, 0.0);
         }
         else if (this.m_limitState == b2Joint.e_atUpperLimit) {
            this.m_impulse.z = b2Math.Min(this.m_impulse.z, 0.0);
         }
         var bX = (-Cdot1X) - (this.m_impulse.z - f1.z) * this.m_K.col3.x;
         var bY = (-Cdot1Y) - (this.m_impulse.z - f1.z) * this.m_K.col3.y;
         var f2r = this.m_K.Solve22(new b2Vec2(), bX, bY);
         f2r.x += f1.x;
         f2r.y += f1.y;
         this.m_impulse.x = f2r.x;
         this.m_impulse.y = f2r.y;
         df.x = this.m_impulse.x - f1.x;
         df.y = this.m_impulse.y - f1.y;
         df.z = this.m_impulse.z - f1.z;
         PX = df.x * this.m_perp.x + df.z * this.m_axis.x;
         PY = df.x * this.m_perp.y + df.z * this.m_axis.y;
         L1 = df.x * this.m_s1 + df.y + df.z * this.m_a1;
         L2 = df.x * this.m_s2 + df.y + df.z * this.m_a2;
         v1.x -= this.m_invMassA * PX;
         v1.y -= this.m_invMassA * PY;
         w1 -= this.m_invIA * L1;
         v2.x += this.m_invMassB * PX;
         v2.y += this.m_invMassB * PY;
         w2 += this.m_invIB * L2;
      }
      else {
         var df2 = this.m_K.Solve22(new b2Vec2(), (-Cdot1X), (-Cdot1Y));
         this.m_impulse.x += df2.x;
         this.m_impulse.y += df2.y;
         PX = df2.x * this.m_perp.x;
         PY = df2.x * this.m_perp.y;
         L1 = df2.x * this.m_s1 + df2.y;
         L2 = df2.x * this.m_s2 + df2.y;
         v1.x -= this.m_invMassA * PX;
         v1.y -= this.m_invMassA * PY;
         w1 -= this.m_invIA * L1;
         v2.x += this.m_invMassB * PX;
         v2.y += this.m_invMassB * PY;
         w2 += this.m_invIB * L2;
      }
      bA.m_linearVelocity.SetV(v1);
      bA.m_angularVelocity = w1;
      bB.m_linearVelocity.SetV(v2);
      bB.m_angularVelocity = w2;
   }
   b2PrismaticJoint.prototype.SolvePositionConstraints = function (baumgarte) {
      if (baumgarte === undefined) baumgarte = 0;
      var limitC = 0;
      var oldLimitImpulse = 0;
      var bA = this.m_bodyA;
      var bB = this.m_bodyB;
      var c1 = bA.m_sweep.c;
      var a1 = bA.m_sweep.a;
      var c2 = bB.m_sweep.c;
      var a2 = bB.m_sweep.a;
      var tMat;
      var tX = 0;
      var m1 = 0;
      var m2 = 0;
      var i1 = 0;
      var i2 = 0;
      var linearError = 0.0;
      var angularError = 0.0;
      var active = false;
      var C2 = 0.0;
      var R1 = b2Mat22.FromAngle(a1);
      var R2 = b2Mat22.FromAngle(a2);
      tMat = R1;
      var r1X = this.m_localAnchor1.x - this.m_localCenterA.x;
      var r1Y = this.m_localAnchor1.y - this.m_localCenterA.y;
      tX = (tMat.col1.x * r1X + tMat.col2.x * r1Y);
      r1Y = (tMat.col1.y * r1X + tMat.col2.y * r1Y);
      r1X = tX;
      tMat = R2;
      var r2X = this.m_localAnchor2.x - this.m_localCenterB.x;
      var r2Y = this.m_localAnchor2.y - this.m_localCenterB.y;
      tX = (tMat.col1.x * r2X + tMat.col2.x * r2Y);
      r2Y = (tMat.col1.y * r2X + tMat.col2.y * r2Y);
      r2X = tX;
      var dX = c2.x + r2X - c1.x - r1X;
      var dY = c2.y + r2Y - c1.y - r1Y;
      if (this.m_enableLimit) {
         this.m_axis = b2Math.MulMV(R1, this.m_localXAxis1);
         this.m_a1 = (dX + r1X) * this.m_axis.y - (dY + r1Y) * this.m_axis.x;
         this.m_a2 = r2X * this.m_axis.y - r2Y * this.m_axis.x;
         var translation = this.m_axis.x * dX + this.m_axis.y * dY;
         if (b2Math.Abs(this.m_upperTranslation - this.m_lowerTranslation) < 2.0 * b2Settings.b2_linearSlop) {
            C2 = b2Math.Clamp(translation, (-b2Settings.b2_maxLinearCorrection), b2Settings.b2_maxLinearCorrection);
            linearError = b2Math.Abs(translation);
            active = true;
         }
         else if (translation <= this.m_lowerTranslation) {
            C2 = b2Math.Clamp(translation - this.m_lowerTranslation + b2Settings.b2_linearSlop, (-b2Settings.b2_maxLinearCorrection), 0.0);
            linearError = this.m_lowerTranslation - translation;
            active = true;
         }
         else if (translation >= this.m_upperTranslation) {
            C2 = b2Math.Clamp(translation - this.m_upperTranslation + b2Settings.b2_linearSlop, 0.0, b2Settings.b2_maxLinearCorrection);
            linearError = translation - this.m_upperTranslation;
            active = true;
         }
      }
      this.m_perp = b2Math.MulMV(R1, this.m_localYAxis1);
      this.m_s1 = (dX + r1X) * this.m_perp.y - (dY + r1Y) * this.m_perp.x;
      this.m_s2 = r2X * this.m_perp.y - r2Y * this.m_perp.x;
      var impulse = new b2Vec3();
      var C1X = this.m_perp.x * dX + this.m_perp.y * dY;
      var C1Y = a2 - a1 - this.m_refAngle;
      linearError = b2Math.Max(linearError, b2Math.Abs(C1X));
      angularError = b2Math.Abs(C1Y);
      if (active) {
         m1 = this.m_invMassA;
         m2 = this.m_invMassB;
         i1 = this.m_invIA;
         i2 = this.m_invIB;
         this.m_K.col1.x = m1 + m2 + i1 * this.m_s1 * this.m_s1 + i2 * this.m_s2 * this.m_s2;
         this.m_K.col1.y = i1 * this.m_s1 + i2 * this.m_s2;
         this.m_K.col1.z = i1 * this.m_s1 * this.m_a1 + i2 * this.m_s2 * this.m_a2;
         this.m_K.col2.x = this.m_K.col1.y;
         this.m_K.col2.y = i1 + i2;
         this.m_K.col2.z = i1 * this.m_a1 + i2 * this.m_a2;
         this.m_K.col3.x = this.m_K.col1.z;
         this.m_K.col3.y = this.m_K.col2.z;
         this.m_K.col3.z = m1 + m2 + i1 * this.m_a1 * this.m_a1 + i2 * this.m_a2 * this.m_a2;
         this.m_K.Solve33(impulse, (-C1X), (-C1Y), (-C2));
      }
      else {
         m1 = this.m_invMassA;
         m2 = this.m_invMassB;
         i1 = this.m_invIA;
         i2 = this.m_invIB;
         var k11 = m1 + m2 + i1 * this.m_s1 * this.m_s1 + i2 * this.m_s2 * this.m_s2;
         var k12 = i1 * this.m_s1 + i2 * this.m_s2;
         var k22 = i1 + i2;
         this.m_K.col1.Set(k11, k12, 0.0);
         this.m_K.col2.Set(k12, k22, 0.0);
         var impulse1 = this.m_K.Solve22(new b2Vec2(), (-C1X), (-C1Y));
         impulse.x = impulse1.x;
         impulse.y = impulse1.y;
         impulse.z = 0.0;
      }
      var PX = impulse.x * this.m_perp.x + impulse.z * this.m_axis.x;
      var PY = impulse.x * this.m_perp.y + impulse.z * this.m_axis.y;
      var L1 = impulse.x * this.m_s1 + impulse.y + impulse.z * this.m_a1;
      var L2 = impulse.x * this.m_s2 + impulse.y + impulse.z * this.m_a2;
      c1.x -= this.m_invMassA * PX;
      c1.y -= this.m_invMassA * PY;
      a1 -= this.m_invIA * L1;
      c2.x += this.m_invMassB * PX;
      c2.y += this.m_invMassB * PY;
      a2 += this.m_invIB * L2;
      bA.m_sweep.a = a1;
      bB.m_sweep.a = a2;
      bA.SynchronizeTransform();
      bB.SynchronizeTransform();
      return linearError <= b2Settings.b2_linearSlop && angularError <= b2Settings.b2_angularSlop;
   }
   Box2D.inherit(b2PrismaticJointDef, Box2D.Dynamics.Joints.b2JointDef);
   b2PrismaticJointDef.prototype.__super = Box2D.Dynamics.Joints.b2JointDef.prototype;
   b2PrismaticJointDef.b2PrismaticJointDef = function () {
      Box2D.Dynamics.Joints.b2JointDef.b2JointDef.apply(this, arguments);
      this.localAnchorA = new b2Vec2();
      this.localAnchorB = new b2Vec2();
      this.localAxisA = new b2Vec2();
   };
   b2PrismaticJointDef.prototype.b2PrismaticJointDef = function () {
      this.__super.b2JointDef.call(this);
      this.type = b2Joint.e_prismaticJoint;
      this.localAxisA.Set(1.0, 0.0);
      this.referenceAngle = 0.0;
      this.enableLimit = false;
      this.lowerTranslation = 0.0;
      this.upperTranslation = 0.0;
      this.enableMotor = false;
      this.maxMotorForce = 0.0;
      this.motorSpeed = 0.0;
   }
   b2PrismaticJointDef.prototype.Initialize = function (bA, bB, anchor, axis) {
      this.bodyA = bA;
      this.bodyB = bB;
      this.localAnchorA = this.bodyA.GetLocalPoint(anchor);
      this.localAnchorB = this.bodyB.GetLocalPoint(anchor);
      this.localAxisA = this.bodyA.GetLocalVector(axis);
      this.referenceAngle = this.bodyB.GetAngle() - this.bodyA.GetAngle();
   }
   Box2D.inherit(b2PulleyJoint, Box2D.Dynamics.Joints.b2Joint);
   b2PulleyJoint.prototype.__super = Box2D.Dynamics.Joints.b2Joint.prototype;
   b2PulleyJoint.b2PulleyJoint = function () {
      Box2D.Dynamics.Joints.b2Joint.b2Joint.apply(this, arguments);
      this.m_groundAnchor1 = new b2Vec2();
      this.m_groundAnchor2 = new b2Vec2();
      this.m_localAnchor1 = new b2Vec2();
      this.m_localAnchor2 = new b2Vec2();
      this.m_u1 = new b2Vec2();
      this.m_u2 = new b2Vec2();
   };
   b2PulleyJoint.prototype.GetAnchorA = function () {
      return this.m_bodyA.GetWorldPoint(this.m_localAnchor1);
   }
   b2PulleyJoint.prototype.GetAnchorB = function () {
      return this.m_bodyB.GetWorldPoint(this.m_localAnchor2);
   }
   b2PulleyJoint.prototype.GetReactionForce = function (inv_dt) {
      if (inv_dt === undefined) inv_dt = 0;
      return new b2Vec2(inv_dt * this.m_impulse * this.m_u2.x, inv_dt * this.m_impulse * this.m_u2.y);
   }
   b2PulleyJoint.prototype.GetReactionTorque = function (inv_dt) {
      if (inv_dt === undefined) inv_dt = 0;
      return 0.0;
   }
   b2PulleyJoint.prototype.GetGroundAnchorA = function () {
      var a = this.m_ground.m_xf.position.Copy();
      a.Add(this.m_groundAnchor1);
      return a;
   }
   b2PulleyJoint.prototype.GetGroundAnchorB = function () {
      var a = this.m_ground.m_xf.position.Copy();
      a.Add(this.m_groundAnchor2);
      return a;
   }
   b2PulleyJoint.prototype.GetLength1 = function () {
      var p = this.m_bodyA.GetWorldPoint(this.m_localAnchor1);
      var sX = this.m_ground.m_xf.position.x + this.m_groundAnchor1.x;
      var sY = this.m_ground.m_xf.position.y + this.m_groundAnchor1.y;
      var dX = p.x - sX;
      var dY = p.y - sY;
      return Math.sqrt(dX * dX + dY * dY);
   }
   b2PulleyJoint.prototype.GetLength2 = function () {
      var p = this.m_bodyB.GetWorldPoint(this.m_localAnchor2);
      var sX = this.m_ground.m_xf.position.x + this.m_groundAnchor2.x;
      var sY = this.m_ground.m_xf.position.y + this.m_groundAnchor2.y;
      var dX = p.x - sX;
      var dY = p.y - sY;
      return Math.sqrt(dX * dX + dY * dY);
   }
   b2PulleyJoint.prototype.GetRatio = function () {
      return this.m_ratio;
   }
   b2PulleyJoint.prototype.b2PulleyJoint = function (def) {
      this.__super.b2Joint.call(this, def);
      var tMat;
      var tX = 0;
      var tY = 0;
      this.m_ground = this.m_bodyA.m_world.m_groundBody;
      this.m_groundAnchor1.x = def.groundAnchorA.x - this.m_ground.m_xf.position.x;
      this.m_groundAnchor1.y = def.groundAnchorA.y - this.m_ground.m_xf.position.y;
      this.m_groundAnchor2.x = def.groundAnchorB.x - this.m_ground.m_xf.position.x;
      this.m_groundAnchor2.y = def.groundAnchorB.y - this.m_ground.m_xf.position.y;
      this.m_localAnchor1.SetV(def.localAnchorA);
      this.m_localAnchor2.SetV(def.localAnchorB);
      this.m_ratio = def.ratio;
      this.m_constant = def.lengthA + this.m_ratio * def.lengthB;
      this.m_maxLength1 = b2Math.Min(def.maxLengthA, this.m_constant - this.m_ratio * b2PulleyJoint.b2_minPulleyLength);
      this.m_maxLength2 = b2Math.Min(def.maxLengthB, (this.m_constant - b2PulleyJoint.b2_minPulleyLength) / this.m_ratio);
      this.m_impulse = 0.0;
      this.m_limitImpulse1 = 0.0;
      this.m_limitImpulse2 = 0.0;
   }
   b2PulleyJoint.prototype.InitVelocityConstraints = function (step) {
      var bA = this.m_bodyA;
      var bB = this.m_bodyB;
      var tMat;
      tMat = bA.m_xf.R;
      var r1X = this.m_localAnchor1.x - bA.m_sweep.localCenter.x;
      var r1Y = this.m_localAnchor1.y - bA.m_sweep.localCenter.y;
      var tX = (tMat.col1.x * r1X + tMat.col2.x * r1Y);
      r1Y = (tMat.col1.y * r1X + tMat.col2.y * r1Y);
      r1X = tX;
      tMat = bB.m_xf.R;
      var r2X = this.m_localAnchor2.x - bB.m_sweep.localCenter.x;
      var r2Y = this.m_localAnchor2.y - bB.m_sweep.localCenter.y;
      tX = (tMat.col1.x * r2X + tMat.col2.x * r2Y);
      r2Y = (tMat.col1.y * r2X + tMat.col2.y * r2Y);
      r2X = tX;
      var p1X = bA.m_sweep.c.x + r1X;
      var p1Y = bA.m_sweep.c.y + r1Y;
      var p2X = bB.m_sweep.c.x + r2X;
      var p2Y = bB.m_sweep.c.y + r2Y;
      var s1X = this.m_ground.m_xf.position.x + this.m_groundAnchor1.x;
      var s1Y = this.m_ground.m_xf.position.y + this.m_groundAnchor1.y;
      var s2X = this.m_ground.m_xf.position.x + this.m_groundAnchor2.x;
      var s2Y = this.m_ground.m_xf.position.y + this.m_groundAnchor2.y;
      this.m_u1.Set(p1X - s1X, p1Y - s1Y);
      this.m_u2.Set(p2X - s2X, p2Y - s2Y);
      var length1 = this.m_u1.Length();
      var length2 = this.m_u2.Length();
      if (length1 > b2Settings.b2_linearSlop) {
         this.m_u1.Multiply(1.0 / length1);
      }
      else {
         this.m_u1.SetZero();
      }
      if (length2 > b2Settings.b2_linearSlop) {
         this.m_u2.Multiply(1.0 / length2);
      }
      else {
         this.m_u2.SetZero();
      }
      var C = this.m_constant - length1 - this.m_ratio * length2;
      if (C > 0.0) {
         this.m_state = b2Joint.e_inactiveLimit;
         this.m_impulse = 0.0;
      }
      else {
         this.m_state = b2Joint.e_atUpperLimit;
      }
      if (length1 < this.m_maxLength1) {
         this.m_limitState1 = b2Joint.e_inactiveLimit;
         this.m_limitImpulse1 = 0.0;
      }
      else {
         this.m_limitState1 = b2Joint.e_atUpperLimit;
      }
      if (length2 < this.m_maxLength2) {
         this.m_limitState2 = b2Joint.e_inactiveLimit;
         this.m_limitImpulse2 = 0.0;
      }
      else {
         this.m_limitState2 = b2Joint.e_atUpperLimit;
      }
      var cr1u1 = r1X * this.m_u1.y - r1Y * this.m_u1.x;
      var cr2u2 = r2X * this.m_u2.y - r2Y * this.m_u2.x;
      this.m_limitMass1 = bA.m_invMass + bA.m_invI * cr1u1 * cr1u1;
      this.m_limitMass2 = bB.m_invMass + bB.m_invI * cr2u2 * cr2u2;
      this.m_pulleyMass = this.m_limitMass1 + this.m_ratio * this.m_ratio * this.m_limitMass2;
      this.m_limitMass1 = 1.0 / this.m_limitMass1;
      this.m_limitMass2 = 1.0 / this.m_limitMass2;
      this.m_pulleyMass = 1.0 / this.m_pulleyMass;
      if (step.warmStarting) {
         this.m_impulse *= step.dtRatio;
         this.m_limitImpulse1 *= step.dtRatio;
         this.m_limitImpulse2 *= step.dtRatio;
         var P1X = ((-this.m_impulse) - this.m_limitImpulse1) * this.m_u1.x;
         var P1Y = ((-this.m_impulse) - this.m_limitImpulse1) * this.m_u1.y;
         var P2X = ((-this.m_ratio * this.m_impulse) - this.m_limitImpulse2) * this.m_u2.x;
         var P2Y = ((-this.m_ratio * this.m_impulse) - this.m_limitImpulse2) * this.m_u2.y;
         bA.m_linearVelocity.x += bA.m_invMass * P1X;
         bA.m_linearVelocity.y += bA.m_invMass * P1Y;
         bA.m_angularVelocity += bA.m_invI * (r1X * P1Y - r1Y * P1X);
         bB.m_linearVelocity.x += bB.m_invMass * P2X;
         bB.m_linearVelocity.y += bB.m_invMass * P2Y;
         bB.m_angularVelocity += bB.m_invI * (r2X * P2Y - r2Y * P2X);
      }
      else {
         this.m_impulse = 0.0;
         this.m_limitImpulse1 = 0.0;
         this.m_limitImpulse2 = 0.0;
      }
   }
   b2PulleyJoint.prototype.SolveVelocityConstraints = function (step) {
      var bA = this.m_bodyA;
      var bB = this.m_bodyB;
      var tMat;
      tMat = bA.m_xf.R;
      var r1X = this.m_localAnchor1.x - bA.m_sweep.localCenter.x;
      var r1Y = this.m_localAnchor1.y - bA.m_sweep.localCenter.y;
      var tX = (tMat.col1.x * r1X + tMat.col2.x * r1Y);
      r1Y = (tMat.col1.y * r1X + tMat.col2.y * r1Y);
      r1X = tX;
      tMat = bB.m_xf.R;
      var r2X = this.m_localAnchor2.x - bB.m_sweep.localCenter.x;
      var r2Y = this.m_localAnchor2.y - bB.m_sweep.localCenter.y;
      tX = (tMat.col1.x * r2X + tMat.col2.x * r2Y);
      r2Y = (tMat.col1.y * r2X + tMat.col2.y * r2Y);
      r2X = tX;
      var v1X = 0;
      var v1Y = 0;
      var v2X = 0;
      var v2Y = 0;
      var P1X = 0;
      var P1Y = 0;
      var P2X = 0;
      var P2Y = 0;
      var Cdot = 0;
      var impulse = 0;
      var oldImpulse = 0;
      if (this.m_state == b2Joint.e_atUpperLimit) {
         v1X = bA.m_linearVelocity.x + ((-bA.m_angularVelocity * r1Y));
         v1Y = bA.m_linearVelocity.y + (bA.m_angularVelocity * r1X);
         v2X = bB.m_linearVelocity.x + ((-bB.m_angularVelocity * r2Y));
         v2Y = bB.m_linearVelocity.y + (bB.m_angularVelocity * r2X);
         Cdot = (-(this.m_u1.x * v1X + this.m_u1.y * v1Y)) - this.m_ratio * (this.m_u2.x * v2X + this.m_u2.y * v2Y);
         impulse = this.m_pulleyMass * ((-Cdot));
         oldImpulse = this.m_impulse;
         this.m_impulse = b2Math.Max(0.0, this.m_impulse + impulse);
         impulse = this.m_impulse - oldImpulse;
         P1X = (-impulse * this.m_u1.x);
         P1Y = (-impulse * this.m_u1.y);
         P2X = (-this.m_ratio * impulse * this.m_u2.x);
         P2Y = (-this.m_ratio * impulse * this.m_u2.y);
         bA.m_linearVelocity.x += bA.m_invMass * P1X;
         bA.m_linearVelocity.y += bA.m_invMass * P1Y;
         bA.m_angularVelocity += bA.m_invI * (r1X * P1Y - r1Y * P1X);
         bB.m_linearVelocity.x += bB.m_invMass * P2X;
         bB.m_linearVelocity.y += bB.m_invMass * P2Y;
         bB.m_angularVelocity += bB.m_invI * (r2X * P2Y - r2Y * P2X);
      }
      if (this.m_limitState1 == b2Joint.e_atUpperLimit) {
         v1X = bA.m_linearVelocity.x + ((-bA.m_angularVelocity * r1Y));
         v1Y = bA.m_linearVelocity.y + (bA.m_angularVelocity * r1X);
         Cdot = (-(this.m_u1.x * v1X + this.m_u1.y * v1Y));
         impulse = (-this.m_limitMass1 * Cdot);
         oldImpulse = this.m_limitImpulse1;
         this.m_limitImpulse1 = b2Math.Max(0.0, this.m_limitImpulse1 + impulse);
         impulse = this.m_limitImpulse1 - oldImpulse;
         P1X = (-impulse * this.m_u1.x);
         P1Y = (-impulse * this.m_u1.y);
         bA.m_linearVelocity.x += bA.m_invMass * P1X;
         bA.m_linearVelocity.y += bA.m_invMass * P1Y;
         bA.m_angularVelocity += bA.m_invI * (r1X * P1Y - r1Y * P1X);
      }
      if (this.m_limitState2 == b2Joint.e_atUpperLimit) {
         v2X = bB.m_linearVelocity.x + ((-bB.m_angularVelocity * r2Y));
         v2Y = bB.m_linearVelocity.y + (bB.m_angularVelocity * r2X);
         Cdot = (-(this.m_u2.x * v2X + this.m_u2.y * v2Y));
         impulse = (-this.m_limitMass2 * Cdot);
         oldImpulse = this.m_limitImpulse2;
         this.m_limitImpulse2 = b2Math.Max(0.0, this.m_limitImpulse2 + impulse);
         impulse = this.m_limitImpulse2 - oldImpulse;
         P2X = (-impulse * this.m_u2.x);
         P2Y = (-impulse * this.m_u2.y);
         bB.m_linearVelocity.x += bB.m_invMass * P2X;
         bB.m_linearVelocity.y += bB.m_invMass * P2Y;
         bB.m_angularVelocity += bB.m_invI * (r2X * P2Y - r2Y * P2X);
      }
   }
   b2PulleyJoint.prototype.SolvePositionConstraints = function (baumgarte) {
      if (baumgarte === undefined) baumgarte = 0;
      var bA = this.m_bodyA;
      var bB = this.m_bodyB;
      var tMat;
      var s1X = this.m_ground.m_xf.position.x + this.m_groundAnchor1.x;
      var s1Y = this.m_ground.m_xf.position.y + this.m_groundAnchor1.y;
      var s2X = this.m_ground.m_xf.position.x + this.m_groundAnchor2.x;
      var s2Y = this.m_ground.m_xf.position.y + this.m_groundAnchor2.y;
      var r1X = 0;
      var r1Y = 0;
      var r2X = 0;
      var r2Y = 0;
      var p1X = 0;
      var p1Y = 0;
      var p2X = 0;
      var p2Y = 0;
      var length1 = 0;
      var length2 = 0;
      var C = 0;
      var impulse = 0;
      var oldImpulse = 0;
      var oldLimitPositionImpulse = 0;
      var tX = 0;
      var linearError = 0.0;
      if (this.m_state == b2Joint.e_atUpperLimit) {
         tMat = bA.m_xf.R;
         r1X = this.m_localAnchor1.x - bA.m_sweep.localCenter.x;
         r1Y = this.m_localAnchor1.y - bA.m_sweep.localCenter.y;
         tX = (tMat.col1.x * r1X + tMat.col2.x * r1Y);
         r1Y = (tMat.col1.y * r1X + tMat.col2.y * r1Y);
         r1X = tX;
         tMat = bB.m_xf.R;
         r2X = this.m_localAnchor2.x - bB.m_sweep.localCenter.x;
         r2Y = this.m_localAnchor2.y - bB.m_sweep.localCenter.y;
         tX = (tMat.col1.x * r2X + tMat.col2.x * r2Y);
         r2Y = (tMat.col1.y * r2X + tMat.col2.y * r2Y);
         r2X = tX;
         p1X = bA.m_sweep.c.x + r1X;
         p1Y = bA.m_sweep.c.y + r1Y;
         p2X = bB.m_sweep.c.x + r2X;
         p2Y = bB.m_sweep.c.y + r2Y;
         this.m_u1.Set(p1X - s1X, p1Y - s1Y);
         this.m_u2.Set(p2X - s2X, p2Y - s2Y);
         length1 = this.m_u1.Length();
         length2 = this.m_u2.Length();
         if (length1 > b2Settings.b2_linearSlop) {
            this.m_u1.Multiply(1.0 / length1);
         }
         else {
            this.m_u1.SetZero();
         }
         if (length2 > b2Settings.b2_linearSlop) {
            this.m_u2.Multiply(1.0 / length2);
         }
         else {
            this.m_u2.SetZero();
         }
         C = this.m_constant - length1 - this.m_ratio * length2;
         linearError = b2Math.Max(linearError, (-C));
         C = b2Math.Clamp(C + b2Settings.b2_linearSlop, (-b2Settings.b2_maxLinearCorrection), 0.0);
         impulse = (-this.m_pulleyMass * C);
         p1X = (-impulse * this.m_u1.x);
         p1Y = (-impulse * this.m_u1.y);
         p2X = (-this.m_ratio * impulse * this.m_u2.x);
         p2Y = (-this.m_ratio * impulse * this.m_u2.y);
         bA.m_sweep.c.x += bA.m_invMass * p1X;
         bA.m_sweep.c.y += bA.m_invMass * p1Y;
         bA.m_sweep.a += bA.m_invI * (r1X * p1Y - r1Y * p1X);
         bB.m_sweep.c.x += bB.m_invMass * p2X;
         bB.m_sweep.c.y += bB.m_invMass * p2Y;
         bB.m_sweep.a += bB.m_invI * (r2X * p2Y - r2Y * p2X);
         bA.SynchronizeTransform();
         bB.SynchronizeTransform();
      }
      if (this.m_limitState1 == b2Joint.e_atUpperLimit) {
         tMat = bA.m_xf.R;
         r1X = this.m_localAnchor1.x - bA.m_sweep.localCenter.x;
         r1Y = this.m_localAnchor1.y - bA.m_sweep.localCenter.y;
         tX = (tMat.col1.x * r1X + tMat.col2.x * r1Y);
         r1Y = (tMat.col1.y * r1X + tMat.col2.y * r1Y);
         r1X = tX;
         p1X = bA.m_sweep.c.x + r1X;
         p1Y = bA.m_sweep.c.y + r1Y;
         this.m_u1.Set(p1X - s1X, p1Y - s1Y);
         length1 = this.m_u1.Length();
         if (length1 > b2Settings.b2_linearSlop) {
            this.m_u1.x *= 1.0 / length1;
            this.m_u1.y *= 1.0 / length1;
         }
         else {
            this.m_u1.SetZero();
         }
         C = this.m_maxLength1 - length1;
         linearError = b2Math.Max(linearError, (-C));
         C = b2Math.Clamp(C + b2Settings.b2_linearSlop, (-b2Settings.b2_maxLinearCorrection), 0.0);
         impulse = (-this.m_limitMass1 * C);
         p1X = (-impulse * this.m_u1.x);
         p1Y = (-impulse * this.m_u1.y);
         bA.m_sweep.c.x += bA.m_invMass * p1X;
         bA.m_sweep.c.y += bA.m_invMass * p1Y;
         bA.m_sweep.a += bA.m_invI * (r1X * p1Y - r1Y * p1X);
         bA.SynchronizeTransform();
      }
      if (this.m_limitState2 == b2Joint.e_atUpperLimit) {
         tMat = bB.m_xf.R;
         r2X = this.m_localAnchor2.x - bB.m_sweep.localCenter.x;
         r2Y = this.m_localAnchor2.y - bB.m_sweep.localCenter.y;
         tX = (tMat.col1.x * r2X + tMat.col2.x * r2Y);
         r2Y = (tMat.col1.y * r2X + tMat.col2.y * r2Y);
         r2X = tX;
         p2X = bB.m_sweep.c.x + r2X;
         p2Y = bB.m_sweep.c.y + r2Y;
         this.m_u2.Set(p2X - s2X, p2Y - s2Y);
         length2 = this.m_u2.Length();
         if (length2 > b2Settings.b2_linearSlop) {
            this.m_u2.x *= 1.0 / length2;
            this.m_u2.y *= 1.0 / length2;
         }
         else {
            this.m_u2.SetZero();
         }
         C = this.m_maxLength2 - length2;
         linearError = b2Math.Max(linearError, (-C));
         C = b2Math.Clamp(C + b2Settings.b2_linearSlop, (-b2Settings.b2_maxLinearCorrection), 0.0);
         impulse = (-this.m_limitMass2 * C);
         p2X = (-impulse * this.m_u2.x);
         p2Y = (-impulse * this.m_u2.y);
         bB.m_sweep.c.x += bB.m_invMass * p2X;
         bB.m_sweep.c.y += bB.m_invMass * p2Y;
         bB.m_sweep.a += bB.m_invI * (r2X * p2Y - r2Y * p2X);
         bB.SynchronizeTransform();
      }
      return linearError < b2Settings.b2_linearSlop;
   }
   Box2D.postDefs.push(function () {
      Box2D.Dynamics.Joints.b2PulleyJoint.b2_minPulleyLength = 2.0;
   });
   Box2D.inherit(b2PulleyJointDef, Box2D.Dynamics.Joints.b2JointDef);
   b2PulleyJointDef.prototype.__super = Box2D.Dynamics.Joints.b2JointDef.prototype;
   b2PulleyJointDef.b2PulleyJointDef = function () {
      Box2D.Dynamics.Joints.b2JointDef.b2JointDef.apply(this, arguments);
      this.groundAnchorA = new b2Vec2();
      this.groundAnchorB = new b2Vec2();
      this.localAnchorA = new b2Vec2();
      this.localAnchorB = new b2Vec2();
   };
   b2PulleyJointDef.prototype.b2PulleyJointDef = function () {
      this.__super.b2JointDef.call(this);
      this.type = b2Joint.e_pulleyJoint;
      this.groundAnchorA.Set((-1.0), 1.0);
      this.groundAnchorB.Set(1.0, 1.0);
      this.localAnchorA.Set((-1.0), 0.0);
      this.localAnchorB.Set(1.0, 0.0);
      this.lengthA = 0.0;
      this.maxLengthA = 0.0;
      this.lengthB = 0.0;
      this.maxLengthB = 0.0;
      this.ratio = 1.0;
      this.collideConnected = true;
   }
   b2PulleyJointDef.prototype.Initialize = function (bA, bB, gaA, gaB, anchorA, anchorB, r) {
      if (r === undefined) r = 0;
      this.bodyA = bA;
      this.bodyB = bB;
      this.groundAnchorA.SetV(gaA);
      this.groundAnchorB.SetV(gaB);
      this.localAnchorA = this.bodyA.GetLocalPoint(anchorA);
      this.localAnchorB = this.bodyB.GetLocalPoint(anchorB);
      var d1X = anchorA.x - gaA.x;
      var d1Y = anchorA.y - gaA.y;
      this.lengthA = Math.sqrt(d1X * d1X + d1Y * d1Y);
      var d2X = anchorB.x - gaB.x;
      var d2Y = anchorB.y - gaB.y;
      this.lengthB = Math.sqrt(d2X * d2X + d2Y * d2Y);
      this.ratio = r;
      var C = this.lengthA + this.ratio * this.lengthB;
      this.maxLengthA = C - this.ratio * b2PulleyJoint.b2_minPulleyLength;
      this.maxLengthB = (C - b2PulleyJoint.b2_minPulleyLength) / this.ratio;
   }
   Box2D.inherit(b2RevoluteJoint, Box2D.Dynamics.Joints.b2Joint);
   b2RevoluteJoint.prototype.__super = Box2D.Dynamics.Joints.b2Joint.prototype;
   b2RevoluteJoint.b2RevoluteJoint = function () {
      Box2D.Dynamics.Joints.b2Joint.b2Joint.apply(this, arguments);
      this.K = new b2Mat22();
      this.K1 = new b2Mat22();
      this.K2 = new b2Mat22();
      this.K3 = new b2Mat22();
      this.impulse3 = new b2Vec3();
      this.impulse2 = new b2Vec2();
      this.reduced = new b2Vec2();
      this.m_localAnchor1 = new b2Vec2();
      this.m_localAnchor2 = new b2Vec2();
      this.m_impulse = new b2Vec3();
      this.m_mass = new b2Mat33();
   };
   b2RevoluteJoint.prototype.GetAnchorA = function () {
      return this.m_bodyA.GetWorldPoint(this.m_localAnchor1);
   }
   b2RevoluteJoint.prototype.GetAnchorB = function () {
      return this.m_bodyB.GetWorldPoint(this.m_localAnchor2);
   }
   b2RevoluteJoint.prototype.GetReactionForce = function (inv_dt) {
      if (inv_dt === undefined) inv_dt = 0;
      return new b2Vec2(inv_dt * this.m_impulse.x, inv_dt * this.m_impulse.y);
   }
   b2RevoluteJoint.prototype.GetReactionTorque = function (inv_dt) {
      if (inv_dt === undefined) inv_dt = 0;
      return inv_dt * this.m_impulse.z;
   }
   b2RevoluteJoint.prototype.GetJointAngle = function () {
      return this.m_bodyB.m_sweep.a - this.m_bodyA.m_sweep.a - this.m_referenceAngle;
   }
   b2RevoluteJoint.prototype.GetJointSpeed = function () {
      return this.m_bodyB.m_angularVelocity - this.m_bodyA.m_angularVelocity;
   }
   b2RevoluteJoint.prototype.IsLimitEnabled = function () {
      return this.m_enableLimit;
   }
   b2RevoluteJoint.prototype.EnableLimit = function (flag) {
      this.m_enableLimit = flag;
   }
   b2RevoluteJoint.prototype.GetLowerLimit = function () {
      return this.m_lowerAngle;
   }
   b2RevoluteJoint.prototype.GetUpperLimit = function () {
      return this.m_upperAngle;
   }
   b2RevoluteJoint.prototype.SetLimits = function (lower, upper) {
      if (lower === undefined) lower = 0;
      if (upper === undefined) upper = 0;
      this.m_lowerAngle = lower;
      this.m_upperAngle = upper;
   }
   b2RevoluteJoint.prototype.IsMotorEnabled = function () {
      this.m_bodyA.SetAwake(true);
      this.m_bodyB.SetAwake(true);
      return this.m_enableMotor;
   }
   b2RevoluteJoint.prototype.EnableMotor = function (flag) {
      this.m_enableMotor = flag;
   }
   b2RevoluteJoint.prototype.SetMotorSpeed = function (speed) {
      if (speed === undefined) speed = 0;
      this.m_bodyA.SetAwake(true);
      this.m_bodyB.SetAwake(true);
      this.m_motorSpeed = speed;
   }
   b2RevoluteJoint.prototype.GetMotorSpeed = function () {
      return this.m_motorSpeed;
   }
   b2RevoluteJoint.prototype.SetMaxMotorTorque = function (torque) {
      if (torque === undefined) torque = 0;
      this.m_maxMotorTorque = torque;
   }
   b2RevoluteJoint.prototype.GetMotorTorque = function () {
      return this.m_maxMotorTorque;
   }
   b2RevoluteJoint.prototype.b2RevoluteJoint = function (def) {
      this.__super.b2Joint.call(this, def);
      this.m_localAnchor1.SetV(def.localAnchorA);
      this.m_localAnchor2.SetV(def.localAnchorB);
      this.m_referenceAngle = def.referenceAngle;
      this.m_impulse.SetZero();
      this.m_motorImpulse = 0.0;
      this.m_lowerAngle = def.lowerAngle;
      this.m_upperAngle = def.upperAngle;
      this.m_maxMotorTorque = def.maxMotorTorque;
      this.m_motorSpeed = def.motorSpeed;
      this.m_enableLimit = def.enableLimit;
      this.m_enableMotor = def.enableMotor;
      this.m_limitState = b2Joint.e_inactiveLimit;
   }
   b2RevoluteJoint.prototype.InitVelocityConstraints = function (step) {
      var bA = this.m_bodyA;
      var bB = this.m_bodyB;
      var tMat;
      var tX = 0;
      if (this.m_enableMotor || this.m_enableLimit) {}
      tMat = bA.m_xf.R;
      var r1X = this.m_localAnchor1.x - bA.m_sweep.localCenter.x;
      var r1Y = this.m_localAnchor1.y - bA.m_sweep.localCenter.y;
      tX = (tMat.col1.x * r1X + tMat.col2.x * r1Y);
      r1Y = (tMat.col1.y * r1X + tMat.col2.y * r1Y);
      r1X = tX;
      tMat = bB.m_xf.R;
      var r2X = this.m_localAnchor2.x - bB.m_sweep.localCenter.x;
      var r2Y = this.m_localAnchor2.y - bB.m_sweep.localCenter.y;
      tX = (tMat.col1.x * r2X + tMat.col2.x * r2Y);
      r2Y = (tMat.col1.y * r2X + tMat.col2.y * r2Y);
      r2X = tX;
      var m1 = bA.m_invMass;
      var m2 = bB.m_invMass;
      var i1 = bA.m_invI;
      var i2 = bB.m_invI;
      this.m_mass.col1.x = m1 + m2 + r1Y * r1Y * i1 + r2Y * r2Y * i2;
      this.m_mass.col2.x = (-r1Y * r1X * i1) - r2Y * r2X * i2;
      this.m_mass.col3.x = (-r1Y * i1) - r2Y * i2;
      this.m_mass.col1.y = this.m_mass.col2.x;
      this.m_mass.col2.y = m1 + m2 + r1X * r1X * i1 + r2X * r2X * i2;
      this.m_mass.col3.y = r1X * i1 + r2X * i2;
      this.m_mass.col1.z = this.m_mass.col3.x;
      this.m_mass.col2.z = this.m_mass.col3.y;
      this.m_mass.col3.z = i1 + i2;
      this.m_motorMass = 1.0 / (i1 + i2);
      if (this.m_enableMotor == false) {
         this.m_motorImpulse = 0.0;
      }
      if (this.m_enableLimit) {
         var jointAngle = bB.m_sweep.a - bA.m_sweep.a - this.m_referenceAngle;
         if (b2Math.Abs(this.m_upperAngle - this.m_lowerAngle) < 2.0 * b2Settings.b2_angularSlop) {
            this.m_limitState = b2Joint.e_equalLimits;
         }
         else if (jointAngle <= this.m_lowerAngle) {
            if (this.m_limitState != b2Joint.e_atLowerLimit) {
               this.m_impulse.z = 0.0;
            }
            this.m_limitState = b2Joint.e_atLowerLimit;
         }
         else if (jointAngle >= this.m_upperAngle) {
            if (this.m_limitState != b2Joint.e_atUpperLimit) {
               this.m_impulse.z = 0.0;
            }
            this.m_limitState = b2Joint.e_atUpperLimit;
         }
         else {
            this.m_limitState = b2Joint.e_inactiveLimit;
            this.m_impulse.z = 0.0;
         }
      }
      else {
         this.m_limitState = b2Joint.e_inactiveLimit;
      }
      if (step.warmStarting) {
         this.m_impulse.x *= step.dtRatio;
         this.m_impulse.y *= step.dtRatio;
         this.m_motorImpulse *= step.dtRatio;
         var PX = this.m_impulse.x;
         var PY = this.m_impulse.y;
         bA.m_linearVelocity.x -= m1 * PX;
         bA.m_linearVelocity.y -= m1 * PY;
         bA.m_angularVelocity -= i1 * ((r1X * PY - r1Y * PX) + this.m_motorImpulse + this.m_impulse.z);
         bB.m_linearVelocity.x += m2 * PX;
         bB.m_linearVelocity.y += m2 * PY;
         bB.m_angularVelocity += i2 * ((r2X * PY - r2Y * PX) + this.m_motorImpulse + this.m_impulse.z);
      }
      else {
         this.m_impulse.SetZero();
         this.m_motorImpulse = 0.0;
      }
   }
   b2RevoluteJoint.prototype.SolveVelocityConstraints = function (step) {
      var bA = this.m_bodyA;
      var bB = this.m_bodyB;
      var tMat;
      var tX = 0;
      var newImpulse = 0;
      var r1X = 0;
      var r1Y = 0;
      var r2X = 0;
      var r2Y = 0;
      var v1 = bA.m_linearVelocity;
      var w1 = bA.m_angularVelocity;
      var v2 = bB.m_linearVelocity;
      var w2 = bB.m_angularVelocity;
      var m1 = bA.m_invMass;
      var m2 = bB.m_invMass;
      var i1 = bA.m_invI;
      var i2 = bB.m_invI;
      if (this.m_enableMotor && this.m_limitState != b2Joint.e_equalLimits) {
         var Cdot = w2 - w1 - this.m_motorSpeed;
         var impulse = this.m_motorMass * ((-Cdot));
         var oldImpulse = this.m_motorImpulse;
         var maxImpulse = step.dt * this.m_maxMotorTorque;
         this.m_motorImpulse = b2Math.Clamp(this.m_motorImpulse + impulse, (-maxImpulse), maxImpulse);
         impulse = this.m_motorImpulse - oldImpulse;
         w1 -= i1 * impulse;
         w2 += i2 * impulse;
      }
      if (this.m_enableLimit && this.m_limitState != b2Joint.e_inactiveLimit) {
         tMat = bA.m_xf.R;
         r1X = this.m_localAnchor1.x - bA.m_sweep.localCenter.x;
         r1Y = this.m_localAnchor1.y - bA.m_sweep.localCenter.y;
         tX = (tMat.col1.x * r1X + tMat.col2.x * r1Y);
         r1Y = (tMat.col1.y * r1X + tMat.col2.y * r1Y);
         r1X = tX;
         tMat = bB.m_xf.R;
         r2X = this.m_localAnchor2.x - bB.m_sweep.localCenter.x;
         r2Y = this.m_localAnchor2.y - bB.m_sweep.localCenter.y;
         tX = (tMat.col1.x * r2X + tMat.col2.x * r2Y);
         r2Y = (tMat.col1.y * r2X + tMat.col2.y * r2Y);
         r2X = tX;
         var Cdot1X = v2.x + ((-w2 * r2Y)) - v1.x - ((-w1 * r1Y));
         var Cdot1Y = v2.y + (w2 * r2X) - v1.y - (w1 * r1X);
         var Cdot2 = w2 - w1;
         this.m_mass.Solve33(this.impulse3, (-Cdot1X), (-Cdot1Y), (-Cdot2));
         if (this.m_limitState == b2Joint.e_equalLimits) {
            this.m_impulse.Add(this.impulse3);
         }
         else if (this.m_limitState == b2Joint.e_atLowerLimit) {
            newImpulse = this.m_impulse.z + this.impulse3.z;
            if (newImpulse < 0.0) {
               this.m_mass.Solve22(this.reduced, (-Cdot1X), (-Cdot1Y));
               this.impulse3.x = this.reduced.x;
               this.impulse3.y = this.reduced.y;
               this.impulse3.z = (-this.m_impulse.z);
               this.m_impulse.x += this.reduced.x;
               this.m_impulse.y += this.reduced.y;
               this.m_impulse.z = 0.0;
            }
         }
         else if (this.m_limitState == b2Joint.e_atUpperLimit) {
            newImpulse = this.m_impulse.z + this.impulse3.z;
            if (newImpulse > 0.0) {
               this.m_mass.Solve22(this.reduced, (-Cdot1X), (-Cdot1Y));
               this.impulse3.x = this.reduced.x;
               this.impulse3.y = this.reduced.y;
               this.impulse3.z = (-this.m_impulse.z);
               this.m_impulse.x += this.reduced.x;
               this.m_impulse.y += this.reduced.y;
               this.m_impulse.z = 0.0;
            }
         }
         v1.x -= m1 * this.impulse3.x;
         v1.y -= m1 * this.impulse3.y;
         w1 -= i1 * (r1X * this.impulse3.y - r1Y * this.impulse3.x + this.impulse3.z);
         v2.x += m2 * this.impulse3.x;
         v2.y += m2 * this.impulse3.y;
         w2 += i2 * (r2X * this.impulse3.y - r2Y * this.impulse3.x + this.impulse3.z);
      }
      else {
         tMat = bA.m_xf.R;
         r1X = this.m_localAnchor1.x - bA.m_sweep.localCenter.x;
         r1Y = this.m_localAnchor1.y - bA.m_sweep.localCenter.y;
         tX = (tMat.col1.x * r1X + tMat.col2.x * r1Y);
         r1Y = (tMat.col1.y * r1X + tMat.col2.y * r1Y);
         r1X = tX;
         tMat = bB.m_xf.R;
         r2X = this.m_localAnchor2.x - bB.m_sweep.localCenter.x;
         r2Y = this.m_localAnchor2.y - bB.m_sweep.localCenter.y;
         tX = (tMat.col1.x * r2X + tMat.col2.x * r2Y);
         r2Y = (tMat.col1.y * r2X + tMat.col2.y * r2Y);
         r2X = tX;
         var CdotX = v2.x + ((-w2 * r2Y)) - v1.x - ((-w1 * r1Y));
         var CdotY = v2.y + (w2 * r2X) - v1.y - (w1 * r1X);
         this.m_mass.Solve22(this.impulse2, (-CdotX), (-CdotY));
         this.m_impulse.x += this.impulse2.x;
         this.m_impulse.y += this.impulse2.y;
         v1.x -= m1 * this.impulse2.x;
         v1.y -= m1 * this.impulse2.y;
         w1 -= i1 * (r1X * this.impulse2.y - r1Y * this.impulse2.x);
         v2.x += m2 * this.impulse2.x;
         v2.y += m2 * this.impulse2.y;
         w2 += i2 * (r2X * this.impulse2.y - r2Y * this.impulse2.x);
      }
      bA.m_linearVelocity.SetV(v1);
      bA.m_angularVelocity = w1;
      bB.m_linearVelocity.SetV(v2);
      bB.m_angularVelocity = w2;
   }
   b2RevoluteJoint.prototype.SolvePositionConstraints = function (baumgarte) {
      if (baumgarte === undefined) baumgarte = 0;
      var oldLimitImpulse = 0;
      var C = 0;
      var tMat;
      var bA = this.m_bodyA;
      var bB = this.m_bodyB;
      var angularError = 0.0;
      var positionError = 0.0;
      var tX = 0;
      var impulseX = 0;
      var impulseY = 0;
      if (this.m_enableLimit && this.m_limitState != b2Joint.e_inactiveLimit) {
         var angle = bB.m_sweep.a - bA.m_sweep.a - this.m_referenceAngle;
         var limitImpulse = 0.0;
         if (this.m_limitState == b2Joint.e_equalLimits) {
            C = b2Math.Clamp(angle - this.m_lowerAngle, (-b2Settings.b2_maxAngularCorrection), b2Settings.b2_maxAngularCorrection);
            limitImpulse = (-this.m_motorMass * C);
            angularError = b2Math.Abs(C);
         }
         else if (this.m_limitState == b2Joint.e_atLowerLimit) {
            C = angle - this.m_lowerAngle;
            angularError = (-C);
            C = b2Math.Clamp(C + b2Settings.b2_angularSlop, (-b2Settings.b2_maxAngularCorrection), 0.0);
            limitImpulse = (-this.m_motorMass * C);
         }
         else if (this.m_limitState == b2Joint.e_atUpperLimit) {
            C = angle - this.m_upperAngle;
            angularError = C;
            C = b2Math.Clamp(C - b2Settings.b2_angularSlop, 0.0, b2Settings.b2_maxAngularCorrection);
            limitImpulse = (-this.m_motorMass * C);
         }
         bA.m_sweep.a -= bA.m_invI * limitImpulse;
         bB.m_sweep.a += bB.m_invI * limitImpulse;
         bA.SynchronizeTransform();
         bB.SynchronizeTransform();
      } {
         tMat = bA.m_xf.R;
         var r1X = this.m_localAnchor1.x - bA.m_sweep.localCenter.x;
         var r1Y = this.m_localAnchor1.y - bA.m_sweep.localCenter.y;
         tX = (tMat.col1.x * r1X + tMat.col2.x * r1Y);
         r1Y = (tMat.col1.y * r1X + tMat.col2.y * r1Y);
         r1X = tX;
         tMat = bB.m_xf.R;
         var r2X = this.m_localAnchor2.x - bB.m_sweep.localCenter.x;
         var r2Y = this.m_localAnchor2.y - bB.m_sweep.localCenter.y;
         tX = (tMat.col1.x * r2X + tMat.col2.x * r2Y);
         r2Y = (tMat.col1.y * r2X + tMat.col2.y * r2Y);
         r2X = tX;
         var CX = bB.m_sweep.c.x + r2X - bA.m_sweep.c.x - r1X;
         var CY = bB.m_sweep.c.y + r2Y - bA.m_sweep.c.y - r1Y;
         var CLengthSquared = CX * CX + CY * CY;
         var CLength = Math.sqrt(CLengthSquared);
         positionError = CLength;
         var invMass1 = bA.m_invMass;
         var invMass2 = bB.m_invMass;
         var invI1 = bA.m_invI;
         var invI2 = bB.m_invI;
         var k_allowedStretch = 10.0 * b2Settings.b2_linearSlop;
         if (CLengthSquared > k_allowedStretch * k_allowedStretch) {
            var uX = CX / CLength;
            var uY = CY / CLength;
            var k = invMass1 + invMass2;
            var m = 1.0 / k;
            impulseX = m * ((-CX));
            impulseY = m * ((-CY));
            var k_beta = 0.5;
            bA.m_sweep.c.x -= k_beta * invMass1 * impulseX;
            bA.m_sweep.c.y -= k_beta * invMass1 * impulseY;
            bB.m_sweep.c.x += k_beta * invMass2 * impulseX;
            bB.m_sweep.c.y += k_beta * invMass2 * impulseY;
            CX = bB.m_sweep.c.x + r2X - bA.m_sweep.c.x - r1X;
            CY = bB.m_sweep.c.y + r2Y - bA.m_sweep.c.y - r1Y;
         }
         this.K1.col1.x = invMass1 + invMass2;
         this.K1.col2.x = 0.0;
         this.K1.col1.y = 0.0;
         this.K1.col2.y = invMass1 + invMass2;
         this.K2.col1.x = invI1 * r1Y * r1Y;
         this.K2.col2.x = (-invI1 * r1X * r1Y);
         this.K2.col1.y = (-invI1 * r1X * r1Y);
         this.K2.col2.y = invI1 * r1X * r1X;
         this.K3.col1.x = invI2 * r2Y * r2Y;
         this.K3.col2.x = (-invI2 * r2X * r2Y);
         this.K3.col1.y = (-invI2 * r2X * r2Y);
         this.K3.col2.y = invI2 * r2X * r2X;
         this.K.SetM(this.K1);
         this.K.AddM(this.K2);
         this.K.AddM(this.K3);
         this.K.Solve(b2RevoluteJoint.tImpulse, (-CX), (-CY));
         impulseX = b2RevoluteJoint.tImpulse.x;
         impulseY = b2RevoluteJoint.tImpulse.y;
         bA.m_sweep.c.x -= bA.m_invMass * impulseX;
         bA.m_sweep.c.y -= bA.m_invMass * impulseY;
         bA.m_sweep.a -= bA.m_invI * (r1X * impulseY - r1Y * impulseX);
         bB.m_sweep.c.x += bB.m_invMass * impulseX;
         bB.m_sweep.c.y += bB.m_invMass * impulseY;
         bB.m_sweep.a += bB.m_invI * (r2X * impulseY - r2Y * impulseX);
         bA.SynchronizeTransform();
         bB.SynchronizeTransform();
      }
      return positionError <= b2Settings.b2_linearSlop && angularError <= b2Settings.b2_angularSlop;
   }
   Box2D.postDefs.push(function () {
      Box2D.Dynamics.Joints.b2RevoluteJoint.tImpulse = new b2Vec2();
   });
   Box2D.inherit(b2RevoluteJointDef, Box2D.Dynamics.Joints.b2JointDef);
   b2RevoluteJointDef.prototype.__super = Box2D.Dynamics.Joints.b2JointDef.prototype;
   b2RevoluteJointDef.b2RevoluteJointDef = function () {
      Box2D.Dynamics.Joints.b2JointDef.b2JointDef.apply(this, arguments);
      this.localAnchorA = new b2Vec2();
      this.localAnchorB = new b2Vec2();
   };
   b2RevoluteJointDef.prototype.b2RevoluteJointDef = function () {
      this.__super.b2JointDef.call(this);
      this.type = b2Joint.e_revoluteJoint;
      this.localAnchorA.Set(0.0, 0.0);
      this.localAnchorB.Set(0.0, 0.0);
      this.referenceAngle = 0.0;
      this.lowerAngle = 0.0;
      this.upperAngle = 0.0;
      this.maxMotorTorque = 0.0;
      this.motorSpeed = 0.0;
      this.enableLimit = false;
      this.enableMotor = false;
   }
   b2RevoluteJointDef.prototype.Initialize = function (bA, bB, anchor) {
      this.bodyA = bA;
      this.bodyB = bB;
      this.localAnchorA = this.bodyA.GetLocalPoint(anchor);
      this.localAnchorB = this.bodyB.GetLocalPoint(anchor);
      this.referenceAngle = this.bodyB.GetAngle() - this.bodyA.GetAngle();
   }
   Box2D.inherit(b2WeldJoint, Box2D.Dynamics.Joints.b2Joint);
   b2WeldJoint.prototype.__super = Box2D.Dynamics.Joints.b2Joint.prototype;
   b2WeldJoint.b2WeldJoint = function () {
      Box2D.Dynamics.Joints.b2Joint.b2Joint.apply(this, arguments);
      this.m_localAnchorA = new b2Vec2();
      this.m_localAnchorB = new b2Vec2();
      this.m_impulse = new b2Vec3();
      this.m_mass = new b2Mat33();
   };
   b2WeldJoint.prototype.GetAnchorA = function () {
      return this.m_bodyA.GetWorldPoint(this.m_localAnchorA);
   }
   b2WeldJoint.prototype.GetAnchorB = function () {
      return this.m_bodyB.GetWorldPoint(this.m_localAnchorB);
   }
   b2WeldJoint.prototype.GetReactionForce = function (inv_dt) {
      if (inv_dt === undefined) inv_dt = 0;
      return new b2Vec2(inv_dt * this.m_impulse.x, inv_dt * this.m_impulse.y);
   }
   b2WeldJoint.prototype.GetReactionTorque = function (inv_dt) {
      if (inv_dt === undefined) inv_dt = 0;
      return inv_dt * this.m_impulse.z;
   }
   b2WeldJoint.prototype.b2WeldJoint = function (def) {
      this.__super.b2Joint.call(this, def);
      this.m_localAnchorA.SetV(def.localAnchorA);
      this.m_localAnchorB.SetV(def.localAnchorB);
      this.m_referenceAngle = def.referenceAngle;
      this.m_impulse.SetZero();
      this.m_mass = new b2Mat33();
   }
   b2WeldJoint.prototype.InitVelocityConstraints = function (step) {
      var tMat;
      var tX = 0;
      var bA = this.m_bodyA;
      var bB = this.m_bodyB;
      tMat = bA.m_xf.R;
      var rAX = this.m_localAnchorA.x - bA.m_sweep.localCenter.x;
      var rAY = this.m_localAnchorA.y - bA.m_sweep.localCenter.y;
      tX = (tMat.col1.x * rAX + tMat.col2.x * rAY);
      rAY = (tMat.col1.y * rAX + tMat.col2.y * rAY);
      rAX = tX;
      tMat = bB.m_xf.R;
      var rBX = this.m_localAnchorB.x - bB.m_sweep.localCenter.x;
      var rBY = this.m_localAnchorB.y - bB.m_sweep.localCenter.y;
      tX = (tMat.col1.x * rBX + tMat.col2.x * rBY);
      rBY = (tMat.col1.y * rBX + tMat.col2.y * rBY);
      rBX = tX;
      var mA = bA.m_invMass;
      var mB = bB.m_invMass;
      var iA = bA.m_invI;
      var iB = bB.m_invI;
      this.m_mass.col1.x = mA + mB + rAY * rAY * iA + rBY * rBY * iB;
      this.m_mass.col2.x = (-rAY * rAX * iA) - rBY * rBX * iB;
      this.m_mass.col3.x = (-rAY * iA) - rBY * iB;
      this.m_mass.col1.y = this.m_mass.col2.x;
      this.m_mass.col2.y = mA + mB + rAX * rAX * iA + rBX * rBX * iB;
      this.m_mass.col3.y = rAX * iA + rBX * iB;
      this.m_mass.col1.z = this.m_mass.col3.x;
      this.m_mass.col2.z = this.m_mass.col3.y;
      this.m_mass.col3.z = iA + iB;
      if (step.warmStarting) {
         this.m_impulse.x *= step.dtRatio;
         this.m_impulse.y *= step.dtRatio;
         this.m_impulse.z *= step.dtRatio;
         bA.m_linearVelocity.x -= mA * this.m_impulse.x;
         bA.m_linearVelocity.y -= mA * this.m_impulse.y;
         bA.m_angularVelocity -= iA * (rAX * this.m_impulse.y - rAY * this.m_impulse.x + this.m_impulse.z);
         bB.m_linearVelocity.x += mB * this.m_impulse.x;
         bB.m_linearVelocity.y += mB * this.m_impulse.y;
         bB.m_angularVelocity += iB * (rBX * this.m_impulse.y - rBY * this.m_impulse.x + this.m_impulse.z);
      }
      else {
         this.m_impulse.SetZero();
      }
   }
   b2WeldJoint.prototype.SolveVelocityConstraints = function (step) {
      var tMat;
      var tX = 0;
      var bA = this.m_bodyA;
      var bB = this.m_bodyB;
      var vA = bA.m_linearVelocity;
      var wA = bA.m_angularVelocity;
      var vB = bB.m_linearVelocity;
      var wB = bB.m_angularVelocity;
      var mA = bA.m_invMass;
      var mB = bB.m_invMass;
      var iA = bA.m_invI;
      var iB = bB.m_invI;
      tMat = bA.m_xf.R;
      var rAX = this.m_localAnchorA.x - bA.m_sweep.localCenter.x;
      var rAY = this.m_localAnchorA.y - bA.m_sweep.localCenter.y;
      tX = (tMat.col1.x * rAX + tMat.col2.x * rAY);
      rAY = (tMat.col1.y * rAX + tMat.col2.y * rAY);
      rAX = tX;
      tMat = bB.m_xf.R;
      var rBX = this.m_localAnchorB.x - bB.m_sweep.localCenter.x;
      var rBY = this.m_localAnchorB.y - bB.m_sweep.localCenter.y;
      tX = (tMat.col1.x * rBX + tMat.col2.x * rBY);
      rBY = (tMat.col1.y * rBX + tMat.col2.y * rBY);
      rBX = tX;
      var Cdot1X = vB.x - wB * rBY - vA.x + wA * rAY;
      var Cdot1Y = vB.y + wB * rBX - vA.y - wA * rAX;
      var Cdot2 = wB - wA;
      var impulse = new b2Vec3();
      this.m_mass.Solve33(impulse, (-Cdot1X), (-Cdot1Y), (-Cdot2));
      this.m_impulse.Add(impulse);
      vA.x -= mA * impulse.x;
      vA.y -= mA * impulse.y;
      wA -= iA * (rAX * impulse.y - rAY * impulse.x + impulse.z);
      vB.x += mB * impulse.x;
      vB.y += mB * impulse.y;
      wB += iB * (rBX * impulse.y - rBY * impulse.x + impulse.z);
      bA.m_angularVelocity = wA;
      bB.m_angularVelocity = wB;
   }
   b2WeldJoint.prototype.SolvePositionConstraints = function (baumgarte) {
      if (baumgarte === undefined) baumgarte = 0;
      var tMat;
      var tX = 0;
      var bA = this.m_bodyA;
      var bB = this.m_bodyB;
      tMat = bA.m_xf.R;
      var rAX = this.m_localAnchorA.x - bA.m_sweep.localCenter.x;
      var rAY = this.m_localAnchorA.y - bA.m_sweep.localCenter.y;
      tX = (tMat.col1.x * rAX + tMat.col2.x * rAY);
      rAY = (tMat.col1.y * rAX + tMat.col2.y * rAY);
      rAX = tX;
      tMat = bB.m_xf.R;
      var rBX = this.m_localAnchorB.x - bB.m_sweep.localCenter.x;
      var rBY = this.m_localAnchorB.y - bB.m_sweep.localCenter.y;
      tX = (tMat.col1.x * rBX + tMat.col2.x * rBY);
      rBY = (tMat.col1.y * rBX + tMat.col2.y * rBY);
      rBX = tX;
      var mA = bA.m_invMass;
      var mB = bB.m_invMass;
      var iA = bA.m_invI;
      var iB = bB.m_invI;
      var C1X = bB.m_sweep.c.x + rBX - bA.m_sweep.c.x - rAX;
      var C1Y = bB.m_sweep.c.y + rBY - bA.m_sweep.c.y - rAY;
      var C2 = bB.m_sweep.a - bA.m_sweep.a - this.m_referenceAngle;
      var k_allowedStretch = 10.0 * b2Settings.b2_linearSlop;
      var positionError = Math.sqrt(C1X * C1X + C1Y * C1Y);
      var angularError = b2Math.Abs(C2);
      if (positionError > k_allowedStretch) {
         iA *= 1.0;
         iB *= 1.0;
      }
      this.m_mass.col1.x = mA + mB + rAY * rAY * iA + rBY * rBY * iB;
      this.m_mass.col2.x = (-rAY * rAX * iA) - rBY * rBX * iB;
      this.m_mass.col3.x = (-rAY * iA) - rBY * iB;
      this.m_mass.col1.y = this.m_mass.col2.x;
      this.m_mass.col2.y = mA + mB + rAX * rAX * iA + rBX * rBX * iB;
      this.m_mass.col3.y = rAX * iA + rBX * iB;
      this.m_mass.col1.z = this.m_mass.col3.x;
      this.m_mass.col2.z = this.m_mass.col3.y;
      this.m_mass.col3.z = iA + iB;
      var impulse = new b2Vec3();
      this.m_mass.Solve33(impulse, (-C1X), (-C1Y), (-C2));
      bA.m_sweep.c.x -= mA * impulse.x;
      bA.m_sweep.c.y -= mA * impulse.y;
      bA.m_sweep.a -= iA * (rAX * impulse.y - rAY * impulse.x + impulse.z);
      bB.m_sweep.c.x += mB * impulse.x;
      bB.m_sweep.c.y += mB * impulse.y;
      bB.m_sweep.a += iB * (rBX * impulse.y - rBY * impulse.x + impulse.z);
      bA.SynchronizeTransform();
      bB.SynchronizeTransform();
      return positionError <= b2Settings.b2_linearSlop && angularError <= b2Settings.b2_angularSlop;
   }
   Box2D.inherit(b2WeldJointDef, Box2D.Dynamics.Joints.b2JointDef);
   b2WeldJointDef.prototype.__super = Box2D.Dynamics.Joints.b2JointDef.prototype;
   b2WeldJointDef.b2WeldJointDef = function () {
      Box2D.Dynamics.Joints.b2JointDef.b2JointDef.apply(this, arguments);
      this.localAnchorA = new b2Vec2();
      this.localAnchorB = new b2Vec2();
   };
   b2WeldJointDef.prototype.b2WeldJointDef = function () {
      this.__super.b2JointDef.call(this);
      this.type = b2Joint.e_weldJoint;
      this.referenceAngle = 0.0;
   }
   b2WeldJointDef.prototype.Initialize = function (bA, bB, anchor) {
      this.bodyA = bA;
      this.bodyB = bB;
      this.localAnchorA.SetV(this.bodyA.GetLocalPoint(anchor));
      this.localAnchorB.SetV(this.bodyB.GetLocalPoint(anchor));
      this.referenceAngle = this.bodyB.GetAngle() - this.bodyA.GetAngle();
   }
})();
(function () {
   var b2DebugDraw = Box2D.Dynamics.b2DebugDraw;
   b2DebugDraw.b2DebugDraw = function () {
      this.m_drawScale = 1.0;
      this.m_lineThickness = 1.0;
      this.m_alpha = 1.0;
      this.m_fillAlpha = 1.0;
      this.m_xformScale = 1.0;
      var __this = this;
      //#WORKAROUND
      this.m_sprite = {
         graphics: {
            clear: function () {
               __this.m_ctx.clearRect(0, 0, __this.m_ctx.canvas.width, __this.m_ctx.canvas.height)
            }
         }
      };
   };
   b2DebugDraw.prototype._color = function (color, alpha) {
      return "rgba(" + ((color & 0xFF0000) >> 16) + "," + ((color & 0xFF00) >> 8) + "," + (color & 0xFF) + "," + alpha + ")";
   };
   b2DebugDraw.prototype.b2DebugDraw = function () {
      this.m_drawFlags = 0;
   };
   b2DebugDraw.prototype.SetFlags = function (flags) {
      if (flags === undefined) flags = 0;
      this.m_drawFlags = flags;
   };
   b2DebugDraw.prototype.GetFlags = function () {
      return this.m_drawFlags;
   };
   b2DebugDraw.prototype.AppendFlags = function (flags) {
      if (flags === undefined) flags = 0;
      this.m_drawFlags |= flags;
   };
   b2DebugDraw.prototype.ClearFlags = function (flags) {
      if (flags === undefined) flags = 0;
      this.m_drawFlags &= ~flags;
   };
   b2DebugDraw.prototype.SetSprite = function (sprite) {
      this.m_ctx = sprite;
   };
   b2DebugDraw.prototype.GetSprite = function () {
      return this.m_ctx;
   };
   b2DebugDraw.prototype.SetDrawScale = function (drawScale) {
      if (drawScale === undefined) drawScale = 0;
      this.m_drawScale = drawScale;
   };
   b2DebugDraw.prototype.GetDrawScale = function () {
      return this.m_drawScale;
   };
   b2DebugDraw.prototype.SetLineThickness = function (lineThickness) {
      if (lineThickness === undefined) lineThickness = 0;
      this.m_lineThickness = lineThickness;
      this.m_ctx.strokeWidth = lineThickness;
   };
   b2DebugDraw.prototype.GetLineThickness = function () {
      return this.m_lineThickness;
   };
   b2DebugDraw.prototype.SetAlpha = function (alpha) {
      if (alpha === undefined) alpha = 0;
      this.m_alpha = alpha;
   };
   b2DebugDraw.prototype.GetAlpha = function () {
      return this.m_alpha;
   };
   b2DebugDraw.prototype.SetFillAlpha = function (alpha) {
      if (alpha === undefined) alpha = 0;
      this.m_fillAlpha = alpha;
   };
   b2DebugDraw.prototype.GetFillAlpha = function () {
      return this.m_fillAlpha;
   };
   b2DebugDraw.prototype.SetXFormScale = function (xformScale) {
      if (xformScale === undefined) xformScale = 0;
      this.m_xformScale = xformScale;
   };
   b2DebugDraw.prototype.GetXFormScale = function () {
      return this.m_xformScale;
   };
   b2DebugDraw.prototype.DrawPolygon = function (vertices, vertexCount, color) {
      if (!vertexCount) return;
      var s = this.m_ctx;
      var drawScale = this.m_drawScale;
      s.beginPath();
      s.strokeStyle = this._color(color.color, this.m_alpha);
      s.moveTo(vertices[0].x * drawScale, vertices[0].y * drawScale);
      for (var i = 1; i < vertexCount; i++) {
         s.lineTo(vertices[i].x * drawScale, vertices[i].y * drawScale);
      }
      s.lineTo(vertices[0].x * drawScale, vertices[0].y * drawScale);
      s.closePath();
      s.stroke();
   };
   b2DebugDraw.prototype.DrawSolidPolygon = function (vertices, vertexCount, color) {
      if (!vertexCount) return;
      var s = this.m_ctx;
      var drawScale = this.m_drawScale;
      s.beginPath();
      s.strokeStyle = this._color(color.color, this.m_alpha);
      s.fillStyle = this._color(color.color, this.m_fillAlpha);
      s.moveTo(vertices[0].x * drawScale, vertices[0].y * drawScale);
      for (var i = 1; i < vertexCount; i++) {
         s.lineTo(vertices[i].x * drawScale, vertices[i].y * drawScale);
      }
      s.lineTo(vertices[0].x * drawScale, vertices[0].y * drawScale);
      s.closePath();
      s.fill();
      s.stroke();
   };
   b2DebugDraw.prototype.DrawCircle = function (center, radius, color) {
      if (!radius) return;
      var s = this.m_ctx;
      var drawScale = this.m_drawScale;
      s.beginPath();
      s.strokeStyle = this._color(color.color, this.m_alpha);
      s.arc(center.x * drawScale, center.y * drawScale, radius * drawScale, 0, Math.PI * 2, true);
      s.closePath();
      s.stroke();
   };
   b2DebugDraw.prototype.DrawSolidCircle = function (center, radius, axis, color) {
      if (!radius) return;
      var s = this.m_ctx,
         drawScale = this.m_drawScale,
         cx = center.x * drawScale,
         cy = center.y * drawScale;
      s.moveTo(0, 0);
      s.beginPath();
      s.strokeStyle = this._color(color.color, this.m_alpha);
      s.fillStyle = this._color(color.color, this.m_fillAlpha);
      s.arc(cx, cy, radius * drawScale, 0, Math.PI * 2, true);
      s.moveTo(cx, cy);
      s.lineTo((center.x + axis.x * radius) * drawScale, (center.y + axis.y * radius) * drawScale);
      s.closePath();
      s.fill();
      s.stroke();
   };
   b2DebugDraw.prototype.DrawSegment = function (p1, p2, color) {
      var s = this.m_ctx,
         drawScale = this.m_drawScale;
      s.strokeStyle = this._color(color.color, this.m_alpha);
      s.beginPath();
      s.moveTo(p1.x * drawScale, p1.y * drawScale);
      s.lineTo(p2.x * drawScale, p2.y * drawScale);
      s.closePath();
      s.stroke();
   };
   b2DebugDraw.prototype.DrawTransform = function (xf) {
      var s = this.m_ctx,
         drawScale = this.m_drawScale;
      s.beginPath();
      s.strokeStyle = this._color(0xff0000, this.m_alpha);
      s.moveTo(xf.position.x * drawScale, xf.position.y * drawScale);
      s.lineTo((xf.position.x + this.m_xformScale * xf.R.col1.x) * drawScale, (xf.position.y + this.m_xformScale * xf.R.col1.y) * drawScale);

      s.strokeStyle = this._color(0xff00, this.m_alpha);
      s.moveTo(xf.position.x * drawScale, xf.position.y * drawScale);
      s.lineTo((xf.position.x + this.m_xformScale * xf.R.col2.x) * drawScale, (xf.position.y + this.m_xformScale * xf.R.col2.y) * drawScale);
      s.closePath();
      s.stroke();
   };
})(); //post-definitions
var i;
for (i = 0; i < Box2D.postDefs.length; ++i) Box2D.postDefs[i]();
delete Box2D.postDefs;
// export stuff
exports.Box2D=Box2D;
exports.b2AABB=Box2D.Collision.b2AABB;
exports.b2Vec2 = Box2D.Common.Math.b2Vec2;
exports.b2BodyDef = Box2D.Dynamics.b2BodyDef;
exports.b2Body = Box2D.Dynamics.b2Body;
exports.b2FixtureDef = Box2D.Dynamics.b2FixtureDef;
exports.b2Fixture = Box2D.Dynamics.b2Fixture;
exports.b2World = Box2D.Dynamics.b2World;
exports.b2MassData = Box2D.Collision.Shapes.b2MassData;
exports.b2PolygonShape = Box2D.Collision.Shapes.b2PolygonShape;
exports.b2CircleShape = Box2D.Collision.Shapes.b2CircleShape;
exports.b2DebugDraw = Box2D.Dynamics.b2DebugDraw;
exports.b2RevoluteJointDef = Box2D.Dynamics.Joints.b2RevoluteJointDef;
exports.b2PrismaticJointDef = Box2D.Dynamics.Joints.b2PrismaticJointDef;
exports.b2Transform=Box2D.Common.Math.b2Transform;
exports.b2WorldManifold=Box2D.Collision.b2WorldManifold;
},{}],11:[function(require,module,exports){
var log = require('./logging');
var box2d = require('./box2d');
var object = require('./object');
var utils = require('./utils');

var gamejs = require('gamejs');
var vectors = gamejs.utils.vectors;

var math = gamejs.utils.math;
var radians=math.radians;
var degrees=math.degrees;

var utils = require('./utils');
var arr = utils.arr;
var vec = utils.vec;

var Entity = exports.Entity = function(parameters){

    var par_list = [    
                        'position',
                        'size',
                        ['angle',           0],
                        ['max_health',      0],
                        ['fixed_rotation',  false],
                        ['density',         1],
                        ['restitution',     0.4],
                        ['friction',        0.3],
                        ['linear_damping',  0.15],
                        ['angular_damping', 0.3],
                        ['bullet',          false],
                        ['body_type',       box2d.b2Body.b2_dynamicBody],
                        ['sensor',          false],
                        ['alive',           true]
                   ];
               
    utils.process_parameters(parameters, par_list);
    
    Entity.superConstructor.apply(this, [parameters]);
    
    this.add_tag('entity');
    
    if(this.parameters.sensor) this.add_tag('sensor');
    else this.add_tag('solid');
    
    this.health = this.max_health = this.parameters.max_health;
    this.alive = this.parameters.alive;
    this.buffs = [];
    this._next_buff_id = 1;
    
    if(this.parameters.angle == undefined || this.parameters.angle == null) throw 'Invaldi angle';
    if(isNaN(this.parameters.position[0]) || isNaN(this.parameters.position[1])) throw 'Invalid position: '+this.parameters.position;
    
    this.initialize_body();
    
    gamejs.utils.objects.accessor(this, 'position', this.get_position, this.set_position);
    gamejs.utils.objects.accessor(this, 'angle',    this.get_angle,    this.set_angle); 
};

gamejs.utils.objects.extend(Entity, object.Object);

Entity.prototype.initialize_body = function() {
    var def = new box2d.b2BodyDef();
    def.type = this.parameters.body_type;
    def.position = vec(this.parameters.position);

    //QUIRK setting a rounded angle causes wobbling for a few moments
    // on this box2d version

    def.angle = radians(this.parameters.angle + 0.00001);
    def.linearDamping = this.parameters.linear_damping;
    def.angularDamping = this.parameters.angular_damping;
    def.bullet = this.parameters.bullet;
    def.fixedRotation = this.parameters.fixed_rotation;
    this.body = this.world._create_body(def);
    this.body.SetUserData(this);

    var fixdef = new box2d.b2FixtureDef();
    fixdef.density = this.parameters.density;
    fixdef.friction = this.parameters.friction;
    fixdef.isSensor = this.parameters.sensor;
    //friction when rubbing agaisnt other shapes
    fixdef.restitution = this.parameters.restitution;
    //amount of force feedback when hitting something. >0 makes the car bounce off, it's fun!
    fixdef.shape = this.initialize_shape();
    this.body.CreateFixture(fixdef);
};

Entity.prototype.initialize_shape = function (){
    var shape = new box2d.b2PolygonShape();
    shape.SetAsBox(this.parameters.size[0] / 2, this.parameters.size[1] / 2);
    return shape;
};

Entity.prototype.get_position = function(){
    return arr(this.body.GetPosition());
};

Entity.prototype.set_position = function(position){
    this.body.SetPosition(vec(position));
};

Entity.prototype.get_angle = function(){
    return degrees(this.body.GetAngle());
};

Entity.prototype.set_angle = function(angle){
    this.body.SetAngle(radians(angle));
};

Entity.prototype.set_linear_velocity = function(velocity) {
    this.body.SetLinearVelocity(vec(velocity));
};

Entity.prototype.get_linear_velocity = function(local_point){
    if(local_point){
        return arr(this.body.GetLinearVelocityFromLocalPoint(vec(local_point)));
    } else {
        return  arr(this.body.GetLinearVelocity());
    }
};
/*
 * 
 *speed in kilometers per hour
 * 
 */
Entity.prototype.set_speed = function(speed){
    velocity = vectors.multiply(vectors.unit(this.get_direction_vector()), ((speed*1000.0)/3600.0));
    this.set_linear_velocity(velocity);
};

Entity.prototype.impact = function(object, cpoint, direction){
      
};

Entity.prototype.destroy = function(){
    this.world.destroy(this);
};

Entity.prototype.apply_damage = function(damage, player){
    this.health -= damage;
    if(this.health < 0){
        this.die();
    }
};

Entity.prototype.get_world_point = function(local_point){
    return arr(this.body.GetWorldPoint(vec(local_point)));
};

Entity.prototype.get_local_point = function(world_point){
    return arr(this.body.GetLocalPoint(vec(world_point)));
};

Entity.prototype.get_world_vector = function(local_vector){
    return arr(this.body.GetWorldVector(vec(local_vector)));
};

Entity.prototype.get_local_vector = function(world_vector){
    return arr(this.body.GetLocalVector(vec(world_vector)));
};

Entity.prototype.get_local_velocity = function(local_point){
    if(local_point == undefined) local_point = [0, 0];
    return arr(this.body.GetLinearVelocityFromLocalPoint(vec(local_point)));
};

Entity.prototype.get_mass = function(){
    return this.body.GetMass();
};

Entity.prototype.get_sideways_vector = function(){
    return this.get_world_vector([-1, 0]);
};

Entity.prototype.get_direction_vector = function(){
    return vectors.rotate( (this.get_local_vector(this.get_local_velocity())[1]>0) ? [0, 1]:[0, -1] , this.body.GetAngle()) ;
};

Entity.prototype.get_backward_direction_vector = function(){
    return vectors.rotate( (this.get_local_velocity()[1]>0) ? [0, -1]:[0, 1] , this.body.GetAngle()) ;
};

Entity.prototype.get_world_center = function(){
    return arr(this.body.GetWorldCenter());
};

Entity.prototype.apply_force = function(local_force_vector, local_position){
    this.body.ApplyForce(vec(this.get_world_vector(local_force_vector)), vec(this.get_world_point(local_position)));
};

Entity.prototype.apply_impulse = function(force_vector, position) {
    this.body.ApplyImpulse(vec(force_vector), vec(position));
};
},{"./box2d":10,"./logging":13,"./object":14,"./utils":16,"gamejs":37}],12:[function(require,module,exports){


exports._next_class_id = 1;

exports._registered_classes = {};

exports.register_class = function(fn){
    exports._registered_classes[exports._next_class_id++] = fn;
};

exports.get_class_by_id = function(id){
    if(id in exports._registered_classes){
        return exports._registered_classes[id];
    }else{
        throw 'Unknown class for id: '% id;
    }
};

exports.get_id_by_class = function(fn){
    for(var id in exports._registered_classes){
        if(fn === exports._registered_classes[id]) return id;
    }
    throw 'No id for class!'
};

},{}],13:[function(require,module,exports){
var TYPE_WARNING = exports.TYPE_WARNING = 'warning';
var TYPE_ERROR = exports.TYPE_ERROR = 'error';

var Logger = exports.Logger = function (){
    
};

Logger.prototype.log = function (type, message){
    console.log(type, message);
}

exports.logger = new Logger();

exports.warning = function(message){
    exports.logger.log(TYPE_WARNING, message);
}

exports.error = function(message){
    exports.logger.log(TYPE_ERROR, message);
}

},{}],14:[function(require,module,exports){
var log = require('./logging');
var utils = require('./utils');

/*Base class for in game entities
 * 
 */

var Object = exports.Object = function(parameters){
    var parlist = ['world'];
    this.parameters = utils.process_parameters(parameters, parlist);
    
    this.id = this.parameters.id;
    this.world = this.parameters.world;
    this.world.objects[this.id] = this;
    this._tags = {};
};

Object.prototype.AM_OBJECT = true; //HAHAH IM A DUMBASS. srsly, dont know better way.


Object.prototype.add_tag = function(tag){
    this._tags[tag] = true;
};

Object.prototype.has_tag = function(tag){
    return this._tags[tag] ? true : false;
};

Object.prototype.update = function(ms_duration){
    
};

Object.prototype.draw = function(renderer){
    
};

Object.prototype.on_create = function(){

};

Object.prototype.destroy = function(){
    
};

Object.prototype.die = function(){
    
};



},{"./logging":13,"./utils":16}],15:[function(require,module,exports){

var object = require('./object');
var utils = require('./utils');
var gamejs = require('gamejs');
var _sounds = {};


var Sound = exports.Sound = function(filename) {
    this.audio = new gamejs.mixer.Sound(filename);
};

Sound.prototype.play = function(loop) {
    this.audio.play(loop ? true : false);
};

Sound.prototype.stop = function() {
    this.audio.stop();
};


var SoundObject = exports.SoundObject = function(pars){
       utils.process_parameters(pars, [ 'filename' , 
                                        ['loop', false],
                                        ['position', null]]);
       SoundObject.superConstructor.apply(this, [pars]);
};

gamejs.utils.objects.extend(SoundObject, object.Object);

exports.play = function(filename){
    _sounds[filename].play();
}

SoundObject.prototype.draw = function(renderer){
    var play = false;
    if(this.parameters.position){
        var screen_point = renderer.getScreenPoint(this.parameters.position);
        if(screen_point[0] > 0 && screen_point[0] < renderer.width 
           && screen_point[1] >0 && screen_point[1] < renderer.height){
               play = true;
           }
    } else{
        play = true;
    }
    if(play) _sounds[this.parameters.filename].play(this.parameters.loop);
    this.world.destroy(this);
};

var engine = require('../engine');

engine.register_class(SoundObject);

engine.initialize_sounds = exports.initialize = function(list_of_filenames){
    list_of_filenames.forEach(function(filename){
        _sounds[filename] = new Sound(filename); 
    });
};



},{"../engine":9,"./object":14,"./utils":16,"gamejs":37}],16:[function(require,module,exports){
var box2d = require('./box2d');

var vec = exports.vec = function(){
    if(!(arguments.length && arguments[0].hasOwnProperty('x'))){
        if(arguments.length==1) return new box2d.b2Vec2(arguments[0][0], arguments[0][1]);
        else if(arguments.length==2) return new box2d.b2Vec2(arguments[0], arguments[1]);
        else throw "kablooie"
    }else return arguments[0];
};

var arr = exports.arr = function(vect){
    if(vect.hasOwnProperty('x')) return [vect.x, vect.y];
    return vect;
};

exports.process_parameters = function(parameters, parameter_list){
    parameter_list.forEach(function(parameter){
        var name, default_value = undefined;
        if(parameter instanceof Array){
            name = parameter[0];
            if(parameter.length > 1){
                default_value = parameter[1];
            }
        } else {
            name = parameter;
        }
        
        if(!(name in parameters)){
            if(default_value != undefined){
                parameters[name] = default_value;
            } else {
                throw 'Missing parameter: '+name;   
            }
        }
    });
    return parameters;
};

var copy = exports.copy = function(src, dest){
    for(var attr in src) dest[attr] = src[attr];
    return dest;
};
},{"./box2d":10}],17:[function(require,module,exports){
var box2d = require('./box2d');
var game = require('./game');
var sound = require('./sound');

var gamejs = require('gamejs');
var vectors = gamejs.utils.vectors;

var math = gamejs.utils.math;
var radians=math.radians;
var degrees=math.degrees;

var utils = require('./utils');
var arr = utils.arr;
var vec = utils.vec;


var ContactListener = function(world) {
    this.world = world;
    this.BeginContact = function(cpoint) {
        var body1 = cpoint.GetFixtureA().GetBody();
        var body2 = cpoint.GetFixtureB().GetBody();
        var obj1 = body1.GetUserData();
        var obj2 = body2.GetUserData();
        if(obj1 && obj2) {
            var manifold = new box2d.b2WorldManifold();
            cpoint.GetWorldManifold(manifold);
            var normal = arr(manifold.m_normal);
            world._register_impact(obj1, obj2, cpoint, normal);
            world._register_impact(obj2, obj1, cpoint, vectors.rotate(normal, radians(180)));
        }
    };

    this.EndContact = function() {
    };
    this.PreSolve = function() {
    };
    this.PostSolve = function() {
    };
    return this;
};



var World = exports.World = function(parameters){
    this._next_object_id = 0;
    this._next_event_id = 0;
    
    this._events = {};
    this._impacts = [];
    this.objects = {};
    this.objects_by_tag= {};
    
 
    var parlist = [['gravity', [0, 0]]];


    utils.process_parameters(parameters, parlist);
    
    this.parameters = parameters;
    
    this.b2world=new box2d.b2World(vec(parameters.gravity), false);
    this.b2world.SetContactListener(new ContactListener(this));
};

World.prototype._register_impact = function(obj1, obj2, cpoint, normal){
    this._impacts.push([obj1, obj2, cpoint, normal]);
};

World.prototype._process_impacts = function(){
    while(this._impacts.length){
        var d = this._impacts.pop();
        d[0].impact(d[1], d[2], d[3]);
    };
    
    this._impacts = [];
};


World.prototype._register_event = function(event_type, parameters){
    var event = {
                    'type':event_type,
                    'data':parameters,
                    'id':this._next_event_id++
    };
    
   // this._events[event.id] = event;
    
    //TODO: multiplayerify
    return this._process_event(event);
    
};

World.prototype._create_body = function(def){
    return this.b2world.CreateBody(def);
};

World.prototype._destroy_body = function(body){
    this.b2world.DestroyBody(body);
};

World.prototype._process_event = function(event) {
    if(event.type == 'create') {
        var pars = utils.copy(event.data, {});
        pars.world = this;
        pars.id = this._next_object_id++;
        for(var key in pars) {
            if((pars[key] + '').search('_o_') == 0) {
                var id = parseInt(pars[key].replace('_o_', ''));
                pars[key] = this.get_object(id);
            }
        }
        var fn = game.get_class_by_id(pars.class_id);
        var obj = new fn(pars);
        for(var tag in obj._tags) {
            if(!this.objects_by_tag[tag]) {
                this.objects_by_tag[tag] = [];
            }
            this.objects_by_tag[tag].push(obj);
        }
        obj.on_create();
        return obj;
    } else {
        this._destroy(this.get_object(event.data));
    }
};

World.prototype.get_object = function(id){
    var retv = this.objects[id];
    if(! retv) throw 'Uh oh. Unknown object id= '+id;
    return retv;
};

World.prototype.get_objects_by_tag = function(tag){
    if(this.objects_by_tag[tag]) return this.objects_by_tag[tag];
    return [];
};

World.prototype._destroy = function(obj){
    obj.die();
    delete this.objects[obj.id];
    
    //remove impacts for this object
    var n_impacts = [];
    this._impacts.forEach(function(impact){
        if(!(impact[0].id == obj.id || impact[1].id == obj.id )){
            n_impacts.push(impact);
        }
    });
    this._impacts = n_impacts;
    
    if(obj.body) this._destroy_body(obj.body);
    for(var tag in obj._tags){
        for(var i = 0; i < this.objects_by_tag[tag].length; i++) {
            if(this.objects_by_tag[tag][i].id == obj.id) {
                this.objects_by_tag[tag].splice(i, 1);
                break;
            }
        }
    }
};

World.prototype.create = function(fn, parameters){
    parameters.class_id = game.get_id_by_class(fn);
    for (var key in parameters){
        if(parameters[key] && parameters[key].AM_OBJECT){
            parameters[key] = '_o_' + parameters[key].id;
        }
    }
    return this._register_event('create', parameters);
};

World.prototype.destroy = function(entity){
    this._register_event('destroy', entity.id);
};

World.prototype.update = function(msDuration){
    this._process_impacts();
    for(var id in this.objects){
        this.objects[id].update(msDuration);
    }
};

World.prototype.draw = function(renderer){
    for(var id in this.objects){
        var obj = this.objects[id];
        obj.draw(renderer);
    }
};

World.prototype.play_sound = function(filename, position){
    this.create(sound.SoundObject, {'filename':filename, 'position':position});
};

},{"./box2d":10,"./game":12,"./sound":15,"./utils":16,"gamejs":37}],18:[function(require,module,exports){
var gamejs = require('gamejs');
var draw=gamejs.draw;

var EVT_FOCUS = exports.EVT_FOCUS = 'focus';
var EVT_BLUR = exports.EVT_BLUR = 'blur';
var EVT_MOUSE_OVER = exports.EVT_MOUSE_OVER = 'mouse_over';
var EVT_MOUSE_OUT = exports.EVT_MOUSE_OUT = 'mouse_out';
var EVT_KEY_DOWN = exports.EVT_KEY_DOWN= gamejs.event.KEY_DOWN;
var EVT_KEY_UP = exports.EVT_KEY_UP = gamejs.event.KEY_UP;
var EVT_MOUSE_UP = exports.EVT_MOUSE_UP = gamejs.event.MOUSE_UP;
var EVT_MOUSE_DOWN = exports.EVT_MOUSE_DOWN = gamejs.event.MOUSE_DOWN;
var EVT_MOUSE_WHEEL = exports.EVT_MOUSE_WHEEL = gamejs.event.MOUSE_WHEEL;
var EVT_MOUSE_MOTION = exports.EVT_MOUSE_MOTION = gamejs.event.MOUSE_MOTION;
var EVT_BTN_CLICK = exports.EVT_BTN_CLICK = 'btn_click';
var EVT_CLOSE = exports.EVT_CLOSE = 'close';
var EVT_SCROLL = exports.EVT_SCROLL = 'scroll';
var EVT_DRAG = exports.EVT_DRAG = 'drag';
var EVT_MOVE = exports.EVT_MOVE = 'move';
var EVT_RESIZE = exports.EVT_RESIZE = 'resize';
var EVT_PAINT = exports.EVT_PAINT = 'paint';
var EVT_AFTER_PAINT = exports.EVT_AFTER_PAINT = 'after_paint';
var EVT_CHANGE = exports.EVT_CHANGE = 'change'; //input change for input elements
var DEFAULT_FONT_DESCR='14px Verdana';
var gamejs_ui_next_id=1;


/**
 *@ignore
 */
function cloneEvent(evt, offset){
    var new_evt={};
    for(key in evt){
        new_evt[key]=evt[key];
    }
    if(new_evt.pos && offset){
        new_evt.pos=[new_evt.pos[0]-offset[0], new_evt.pos[1]-offset[1]];
    }
    return new_evt; 
}

/**
 *@ignore
 */
function getCenterPos(size1, size2){
    return [Math.max(parseInt((size1[0]-size2[0])/2), 0),
            Math.max(parseInt((size1[1]-size2[1])/2), 0)];
}

/**
 *Make a view draggable within it's parent. Dragging generates EVT_DRAG
 *@function
 *@param {View} view view to make draggable.
 */
var draggable=exports.draggable=function(view){
    view.grab_pos=null;
    view.on(EVT_MOUSE_DOWN, function(event){
        this.grab_pos=event.global_pos;
    }, view);
    view.getGUI().on(EVT_MOUSE_UP, function(event){
        this.grab_pos=null;
    }, view);
    
    view.getGUI().on(EVT_MOUSE_MOTION, function(event){
        if(this.grab_pos){
            var old_position=this.position;

            var new_position=[this.position[0]+event.pos[0]-this.grab_pos[0],
                              this.position[1]+event.pos[1]-this.grab_pos[1]];
            

            this.grab_pos=event.pos;
            this.move(new_position);
            this.despatchEvent({'type':EVT_DRAG,
                                'old_pos':old_position,
                                'new_pos':this.position});
        }
    }, view);
};

/**
 *implements lazy caching for individual letters
 *@class cached font
 *@constructor
 *
 *@param {String|Array} font either font description as string, or assoc array character:gamejs.Surface
 *@param {String} color a valid #RGB String, "#ffcc00"
 *
 *@property {Number} space_width space between lettersin pixels. Default 'm' width divided by 3
 *@property {Number} tab_width tab width in pixels. Default 3*space_width
 *@property {gamejs.font.Font} font font object used to render characters. Default 14px Verdana
 */
var CachedFont=exports.CachedFont=function(font, color){
    this.space_width=3;
    this.tab_width=12;
    this.chars={}; //character:surface;
    this.font=null;
    if((typeof font)=='string'){
        color = color ? color : '#000';
        this.color=color;
        this.font=new gamejs.font.Font(font);
        
    }else{
        this.chars=font;
        this.font=new gamejs.font.Font(DEFAULT_FONT_DESCR);
        this.color='#000';
    }
    //space width - 1/3 of m's width
    this.space_width=parseInt(Math.ceil(this.getCharSurface('m').getSize()[0]/3));
    this.tab_width=3*this.space_width;
};


/**
 *returns gamejs.Surface for a character. Caches this surface if it is not cached
 *
 *@function
 *@param {String} c single character
 *
 *@returns {gamejs.Surface} surface object with the character painted on. Not a copy, don't paint on it!
 */
CachedFont.prototype.getCharSurface=function(c){
    if(!this.chars[c]){
        var s=this.font.render(c, this.color);
        this.chars[c]=s;
    }
    return this.chars[c];
};

/**
 *get size text would occupy if it was rendered
 *@function
 *
 *@param {String} text
 *
 *@returns {Array} size, eg. [width, height]
 */
CachedFont.prototype.getTextSize=function(text){
    var w=0, h=0, c, l, sz;
    if(text){ 
        for(var i=0;i<text.length;i++){
            c=text[i];
            if(c==' ')w+=this.space_width;
            else if(c=='\t')w+=this.tab_width;
            else{
                l=this.getCharSurface(c);
                if(l){
                    sz=l.getSize();
                    w+=sz[0];
                    h=Math.max(sz[1], h);
                }
            }
        }
        if(!h) h=this.getCharSurface('m').getSize()[1];
        return [w, h];
    }else return [0, 0];
};

/**
 *render text on a surface
 *@function
 *
 *@param {gamejs.Surface} surface surface to render text on
 *@param {String} text text to render
 *@param {Array} position position to render the text at
 *@param {Number} space_width OPTIONAL, override space width
 */
CachedFont.prototype.render=function(surface, text, position, space_width){
    ofst=position[0];
    space_width=space_width? space_width : this.space_width;
    var i, c, s;
    for(i=0;i<text.length;i++){
        c=text[i];
        if(c==' ')ofst+=space_width;
        else if(c=='\t')ofst+=this.tab_width;
        else{
            s=this.getCharSurface(c);
            r1=[ofst, position[1]];
            surface.blit(s, r1);
            ofst+=s.getSize()[0];
        }
    }        
};

try{
    exports.DEFAULT_FONT=new CachedFont('12px Verdana', 'black');
}catch(e){
    
}

/**
 *View
 *@class base gui object !CONSTRUCTOR PARAMETERS ARE PROVIDED IN A OBJECT LITERAL!
 *@constructor
 *
 *@param {View} parent parent element
 *@param {Array} size  array containing width & height of the element, eg. [width, height]
 *@param {Array} position position of the view relative to parent, eg. [x, y]. OPTIONAL, default [0, 0]
 *@param {gamejs.Surface} surface surface to render this view on, OPTIONAL
 *@param {Bool} visible is this view visible? default true
 *
 *@property {Array} size view size, [width, length]
 *@property {Array} position view position relative to parent, [x, y]
 *@property {gamejs.Surface} surface surface this view is rendered on
 *@property {View} parent parent view of this view
 *@property {Array} children array of this views children views
 */
var View=exports.View=function(pars){
    this.type='view';
    this.id=gamejs_ui_next_id++;
    if(!pars.size) throw "View: size must be specified"
    this.size=pars.size;
    if(!pars.position) pars.position=[0, 0];
    this.position=[parseInt(pars.position[0]), parseInt(pars.position[1])];
    this.surface=pars.surface ? pars.surface : new gamejs.Surface(this.size);
    if(pars.parent===undefined) throw "Element's parent not given."
    this.parent=pars.parent;
    if(pars.visible===undefined){
        this.visible=true;
    }else{
        this.visible=pars.visible;
    }
    if(this.parent) this.parent.addChild(this);
    
    this.children=[];
    this._refresh=true;
    
    //is the mouse over this view?
    this.is_hovered=false;
    
    //is this view focused?
    this.is_focused=false;
    
    //evenet type: [{'callback':x, 'scope':y, ...]
    this.listeners={};
    return this;
    
};

/*
 *get is focus state
 *@function
 *@returns {Bool} is this view focused?
 */
View.prototype.isFocused=function(){
    return this.is_focused;  
};

/**
 *get hover state
 *@function
 *@returns {Bool} is mouse hovering on this element?
 */
View.prototype.isHovered=function(){
    return this.is_hovered;  
};
/**
 *get view size
 *@function
 *@returns {Array} view size, [width, height]
 */
View.prototype.getSize=function(){
    return [this.size[0], this.size[1]];
};

/**
 *get view position within it's parent element
 *@function
 *@returns {Array} view position within it's parent element, [x, y]
 */
View.prototype.getPosition=function(){
    return [this.position[0], this.position[1]];
};

/**
 *get visible state
 *@function
 *@returns {Bool} is this view visible?
 */

View.prototype.isVisible=function(){
  return this.visible;
};

/**
 *detaches a child from this view
 *@function
 *@param {View|Number} child View or or child View id.
 */
View.prototype.removeChild=function(child){
    if(typeof(child)!='number')child=child.id;
    for(var i=0;i<this.children.length;i++){
        if(this.children[i].id==child){
            child=this.children.splice(i, 1);
            this.refresh();
            return true;
        }
    }
    return false;
}

/**
 *detaches view from it's parent, effectively destroying it
 *@function
 */
View.prototype.destroy=function(){
    if(this.parent)this.parent.removeChild(this);
}

/**
 *get position & size rect
 *@returns gamejs.Rect instance. Position is relative to parent
 */
View.prototype.getRect=function(){
    return new gamejs.Rect(this.position, this.size);  
};

/**
 *right align element to this x coordinate
 *@function
 *@param {Number} x xcoordinate
 */
View.prototype.rightAlign=function(x){
    this.move([x-this.getSize()[0], this.getPosition()[1]]);
};

/**
 *add child to this view
 *@param {View} child view to add as a child of this view
 */
View.prototype.addChild=function(child){
    this.children.push(child);
};

/**
 *if needed, paints this view, draws children and coposites them on this views surface
 *@function
 *@returns {Bool} has this view been repainted
 */
View.prototype.draw=function(){
    if(!this.visible){
        if(this._refresh){
            this._refresh=false;
            return true;
        }
        return false;
    }
    
    var painted=false; //has something been repainted in this view?
    //does this view need repainting?
  
    this.children.forEach(function(child){
        //draw children if this view has been repainted or child has been repainted
        if(child.draw() || this._refresh){
            painted=true;
        }
    }, this);
    
    if(this._refresh || painted){
        this.paint();
        this.despatchEvent({'type':EVT_PAINT, 'surface':this.surface});
        this.children.forEach(function(child){
            if(child.visible) this.blitChild(child);
        }, this)
        this.despatchEvent({'type':EVT_AFTER_PAINT, 'surface':this.surface});
        painted=true;
        this._refresh=false;
    }
    
    return painted;
};
/**
 *blit child's surface on this view's surface
 *@function
 *@param {View} child child view to blit
 */
View.prototype.blitChild=function(child){
    this.surface.blit(child.surface, child.position);
};

/**
 *paint this view on it's surface. does not repaint/blit children! override this to implement custom drawing of the element itself. by default, only clears the surface
 *@function
 */
View.prototype.paint=function(){
    this.surface.clear();
};


/**
 *update view. does nothing by default
 *@function
 *@param {Number} miliseconds since last update
 */
View.prototype.update=function(msDuration){};

/**
 *recursively calls _update on this views children, then calls update for this view.
 *@ignore
 */
View.prototype._update=function(msDuration){
    this.children.forEach(function(child){
        child._update(msDuration);        
    });
    this.update(msDuration);
};

/**
 *register a callback for an event. When event is triggered, callback is called with event object as argument
 *@function
 *@param {Event ID} event event ID of the event to be registered on, eg gamejs-gui.EVT_BLUR, gamejs-gui.EVT_KEY_DOWN, etc.
 *@param {Function} callback function to call when event is triggered
 *@param {Object} scope - this object for the callback
 */
View.prototype.on=function(event_type, callback, scope){
    if(!this.listeners[event_type])this.listeners[event_type]=[];
    this.listeners[event_type].push({'callback':callback, 'scope':scope});
};

/**
 *despatches event to all children. internal
 *@ignore
 */
View.prototype.despatchEventToChildren= function(event){
    this.children.forEach(function(child){child.despatchEvent(event);});
};

/**
 *Move view relative to its parent. Generates EVT_MOVE event
 *@function
 *@param {Array} new position relative to parent element, eg. [x, y]
 */
View.prototype.move=function(position){
    var old_position=this.position;
    this.position=position;
    this.parent.refresh();
    this.despatchEvent({'type':EVT_MOVE,
                       'old_pos':old_position,
                       'new_pos':position});
};

/**
 *Move view relative to its position. Generates EVT_MOVE event
 *@function
 *@param {Array} delta coordinates relative to current position ,eg. [delta x, delta y]
 */
View.prototype.moveRelative=function(position){
    this.move([this.position[0]+position[0], this.position[1]+position[1]]);  
};  

/**
 *Resize this view. Generates EVT_RESIZE event
 *@function
 *@param {Array} new size, eg. [width, height]
 */
View.prototype.resize=function(size){
    var old_size=this.size;
    this.size=size;
    this.surface=new gamejs.Surface([Math.max(size[0], 1), Math.max(size[1], 1)]);
    this.refresh();
    this.despatchEvent({'type':EVT_RESIZE,
                       'old_size':old_size,
                       'new_size':size});
};

/**
 *Redraw this view and its children.
 *@function
 */
View.prototype.refresh=function(){
    this._refresh=true;
};

/**
 *If this view is hidden, make it visible
 *@function
 */
View.prototype.show=function(){
    if(!this.visible){
        this.visible=true;
        this.refresh();
    }
};

/**
 *If this view is visible, hide it. This also blurs and mouse-outs the view, if applicable
 *@function
 */
View.prototype.hide=function(){
    if(this.visible){
        this.despatchEvent({'type':EVT_BLUR});
        this.despatchEvent({'type':EVT_MOUSE_OUT});
        this.visible=false;
        this.refresh();
    }
};

/**
 *Despatch event to this view. Event is despatched to children if applicable, then handled by this view.
 *@function
 *@param {Event} event event to despatch
 */
View.prototype.despatchEvent=function(event){
    if(!this.visible) return;
    var inside=false; //event position inside this view
    
    if(event.type==EVT_BLUR){
        if(this.is_focused){
            this.is_focused=false;
            this.refresh();
            this.handleEvent(event);
        }
        this.despatchEventToChildren(event);
    }
    else if(event.type==EVT_MOUSE_OUT){
        if(this.is_hovered){
            this.is_hovered=false;
            this.refresh();
            this.handleEvent(event);
        }
        this.despatchEventToChildren(event);
    }
    else if(event.type==EVT_MOUSE_OVER){
        this.is_hovered=true;
        this.refresh();
        this.handleEvent(event);
    }
    
    else if(event.type==EVT_FOCUS){
        this.is_focused=true;
        this.refresh();
        this.handleEvent(event);
    }
    
    else if(event.type==EVT_MOUSE_DOWN){
        if(!this.isFocused()){
            this.despatchEvent({'type':EVT_FOCUS});
        }
        this.children.forEach(function(child){
            //click inside child: despatch
            if(child.getRect().collidePoint(event.pos)){
                child.despatchEvent(cloneEvent(event, child.position));
            }else{
                //not inside, but child is focused: blur
                if(child.isFocused()) child.despatchEvent({'type':EVT_BLUR});
            }
        }, this);
        this.handleEvent(event);
    }
    
    else if(event.type==EVT_MOUSE_UP){
        this.children.forEach(function(child){
            //click inside child: despatch
            if(child.getRect().collidePoint(event.pos)){
                child.despatchEvent(cloneEvent(event, child.position));
            }
        }, this);
        this.handleEvent(event);
    }
    
    else if(event.type==EVT_MOUSE_MOTION){
        
        //mouse moved onto this view - hover
        this.children.forEach(function(child){
            //click inside child: despatch
            if(child.getRect().collidePoint(event.pos)){
                //inside, not hovering: hover
                if(!child.isHovered()) child.despatchEvent(cloneEvent({'type':EVT_MOUSE_OVER, 'pos':event.pos}, child.position));
                child.despatchEvent(cloneEvent(event, child.position));
            }else{
                //not inside, but child is focused: blur
                if(child.isHovered()) child.despatchEvent(cloneEvent({'type':EVT_MOUSE_OUT, 'pos':event.pos}, child.position));
            }
        }, this);
        this.handleEvent(event);
        
    }
    else if(event.type==EVT_KEY_UP || event.type==EVT_KEY_DOWN || event.type==EVT_KEY_UP){
        if(this.isFocused()){     
            this.children.forEach(function(child){
                if(child.isFocused()) child.despatchEvent(cloneEvent(event));
            });
            this.handleEvent(event);
        }
    //default
    }else{
        this.handleEvent(event);
    }

};

/**
 *returns GUI object at the base of this views branch
 *@function
 *@returns {GUI} GUI object at the base if this views branch
 */
View.prototype.getGUI=function(){
    var parent=this.parent;
    while(parent!=null && parent.type!='gui'){
        parent=parent.parent;
    }
    return parent;
};

/**
 *Center a child view within this view. Must be direct child
 *@function
 *@param {View} child child view
 */
View.prototype.center=function(child){
    child.move(getCenterPos(this.size, child.size));   
};

/**
 *execute any registered callbacks for this event. Should only be called by despatchEvent!
 *@ignore
 */
View.prototype.handleEvent=function(event){
    if(this.listeners[event.type]){
        this.listeners[event.type].forEach(function(listener){
            if(listener.scope) listener.callback.apply(listener.scope, [event, this]);
            else listener.callback(event, this);
        });
    }
};

/**
 *@class single-line text display !CONSTRUCTOR PARAMETERS ARE PROVIDED IN A OBJECT LITERAL!
 *@augments View
 *@constructor 
 *
 *@param {CachedFont} font font to draw text with. OPTIONAL, default gamejs-gui.DEFAULT_FONT
 *@param {String} text text to draw
 *@param {View} parent parent element
 *@param {Array} position position of the view relative to parent, eg. [x, y]. OPTIONAL, default [0, 0]
 *@param {gamejs.Surface} surface surface to render this view on, OPTIONAL
 *@param {Bool} visible is this view visible? OPTIONAL, EFAULT true
 *
 *resized automatically to house text.
 *
 *@property {CachedFont} font
 *@property {String} text

 */

var Label=exports.Label=function(pars){
    this.font=pars.font ? pars.font : exports.DEFAULT_FONT;
    pars.size=[1, 1];
    Label.superConstructor.apply(this, [pars]);
    if((pars.text == undefined)|| (pars.text == null)) throw "Label: label text must be provided!"
    this.setText(String(pars.text));
    this.type='label'; 
};

gamejs.utils.objects.extend(Label, View);

/**
 *set new text for this label. Resizes the view automatically.
 *@function
 *
 *@param {String} text new text
 */
Label.prototype.setText=function(text){
    this.text=String(text) ? String(text) : ' ';
    this.size=this.font.getTextSize(text);
    this.resize(this.size);
};

/***
 *paint implementation for label. clears surface and renders text
 *@function
 */
Label.prototype.paint=function(){
    this.surface.clear();
    this.font.render(this.surface, this.text, [0, 0]);
};

/**
 *@class button !CONSTRUCTOR PARAMETERS ARE PROVIDED IN A OBJECT LITERAL!
 *@augments View
 *
 *@param {gamejs.Surface} image button image, OPTIONAL
 *@param {gamejs.Surface} image_down button image when pressed down, OPTIONAL
 *@param {gamejs.Surface} image_hover button image when hovered on, OPTIONAL
 *@param {String} text text to display on button, OPTIONAL
 *@param {CachedFont} font to render text with, OPTIONAL
 *@param {View} parent parent element
 *@param {Array} size  array containing width & height of the element, eg. [width, height]
 *@param {Array} position position of the view relative to parent, eg. [x, y]. OPTIONAL, default [0, 0]
 *@param {gamejs.Surface} surface surface to render this view on, OPTIONAL
 *@param {Bool} visible is this view visible? default true
 *
 *@property {String} text
 *@property {CachedFont} font
 *@property {Label} label  Label obejct, created if text was provided.
 */

var Button=exports.Button=function(pars){
    Button.superConstructor.apply(this, [pars]);
    this.type='button';
    this.image=null;
    this.label=null;
    this.image=pars.image;
    this.image_down=pars.image_down;
    this.image_hover=pars.image_hover;
    
    if(!this.image){
        this.image=new gamejs.Surface(this.size);
        this.image.fill('#FFF');
        gamejs.draw.rect(this.image, '#808080', new gamejs.Rect([0, 0], this.size), 1);
    }
    
    if(pars.text){     
        this.label=new Label({'parent':this,
                             'position':[0, 0],
                             'text':pars.text,
                             'font':pars.font});
        this.center(this.label);
    }
    
    this.pressed_down=false;
    this.on(EVT_MOUSE_DOWN, function(){
        if(!this.pressed_down){
            this.pressed_down=true;
            this.refresh();
        }
    }, this);
    
    this.on(EVT_MOUSE_UP, function(){
        if(this.pressed_down){
            this.pressed_down=false;
            this.despatchEvent({'type':EVT_BTN_CLICK});
            this.refresh();
        }
    }, this);
    
    this.on(EVT_MOUSE_OUT, function(){
        if(this.pressed_down){
            this.pressed_down=false;
            this.refresh();
        }
    }, this)
};

gamejs.utils.objects.extend(Button, View);

/**
 *short hand for on(EVT_BTN_CLICK, callback, scope)
 *@function
 *
 *@param {Function} callback function to call when EVT_BTN_CLICK event is triggered
 *@param {Object} scope this object for callback, OPTIONAL
 */
Button.prototype.onClick=function(callback, scope){
    this.on(EVT_BTN_CLICK, callback, scope);
};

/**
 *default button paint implementation paints image, image_down or image_hover based on button sotate
 *@function
 */
Button.prototype.paint=function(){
    var img;
    if(this.pressed_down && this.image_down) img=this.image_down;
    else if(this.isHovered() && this.image_hover) img=this.image_hover;
    else img=this.image;
    this.surface.blit(img, new gamejs.Rect([0, 0], this.surface.getSize()), new gamejs.Rect([0, 0], img.getSize()));
    
};

/**
 *set button text
 *@function
 *@param {String} text
 */
Button.prototype.setText=function(text){
    if(this.label){
        this.label.setText(text);
        this.center(this.label);
    }
};

/**
 *@class image !CONSTRUCTOR PARAMETERS ARE PROVIDED IN A OBJECT LITERAL!
 *@augments View
 *
 *@param {gamejs.Surface} image to paint
 *@param {View} parent parent element
 *@param {Array} size  array containing width & height of the element, eg. [width, height]
 *@param {Array} position position of the view relative to parent, eg. [x, y]. OPTIONAL, default [0, 0]
 *@param {gamejs.Surface} surface surface to render this view on, OPTIONAL
 *@param {Bool} visible is this view visible? OPTIONAL, DEFAULT true
 *
 *@property {gamejs.Surface} image
 */

var Image=exports.Image=function(pars){
    if(!pars.image) throw 'Image: parameter image is required';
    if(!pars.size) pars.size=pars.image.getSize();
    this.image=pars.image;
    Image.superConstructor.apply(this, [pars]);
    this.type='image';
    return this;
};

gamejs.utils.objects.extend(Image, View);

/**
 *set new image
 *@function
 *@param {gamejs.Surface} image
 */
Image.prototype.setImage=function(image){
    this.image=image;
    this.refresh();
};

/**
 *default paint implementation for image. If Image object size!=provided image surface size, image is stretched.
 *@function
 */
Image.prototype.paint=function(){
    View.prototype.paint.apply(this, []);
    this.surface.blit(this.image, new gamejs.Rect([0, 0], this.surface.getSize()), new gamejs.Rect([0, 0], this.image.getSize()));  
};

/**
 *@class draggable frame header with a close button !CONSTRUCTOR PARAMETERS ARE PROVIDED IN A OBJECT LITERAL!
 *@augments View
 *
 *@param {Frame} parent frame object this header is applied to
 *@param {Number} height frame height, OPTIONAL, DEFAULT 20
 *@param {String} title frame title OPTIONAL
 *@param {CachedFont} title_font font for title OPTIONAL
 *@param {Bool} close_btn show close button? OPTIONAL, DEFAULT false
 *@param {gamejs.Surface} close_icon image to use for close button, OPTIONAL
 *@param {gamejs.Surface} close_btn close button image OPTIONAL
 *@param {gamejs.Surface} surface surface to render this view on, OPTIONAL
 *@param {Bool} visible is this view visible? OPTIONAL, DEFAULT true
 *
 *@property {CachedFont) title_font
 *@property {Number} height
 */
var FrameHeader=exports.FrameHeader=function(pars){
    if(!pars.parent) throw 'FrameHeader: parent parameter is required';
    this.height=pars.height || 20;
    pars.width=pars.parent.size[0];
    pars.size=[pars.width, this.height];
    pars.position=[0, 0];
    this.title_font=pars.title_font;
    
    FrameHeader.superConstructor.apply(this, [pars]);
    draggable(this);
    
    if(pars.title){
        this.setTitle(pars.title);
    }
    
    if(pars.close_btn){
        var img;
        if(pars.close_icon){
            img=pars.close_icon;
        }
        else{
            img=new gamejs.Surface([this.height, this.height]);
            gamejs.draw.line(img, '#000', [3, 3], [this.height-3, this.height-3], 3);
            gamejs.draw.line(img, '#000', [3, this.height-3], [this.height-3, 3], 3);
        }
      
        img=new Image({'parent':this,
                      'position':[this.size[0]-img.getSize()[0], 0],
                      'image':img});
        img.on(EVT_MOUSE_DOWN, function(){
            this.close();
            this.despatchEvent({'type':EVT_CLOSE});
        }, this.parent);
    }
    
    this.type='frameheader';       
};

gamejs.utils.objects.extend(FrameHeader, View);

/**
 *moving header moves parent frame too
 *@function
 *
 *@param {Array} pos position ot move header to
 */
FrameHeader.prototype.move=function(pos){
    this.parent.move([this.parent.position[0]+pos[0]-this.position[0],
                      this.parent.position[1]+pos[1]-this.position[1]]);
};

/**
 *set header title
 *@function
 *
 *@param {String} text new header title
 */
FrameHeader.prototype.setTitle=function(text){
    if(!this.title_label)this.title_label=new Label({'parent':this,
                                                    'position':[0, 0],
                                                    'font':this.title_font,
                                                    'text':text});
    else this.title_label.setText(text);
    var font=this.title_label.font;
    var size=font.getTextSize(text);
    this.title_label.move([font.space_width, Math.max(parseInt(this.height-size[1]))], 0);
    draggable(this);
};

/**
 *default paint implementation: gray background
 *@function
 */
FrameHeader.prototype.paint=function(){
    gamejs.draw.rect(this.surface, '#C0C0C0', new gamejs.Rect([0, 0], this.size));
};



/**
 *@class a overlay view with it's own space and hierarchy, a 'window' in OS talk. Hidden by default !CONSTRUCTOR PARAMETERS ARE PROVIDED IN A OBJECT LITERAL!
 *@augments View
 *
 *@param {GUI} parent parent GUI object
 *@param {Bool} constrain if true, frame cannot be moved out of visible area
 *@param {Array} size  array containing width & height of the element, eg. [width, height]
 *@param {Array} position position of the view relative to parent, eg. [x, y]. OPTIONAL, default [0, 0]
 *@param {gamejs.Surface} surface surface to render this view on, OPTIONAL
 *@param {Bool} visible is this view visible? OPTIONAL, DEFAULT true
 *
 *@property {Bool} constrain
 */
var Frame=exports.Frame=function(pars){
    if(!pars.parent) throw 'Frame: parent parameter is required';
    if(pars.parent.type!='gui') throw 'Frame: parent object must be instance of GUI';
    var gui=pars.parent;
    pars.parent=null;
    Frame.superConstructor.apply(this, [pars]);
    this.type='frame';
    this.visible=false;
    gui.frames.push(this);
    this.parent=gui;    
    //constrain
    this.constrain=pars.constrain;
    return this;
};
gamejs.utils.objects.extend(Frame, View);

/**
 *Default implementation, white fill and gray border.
 *@function
 */
Frame.prototype.paint=function(){
    //fill
    gamejs.draw.rect(this.surface, '#FFF', new gamejs.Rect([0, 0], this.size));
    
    //draw border
    gamejs.draw.rect(this.surface, '#404040', new gamejs.Rect([0, 0], this.size), 1);
};

/**
 *Show frame, move it to top of the screen
 *@function
 */
Frame.prototype.show=function(){
    View.prototype.show.apply(this, []);
    this.parent.moveFrameToTop(this);
};

/**
 *Close frame. You propably want to use this instead of hide()! generates EVT_CLOSE
 *@function
 */
Frame.prototype.close=function(){
    View.prototype.hide.apply(this, []);
    this.despatchEvent({'type':EVT_CLOSE});
};

/**
 *implements restricting frame to GUI bounds. generates EVT_MOVE
 *@function
 *@param {Array} position position to move frame to
 */

Frame.prototype.move=function(position){
    if(this.constrain){
        if(position[0]<0)position[0]=0;
        if(position[0]>this.parent.size[0]-this.size[0]) position[0]=this.parent.size[0]-this.size[0];
        if(position[1]<0)position[1]=0;
        if(position[1]>this.parent.size[1]-this.size[1]) position[1]=this.parent.size[1]-this.size[1];
    }
    View.prototype.move.apply(this, [position]);
};

/**
 *closes frame, then destroys it
 *@function
 */
Frame.prototype.destroy=function(){
    if(this.visible) this.close();
    if(this.parent) this.parent.removeFrame(this);
};

/**
 *@class draggable view: can be dragged within its parent by holding down left mouse btn
 *@augments View
 *
 *@param {Number} min_x minimum x coordinate view can be dragged to, OPTIONAL
 *@param {Number} max_x maximum x coordinate view can be dragged to, OPTIONAL
 *@param {Number} min_y minimum y coordinate view can be dragged to, OPTIONAL
 *@param {Number} max_y maximum y coordinate view can be dragged to, OPTIONAL
 *@param {View} parent parent element
 *@param {Array} size  array containing width & height of the element, eg. [width, height]
 *@param {Array} position position of the view relative to parent, eg. [x, y]. OPTIONAL, default [0, 0]
 *@param {gamejs.Surface} surface surface to render this view on, OPTIONAL
 *@param {Bool} visible is this view visible? default true
 *
 *@property {Number} min_x
 *@property {Number} max_x
 *@property {Number} min_y
 *@property {Number} max_y
 */

var DraggableView=exports.DraggableView=function(pars){
    DraggableView.superConstructor.apply(this, [pars]);
    draggable(this);
    this.min_x=pars.min_x;
    this.max_x=pars.max_x;
    this.min_y=pars.min_y;
    this.max_y=pars.max_y;
    this.type='draggableview';
};

gamejs.utils.objects.extend(DraggableView, View);

/**
 *implements restricting to coordinates, if applicable
 *@function
 *@param {Array} pos new position
 */
DraggableView.prototype.move=function(pos){
    var x=pos[0];
    if(this.min_x || (this.min_x==0)) x=Math.max(x, this.min_x);
    if(this.max_x || (this.max_x==0)) x=Math.min(x, this.max_x);
    
    var y=pos[1];
    if(this.min_y || (this.min_y==0)) y=Math.max(y, this.min_y);
    if(this.max_y || (this.max_y==0)) y=Math.min(y, this.max_y);
    
    View.prototype.move.apply(this, [[x, y]]);
};


/**
 *@class draggable part of the scrollbar !CONSTRUCTOR PARAMETERS ARE PROVIDED IN A OBJECT LITERAL!
 *@augments DraggableView
 *
 *@param {View} parent parent element
 *@param {Array} size  array containing width & height of the element, eg. [width, height]
 *@param {gamejs.Surface} image iamge to use for the scroller, OPTIONAL
 *@param {Number} min_x minimum x coordinate view can be dragged to, OPTIONAL
 *@param {Number} max_x maximum x coordinate view can be dragged to, OPTIONAL
 *@param {Number} min_y minimum y coordinate view can be dragged to, OPTIONAL
 *@param {Number} max_y maximum y coordinate view can be dragged to, OPTIONAL
 *@param {Array} position position of the view relative to parent, eg. [x, y]. OPTIONAL, default [0, 0]
 *@param {gamejs.Surface} surface surface to render this view on, OPTIONAL
 *@param {Bool} visible is this view visible? OPTIONAL, DEFAULT true
 *
 *@property {Image} img Image object created if image parameter was provided
 */
var Scroller=exports.Scroller=function(pars){
    Scroller.superConstructor.apply(this, [pars]);
    this.img=null;
    if(pars.image){
        this.img=new Image({'parent':this,
                    'position':[0, 0],
                    'size':this.size,
                    'image':pars.image});
    }
};
gamejs.utils.objects.extend(Scroller, DraggableView);

/**
 *resizes image along with scroller
 *@function 
 */
Scroller.prototype.resize=function(size){
    DraggableView.prototype.resize.apply(this,[size]);
    if(this.img)this.img.resize(size);

};

/**
 *@class !CONSTRUCTOR PARAMETERS ARE PROVIDED IN A OBJECT LITERAL!
 *@augments View
 *
 *@param {gamejs.Surface} left_btn_image image for left scrollbar button
 *@param {gamejs.Surface} scroller_image image for scroller
 *@param {gamejs.Surface} right_btn_image image for right scrollbar button
 *@param {View} parent parent element
 *@param {Array} size  array containing width & height of the element, eg. [width, height]
 *@param {Array} position position of the view relative to parent, eg. [x, y]. OPTIONAL, default [0, 0]
 *@param {gamejs.Surface} surface surface to render this view on, OPTIONAL
 *@param {Bool} visible is this view visible? OPTIONAL, DEFAULT true
 *
 *@property {Button} left_btn left scrollbar button
 *@property {Button} right_btn right scrollbar button
 *@property {Scroller} scroller
 *@property {Function} scroller_class scroller class used to create scroller #TODO find better way to implement customization
 */

var HorizontalScrollbar=exports.HorizontalScrollbar=function(pars){
    HorizontalScrollbar.superConstructor.apply(this, [pars]);
    this.type='horizontalscrollbar';
    var left_btn_image=pars.left_btn_image;
    if(!left_btn_image){
        left_btn_image=new gamejs.Surface([this.size[1], this.size[1]]);
        var pts=[[0, this.size[1]/2],
                 [this.size[1], 0],
                 [this.size[1], this.size[1]]];
        gamejs.draw.polygon(left_btn_image, '#C0C0C0', pts);
    }
    this.left_btn=new Button({'parent':this,
                            'position':[0, 0],
                            'size':[this.size[1], this.size[1]],
                            'image':left_btn_image});
    this.left_btn.onClick(this.scrollLeft, this);
    
    var right_btn_image=pars.right_btn_image;
    if(!right_btn_image){
        right_btn_image=new gamejs.Surface([this.size[1], this.size[1]]);
        var pts=[[0, 0],
                 [this.size[1], this.size[1]/2],
                 [0, this.size[1]]];
        gamejs.draw.polygon(right_btn_image, '#C0C0C0', pts);
    }
    this.right_btn=new Button({'parent':this,
                            'position':[this.size[0]-this.size[1], 0],
                            'size':[this.size[1], this.size[1]],
                            'image':right_btn_image});
    
    this.right_btn.onClick(this.scrollRight, this);

    //scroller track size
    this.sts=this.size[0]-this.right_btn.size[0]-this.left_btn.size[0];
    
    var scroller_image=pars.scroller_image;
    if(!scroller_image){
        scroller_image=new gamejs.Surface([this.size[1], this.size[1]]);
        var sz=scroller_image.getSize()
        gamejs.draw.rect(scroller_image, '#C0C0C0', new gamejs.Rect([0, 0],[sz[0], sz[1]]));
    }
    var size=[Math.max(parseInt((this.size[0]-2*this.size[1])/2),scroller_image.getSize()[0]), this.size[1]];
    this.scroller=new this.scroller_class({'parent':this,
                                            'position':[this.size[1], 0],
                                            'image':scroller_image,
                                            'size':size,
                                            'min_x':this.size[1],
                                            'max_x':this.size[0]-this.right_btn.size[0]-size[0],
                                            'min_y':0,
                                            'max_y':0});

    
    this.scroll_pos=0;
    this.max_scroll_pos=this.sts-this.scroller.size[0];
    
    this.scroller.on(EVT_DRAG, function(event){
        this.setScrollPX(event.new_pos[0]-this.size[1]);
    }, this);
};
gamejs.utils.objects.extend(HorizontalScrollbar, View);

HorizontalScrollbar.prototype.scroller_class=Scroller;

/**
 *set relative scroller width
 *@function
 *@param {Number} sz relative scroller width, between 0.1 and 1, 
 */
HorizontalScrollbar.prototype.setScrollerSize=function(sz){
    sz=Math.min(Math.max(sz, 0.1), 1);
    this.scroller.resize([this.sts*sz, this.scroller.size[1]]);
   
    this.max_scroll_pos=this.sts-this.scroller.size[0];
    this.scroller.max_x=this.size[0]-this.left_btn.size[0]-this.scroller.size[0];
    this.refresh();
};

/**
 *set scroll amount, px
 *@function
 *@param {Number} pos scroll amount, px
 */
HorizontalScrollbar.prototype.setScrollPX=function(pos){
    this.scroller.move([pos+this.left_btn.size[0], 0]);
    var pos_x=this.scroller.position[0]-this.left_btn.size[0];
    this.scroll_pos=pos_x;
    var scroll=0;
    if(this.max_scroll_pos>0){
        scroll=pos_x/this.max_scroll_pos;
    }
    this.despatchEvent({'type':EVT_SCROLL,
                       'scroll_px':pos_x,
                       'scroll':scroll});
    this.refresh();
};

/**
 *set scroll amount, relative
 *@function
 *@param {Number} pos scroll amount, between 0 and 1
 */
HorizontalScrollbar.prototype.setScroll=function(pos){
    this.setScrollPX(parseInt(this.max_scroll_pos*pos));
};

/**
 *scroll left by 0.1 of max scrollable amount
 *@function
 */
HorizontalScrollbar.prototype.scrollLeft=function(){
    this.setScrollPX(Math.max(0, this.scroll_pos-this.max_scroll_pos*0.1));
};

/**
 *scroll right by 0.1 of max scrollable amount
 *@function
 */
HorizontalScrollbar.prototype.scrollRight=function(){
    this.setScrollPX(Math.min(this.max_scroll_pos, this.scroll_pos+this.max_scroll_pos*0.1));
};

/**
 *@class !CONSTRUCTOR PARAMETERS ARE PROVIDED IN A OBJECT LITERAL!
 *@augments View
 *
 *@param {gamejs.Surface} top_btn_image image for top scrollbar button
 *@param {gamejs.Surface} scroller_image image for scroller
 *@param {gamejs.Surface} bot_btn_image image for bottom scrollbar button
 *@param {View} parent parent element
 *@param {Array} size  array containing width & height of the element, eg. [width, height]
 *@param {Array} position position of the view relative to parent, eg. [x, y]. OPTIONAL, default [0, 0]
 *@param {gamejs.Surface} surface surface to render this view on, OPTIONAL
 *@param {Bool} visible is this view visible? OPTIONAL, DEFAULT true
 *
 *@property {Button} top_btn top scrollbar button
 *@property {Button} bot_btn bottom scrollbar button
 *@property {Scroller} scroller
 *@property {Function} scroller_class scroller class used to create scroller #TODO find better way to implement customization
 */

var VerticalScrollbar=exports.VerticalScrollbar=function(pars){
    VerticalScrollbar.superConstructor.apply(this, [pars]);
    this.type='verticalscrollbar';
    var top_btn_image=pars.top_btn_image;
    if(!top_btn_image){
        top_btn_image=new gamejs.Surface([this.size[0], this.size[0]]);
        var pts=[[this.size[0]/2, 0],
                 [0, this.size[0]],
                 [this.size[0], this.size[0]]];
        gamejs.draw.polygon(top_btn_image, '#C0C0C0', pts);
    }
    this.top_btn=new Button({'parent':this,
                            'position':[0, 0],
                            'size':[this.size[0], this.size[0]],
                            'image':top_btn_image});
    this.top_btn.onClick(this.scrollUp, this);
    
    var bot_btn_image=pars.bot_btn_image;
    if(!bot_btn_image){
        bot_btn_image=new gamejs.Surface([this.size[0], this.size[0]]);
        var pts=[[0, 0],
                 [this.size[0], 0],
                 [this.size[0]/2, this.size[0]]];
        gamejs.draw.polygon(bot_btn_image, '#C0C0C0', pts);
    }
    this.bot_btn=new Button({'parent':this,
                            'position':[0, this.size[1]-this.size[0]],
                            'size':[this.size[0], this.size[0]],
                            'image':bot_btn_image});
    
    this.bot_btn.onClick(this.scrollDown, this);

    //scroller track size
    this.sts=this.size[1]-this.bot_btn.size[1]-this.top_btn.size[1];
    
    var scroller_image=pars.scroller_image;
    if(!scroller_image){
        scroller_image=new gamejs.Surface([this.size[0], this.size[0]]);
        var sz=scroller_image.getSize()
        gamejs.draw.rect(scroller_image, '#C0C0C0', new gamejs.Rect([0, 0],[sz[0], sz[1]]));
    }
    var size=[this.size[0], Math.max(parseInt((this.size[1]-2*this.size[0])/2),scroller_image.getSize()[1])];
    this.scroller=new this.scroller_class({'parent':this,
                                            'position':[0, this.size[0]],
                                            'image':scroller_image,
                                            'size':size,
                                            'min_x':0,
                                            'max_x':0,
                                            'min_y':this.size[0],
                                            'max_y':this.size[1]-this.bot_btn.size[1]-size[1]});

    
    this.scroll_pos=0;
    this.max_scroll_pos=this.sts-this.scroller.size[1];
    
    this.scroller.on(EVT_DRAG, function(event){
        this.setScrollPX(event.new_pos[1]-this.size[0]);
    }, this);
};
gamejs.utils.objects.extend(VerticalScrollbar, View);

VerticalScrollbar.prototype.scroller_class=Scroller;

/**
 *set relative scroller width
 *@function
 *@param {Number} sz relative scroller width, between 0.1 and 1, 
 */
VerticalScrollbar.prototype.setScrollerSize=function(sz){
    sz=Math.min(Math.max(sz, 0.1), 1);
    this.scroller.resize([this.scroller.size[0], this.sts*sz]);
   
    this.max_scroll_pos=this.sts-this.scroller.size[1];
    this.scroller.max_y=this.size[1]-this.bot_btn.size[1]-this.scroller.size[1];
    this.refresh();
};

/**
 *set scroll amount, px
 *@function
 *@param {Number} pos scroll amount, px
 */
VerticalScrollbar.prototype.setScrollPX=function(pos){
    this.scroller.move([0, pos+this.top_btn.size[1]]);
    var pos_y=this.scroller.position[1]-this.top_btn.size[1];
    this.scroll_pos=pos_y;
    var scroll=0;
    if(this.max_scroll_pos>0){
        scroll=pos_y/this.max_scroll_pos;
    }
    this.despatchEvent({'type':EVT_SCROLL,
                       'scroll_px':pos_y,
                       'scroll':scroll});
    this.refresh();
};

/**
 *set scroll amount, relative
 *@function
 *@param {Number} pos scroll amount, between 0 and 1
 */
VerticalScrollbar.prototype.setScroll=function(pos){
    this.setScrollPX(parseInt(this.max_scroll_pos*pos));
};

/**
 *@function
 *scroll up by 0.1 of max scrollable amount
 */
VerticalScrollbar.prototype.scrollUp=function(){
    this.setScrollPX(Math.max(0, this.scroll_pos-this.max_scroll_pos*0.1));
};

/**
 *@function
 *scroll down by 0.1 of max scrollable amount
 */
VerticalScrollbar.prototype.scrollDown=function(){
    this.setScrollPX(Math.min(this.max_scroll_pos, this.scroll_pos+this.max_scroll_pos*0.1));
};

/**
 *@class view with scrollable content !CONSTRUCTOR PARAMETERS ARE PROVIDED IN A OBJECT LITERAL!
 *@augments View
 *
 *@param {View} parent parent element
 *@param {Array} size  array containing width & height of the element, eg. [width, height]
 *@param {Array} position position of the view relative to parent, eg. [x, y]. OPTIONAL, default [0, 0]
 *@param {gamejs.Surface} surface surface to render this view on, OPTIONAL
 *@param {Bool} visible is this view visible? OPTIONAL, DEFAULT true
 */
var ScrollableView=exports.ScrollableView=function(pars){
    ScrollableView.superConstructor.apply(this, [pars]);
    this.type='scrollableview';
    this.scroll_x=0;
    this.scroll_y=0;
    this.max_scroll_x=0;
    this.max_scroll_y=0;
    this.scrollable_area=[0, 0];
    this.setScrollableArea(this.size);
    this.vertical_scrollbar=null;
    this.horizontal_scrollbar=null;
};
gamejs.utils.objects.extend(ScrollableView, View);

/**
 *set vertical scrollbar for this view
 *@function
 *@param {VerticalScrollbar} scrollbar
 */
ScrollableView.prototype.setVerticalScrollbar=function(scrollbar){
    this.vertical_scrollbar=scrollbar;
    scrollbar.on(EVT_SCROLL, function(event){
        this.setScrollY(Math.ceil(event.scroll*this.max_scroll_y));
    }, this);
};

/**
 *set horizontal scrollbar for this view
 *@function
 *@param {HorizontalScrollbar} scrollbar
 */
ScrollableView.prototype.setHorizontalScrollbar=function(scrollbar){
    this.horizontal_scrollbar=scrollbar;
    scrollbar.on(EVT_SCROLL, function(event){
        this.setScrollX(Math.ceil(event.scroll*this.max_scroll_x));
    }, this);
};

/**
 *manually set size of scrollable area
 *@function
 *@param {Array} area scrollbale area, [width, height]
 */
ScrollableView.prototype.setScrollableArea=function(area){
    this.scrollable_area=area;
    this.max_scroll_y=Math.max(area[1]-this.size[1], 0);
    this.max_scroll_x=Math.max(area[0]-this.size[0], 0);
    if(this.vertical_scrollbar){
        var sz=Math.max(Math.min(1, this.size[1]/area[1]), 0.1);
        this.vertical_scrollbar.setScrollerSize(sz);
    }
    if(this.horizontal_scrollbar){
        var sz=Math.max(Math.min(1, this.size[0]/area[0]), 0.1);
        this.horizontal_scrollbar.setScrollerSize(sz);
    }
};

/**
 *automatically set scrollable area based on children positions and sizes
 *@function
 */
ScrollableView.prototype.autoSetScrollableArea=function(){
    scrollable_area=[0, 0];
    this.children.forEach(function(child){
            scrollable_area[0]=Math.max(scrollable_area[0], child.position[0]+child.size[0]+20);
            scrollable_area[1]=Math.max(scrollable_area[1], child.position[1]+child.size[1]+20);
    }, this);
    this.setScrollableArea(scrollable_area);
};

/**
 *TODO: implement optional auto setting scrollable area when children are added
 *@function
 */
ScrollableView.prototype.addChild=function(child){
    View.prototype.addChild.apply(this, [child]);
    this.refresh();    
};

/**
 *implements child blitting adjusted to scroll state
 *@function
 */
ScrollableView.prototype.blitChild=function(child){
    this.surface.blit(child.surface, [child.position[0]-this.scroll_x, child.position[1]-this.scroll_y]);
};

/**
 *adjusts event position based on scroll state
 *@function
 */
ScrollableView.prototype.despatchEvent=function(event){
    if(event.pos){
        event=cloneEvent(event);
        event.pos=[event.pos[0]+this.scroll_x, event.pos[1]+this.scroll_y];
    }
    View.prototype.despatchEvent.apply(this, [event]);
};

/**
 *increment horizontal scroll
 *@function
 *@param {Number} x px to increment horizontal scroll by
 */
ScrollableView.prototype.scrollX=function(x){
  this.setScrollX(this.scroll_x+x);
  this.refresh();
};

/**
 *increment vertical scroll
 *@function
 *@param {Number} y px to increment vertical scroll by
 */
ScrollableView.prototype.scrollY=function(y){
    this.setScrollY(this.scroll_y+y);
    this.refresh();
};

/**
 *set horizontal scroll
 *@function
 *@param {Number} x horizontal scroll, px
 */
ScrollableView.prototype.setScrollX=function(x){
    this.scroll_x=Math.min(Math.max(x, 0), this.max_scroll_x);
    this.refresh();
};

/**
 *set vertical scroll
 *@function
 *@param {Number} y vertical scroll, px
 */
ScrollableView.prototype.setScrollY=function(y){
    this.scroll_y=Math.min(Math.max(y, 0), this.max_scroll_y);
    this.refresh();
};

/**
 *@class text input !CONSTRUCTOR PARAMETERS ARE PROVIDED IN A OBJECT LITERAL!
 *@augments View
 *
 *@param {CachedFont} font 
 *@param {String} text
 *@param {Array} scw_size actual text display size, [width, height].
 *@param {View} parent parent element
 *@param {Array} size  array containing width & height of the element, eg. [width, height]
 *@param {Array} position position of the view relative to parent, eg. [x, y]. OPTIONAL, default [0, 0]
 *@param {gamejs.Surface} surface surface to render this view on, OPTIONAL
 *@param {Bool} visible is this view visible? OPTIONAL, DEFAULT true
 *
 *@property {CachedFont} font
 *@property {String} text
 */
var TextInput=exports.TextInput=function(pars){
    TextInput.superConstructor.apply(this, [pars]);
    this.font=pars.font ? pars.font : exports.DEFAULT_FONT;
    this.text=pars.text ? pars.text : '';
    this.blip=false;
    this.pos=0;
    this.ms=500;
    
    this.scw=new ScrollableView({'parent':this,
                              'position':[0, 0],
                              'size':pars.scw_size || this.size});
    this.center(this.scw);
    this.label=new Label({'parent':this.scw,
                         'position':[0, 0],
                         'font':this.font,
                         'text':this.text});
    this.scw.center(this.label);
    this.label.move([3, this.label.position[1]]);
    
    this.bliplabel=new Label({'parent':this.scw,
                             'position':[0, 0],
                             'font':this.font,
                             'visible':false,
                             'text':'|'});
    
    this.on(EVT_KEY_DOWN, this.onKeyDown, this);
    this.on(EVT_FOCUS, this.blipon, this);
    this.on(EVT_BLUR, function(){
        this.blip=false;
    }, this);
    this.setPos(this.text.length);
};
gamejs.utils.objects.extend(TextInput, View);

/**
 *turn blip on
 *@ignore
 */
TextInput.prototype.blipon=function(event){
    this.blip=true;
    this.ms=500;
    this.refresh();
};

/**
 *implements blip updating
 *@function
 *@param {Number} msDuration
 */
TextInput.prototype.update=function(msDuration){
    if(this.isFocused()){
        this.ms-=msDuration;
        if(this.ms<0){
            this.ms=500;
            this.blip=!this.blip;
        };
        if(this.blip){
            this.bliplabel.show();    
        }else{
            this.bliplabel.hide();
        }
    }else{
        this.bliplabel.hide();
    }
};

/**
 *default implementation: white fill, gray border
 *@function
 */
TextInput.prototype.paint=function(){
    this.surface.fill('#FFF');
    gamejs.draw.rect(this.surface, '#COCOCO', new gamejs.Rect([0, 0], this.size), 1);
};

/**
 *set input text. generates EVT_CHANGE
 *@function
 *@param {String} text
 */
TextInput.prototype.setText=function(text){
    this.setPos(this.text.length);
    this._setText(text);
};

/**
 *set blip position
 *@ignore
 */
TextInput.prototype.setPos=function(pos){
    this.pos=Math.min(Math.max(pos, 0), this.text.length);

    //calc offset for scorllable area
    var ofst=0;
    var ofst=0;
    var tlen=this.font.getTextSize(this.text.substr(0, this.pos))[0];
    ofst=Math.max(tlen-this.scw.size[0]+this.font.getTextSize('s')[0]);
    
    this.scw.setScrollX(ofst);
    this.bliplabel.move([Math.max(this.font.getTextSize(this.text.substr(0, this.pos))[0]+this.label.position[0]-2, 0), this.label.position[1]]);
           
};

/**
 *@ignore
 */
TextInput.prototype._setText=function(text){
    this.text=text;
    this.label.setText(text);
    this.scw.autoSetScrollableArea();
    this.refresh();
    this.despatchEvent({'type':EVT_CHANGE,'value':text});
};

/**
 *key down handler
 *@ignore
 */
TextInput.prototype.onKeyDown=function(event){
    var charcode=event.key;
    if(charcode==13){
        //TODO
    }
    //BACKSPACE
    if(charcode==8){
        if(this.text){
            if(this.pos==this.text.length){
                this._setText(this.text.substr(0,this.text.length-1));
            }else {
                this._setText(this.text.substr(0, this.pos-1)+this.text.substr(this.pos, this.text.length));
            }
            this.blipon();
            this.setPos(this.pos-1);
        }
    }
    //WRITEABLE SYMBOLS, 0 to z or space
    if(((charcode>=48) && (charcode<=90))||(charcode==32)){
        var c=String.fromCharCode(charcode);
        if(event.shiftKey)c=c.toUpperCase();
        else c=c.toLowerCase();
        if(this.pos==this.text.length){
            this._setText(this.text+c);
        }else{
            this._setText(this.text.substr(0, this.pos)+c+this.text.substr(this.pos, this.text.length));
        }
        this.setPos(this.pos+1);
        this.blipon();
    }

    //LEFT
    if(charcode==37){
        this.setPos(this.pos-1);
        this.blipon();
    }
    //RIGHT
    if(charcode==39){
        this.setPos(this.pos+1);
        this.blipon();
    }
};

/**
 *@class a centered dialog position at the top of the GUI. disables and grays out rest of the guy
 *@augments Frame
 *
 *@param {GUI} parent parent GUI object
 *@param {Bool} constrain if true, frame cannot be moved out of visible area
 *@param {Array} size  array containing width & height of the element, eg. [width, height]
 *@param {Array} position position of the view relative to parent, eg. [x, y]. OPTIONAL, default [0, 0]
 *@param {gamejs.Surface} surface surface to render this view on, OPTIONAL
 *@param {Bool} visible is this view visible? default true
 */

var Dialog=exports.Dialog=function(pars){
    pars.position=getCenterPos(pars.parent.size, pars.size);
    Dialog.superConstructor.apply(this, [pars]);
    
};

gamejs.utils.objects.extend(Dialog, Frame);

/**
 *lock GUI & show dialog
 *@function
 */
Dialog.prototype.show=function(){
    this.getGUI().lockFrame(this);
    Frame.prototype.show.apply(this, []);
};

/**
 *unlock gui & hide dialog
 *@function
 */
Dialog.prototype.close=function(){
    this.getGUI().unlockFrame();
    Frame.prototype.close.apply(this, []);
};

/**
 *@class multi-line, line-wrapped text dislay !CONSTRUCTOR PARAMETERS ARE PROVIDED IN A OBJECT LITERAL!
 *@augments View
 *
 *@param {CachedFont} font 
 *@param {String} text
 *@param {Bool} justify if true, text is justified. By default, it's left-aligned
 *@param {View} parent parent element
 *@param {Integer} width text width in px. height is calculated automatically
 *@param {Array} position position of the view relative to parent, eg. [x, y]. OPTIONAL, default [0, 0]
 *@param {gamejs.Surface} surface surface to render this view on, OPTIONAL
 *@param {Bool} visible is this view visible? OPTIONAL, DEFAULT true
 */
var Text=exports.Text=function(pars){
    pars.size=[pars.width, 1];
    Text.superConstructor.apply(this, [pars]);
    this.width=pars.width;
    this.font=pars.font ? pars.font : exports.DEFAULT_FONT;
    this.setText(pars.text);
    this.justify=pars.justify;
};
gamejs.utils.objects.extend(Text, View);

/**
 *set text
 *@function
 *@param {String} text
 */
Text.prototype.setText=function(text){
    //wow, is this a hacky mess!
    
    this.text=text;
    this.lines=[];
    var nlines=text.split(/\r\n|\r|\n/);
    nlines.push(' ');
    var line, words;
    var i, ci, c, l;
    var word='';
    var height=0;
    var n_line_length=0;
    var n_line='';
    for(i=0;i<nlines.length;i++){
        line=nlines[i];
        line+=' ';
        for(ci=0;ci<line.length;ci++){
            c=line[ci];
            if(c==' ' || c=='\t'){
                if(word){
                    l=this.font.getTextSize(word)[0];
                    if((n_line_length+l>this.size[0]) && (!(n_line==''))){
                        this.lines.push({'t':n_line, 'e':false});
                        height+=this.font.getTextSize(n_line)[1];
                        n_line='';
                        n_line_length=0;
                        if(word[0]==' ' || word[0]=='\t'){
                            word=word.substr(1, word.length);
                        }
                    }
                    n_line+=word;
                    n_line_length+=l;
                    
                }
                word='';
                word+=c;
            }else{
                word+=c;
            }
        }
        if(n_line){
            this.lines.push({'t':n_line, 'e':true});
            height+=this.font.getTextSize(n_line)[1];
            n_line='';
            n_line_length=0;
        }
    }
    this.resize([this.width, height]);
    this.refresh();
};

/**
 *@function
 */
Text.prototype.paint=function(){
    View.prototype.paint.apply(this, []);
    var pos=0;
    this.lines.forEach(function(line){
        var sz=this.font.getTextSize(line.t);
        var extra_w=0;
        if(this.justify && (!line.e)){
            var space_count=0;
            for(var i=0;i<line.t.length;i++){
                if(line.t[i]==' ') space_count++;
            }
            extra_w=Math.floor((this.size[0]-sz[0])/space_count);
        }
        this.font.render(this.surface, line.t, [0, pos], this.font.space_width+extra_w);
        pos+=sz[1];
    }, this);
}

/**
 *@class root GUI object. Handles gamejs events, frames
 *@augments View
 *
 *@param {gamejs.Surface} surface surface to render GUI on
 */
var GUI=exports.GUI=function(surface){
    GUI.superConstructor.apply(this, [{'position':[0, 0],
                                      'parent':null,
                                      'size':surface.getSize(),
                                      'surface':surface}]);
    this.type='gui';
    this.locked_frame=null;
    this.frames=[];
};

gamejs.utils.objects.extend(GUI, View);

/**
 *redraw GUI, if needed
 *@function
 *@param {Bool} force_redraw if true GUI is redrawn even if tehre are no internal changes
 */
GUI.prototype.draw=function(force_redraw){
    if(force_redraw)this.refresh();
    var painted=View.prototype.draw.apply(this, []);
    this.frames.forEach(function(frame){
        if(frame.visible && (frame.draw() || painted)){
            if(this.locked_frame && (this.locked_frame.id==frame.id)){
                this.refresh();
                this.blur_bg();
            }
            this.surface.blit(frame.surface, frame.position);
        }
    }, this);
};

/**
 *Does nothing! don't remove!
 *@function
 */
GUI.prototype.paint=function(){};

GUI.prototype.blur_bg=function(){
    gamejs.draw.rect(this.surface, 'rgba(192,192, 192, 0.5)', new gamejs.Rect([0, 0], this.size),0); 
};

/**
 *Remove a frame from GUI
 *@function
 *@param {Frame|Id} frame frame object or id of frame to remove
 */

GUI.prototype.removeFrame=function(frame){
    if(typeof(frame)!='number')frame=frame.id;
    for(var i=0;i<this.frames.length;i++){
        if(this.frames[i].id==frame){
            frame=this.frames.splice(i, 1);
            this.refresh();
            return true;
        }
    }
    return false;
};

/**
 *Move a frame to the top
 *@function
 *@param {Frame} frame
 */
GUI.prototype.moveFrameToTop=function(frame){   
    for(var i=0;i<this.frames.length;i++){
        var f=this.frames[i];
        if(f.id==frame.id){
            if(i==this.frames.length-1) return;
            this.despatchEvent({'type':EVT_BLUR});
            this.frames.splice(i, 1);
            this.frames.push(f);
            this.refresh();
            frame.despatchEvent({'type':EVT_FOCUS});
            break;
        }
    }
};

/**
 *Update GUI and its child objects
 *@function
 *@param {Number} msDuration miliseconds since last update
 */
GUI.prototype.update=function(msDuration){
    this.children.forEach(function(child){
        child._update(msDuration);  
    });
    this.frames.forEach(function(frame){
        frame._update(msDuration);  
    });
    
};

/**
 *@ignore
 */
GUI.prototype.lockFrame=function(frame){
    this.locked_frame=frame;
    this.refresh();
};

/**
 *@ignore
 */
GUI.prototype.unlockFrame=function(){
    this.locked_frame=null;
    this.refresh();
};

/**
 *despatch gamejs event
 *@function
 *@param {gamejs Event| GUI event} event event generated by gamejs, or a GUI event if needed.
 */
GUI.prototype.despatchEvent=function(event){
    if(event.pos)event.global_pos=event.pos;
    
    var i, frame;
    //dispatching mouse events to frames: if event is dispatched to a frame, don't dispatch it anywhere else.
    if(event.type==EVT_MOUSE_DOWN || event.type==EVT_MOUSE_MOTION || event.type==EVT_MOUSE_UP){
        var frame;
        var hit=false;
        var clicked_on=null;
        var moused_on=null;
        var topframe=null;
        for(i=this.frames.length-1; i>=0;i--){
            frame=this.frames[i];
            
            //if frame is locked, dispatch events only to that frame
            if(this.locked_frame &&(this.locked_frame.id!=frame.id)) continue;
            
            if(frame.visible && frame.getRect().collidePoint(event.pos)){
                frame.despatchEvent(cloneEvent(event, frame.position));
                if(event.type==EVT_MOUSE_DOWN){
                    clicked_on=i;
                }
                else if(event.type==EVT_MOUSE_MOTION){
                    moused_on=i;
                }
                hit=true;
                //mouseout view if mouse is on a frame
                if(frame.isFocused())topframe=i;
                break;
            }else{
                //blur frame if focused but clicked somewhere else
                if((event.type==EVT_MOUSE_DOWN) && (frame.isFocused())){
                    frame.despatchEvent({'type':EVT_BLUR});
                }
            }
        }
        
        //blur everything else if clicked on a frame
        if(clicked_on!=null){
            View.prototype.despatchEvent.apply(this, [{'type':EVT_BLUR}]);
            for(i=0;i<this.frames.length;i++){
                if(i!=clicked_on) this.frames[i].despatchEvent({'type':EVT_BLUR});
            }
        }
         
        //mouseout everyhting else if clicked on a frame
        if(moused_on!=null){
            View.prototype.despatchEvent.apply(this, [{'type':EVT_MOUSE_OUT}]);
            for(i=0;i<this.frames.length;i++){
                if(i!=moused_on) this.frames[i].despatchEvent({'type':EVT_MOUSE_OUT});
            } 
        }
        
        if(!hit &&(!this.locked_frame)){
            View.prototype.despatchEvent.apply(this, [event]);
        }
        else{
            View.prototype.handleEvent.apply(this, [event]);
        }
        
        if(topframe!=null){
            this.moveFrameToTop(this.frames[topframe]);      
        }
        
    }else{
        if(event.type==EVT_BLUR || event.type==EVT_MOUSE_OUT || event.type==EVT_KEY_DOWN || event.type==EVT_KEY_UP){
            this.frames.forEach(function(frame){
                if(frame.visible &&(!this.locked_frame || (this.locked_frame.id==frame.id))){
                    frame.despatchEvent(cloneEvent(event, frame.position));
                }
            });  
        }
        
        if(!this.locked_frame) View.prototype.despatchEvent.apply(this, [event]);
        else View.prototype.handleEvent.apply(this, [event]);
    }
};

var layout=exports.layout={

/**
 *arranges obejcts vertically
 *@function
 *@name vertical
 *@lends layout
 *@param {Array} objects a list of gui objects (with the same parent)
 *@param {Number} y starting y coordinate, default 0
 *@param {Number} space space between objects px, default 0
 */
'vertical':function(objects, y, space){
        y=y || 0;
        space = space || 0;
        objects.forEach(function(object){
            object.move([object.position[0], y]);
            y+=object.size[1]+space;
        });
        
    },

/**
 *arranges obejcts horizontally
 *@function
 *@name horizontal
 *@lends layout
 *@param {Array} objects a list of gui objects (with the same parent)
 *@param {Number} x startingx coordinate, default 0
 *@param {Number} space space between objects px, default 0
 */
'horizontal':function(objects, x, space){
        x=x || 0;
        space = space || 0;
        objects.forEach(function(object){
            object.move([x, object.position[1]]);
            x+=object.size[0]+space;
        });
    }
};


},{"gamejs":37}],19:[function(require,module,exports){
var gamejs=require('gamejs');
var utils=require('./utils');
var sounds=require('./sounds');
var combatracer=require('./combatracer');
var cars=require('./cars');
var bots=require('./bots');
var GUI = require('./gamejs-gui');
var vec=utils.vec;
var arr=utils.arr;
var ui=require('./ui');
var leagues=require('./leagues');

var vectors = gamejs.utils.vectors;
var math = gamejs.utils.math;
radians=math.radians;
degrees=math.degrees;

var world=require('./world');
var renderer=require('./renderer');
var settings=require('./settings');
var controllers=require('./controllers');
var car_descriptions=require('./car_descriptions');

var LevelScene=exports.LevelScene=function(level){
    this.game=combatracer.game;
    this.level=level;
    this.cache=renderer.cache;
    this.started=false;
    this.paused=false;
    this.time_to_start=3000;
    this.controllers=[];
    this.keys_down={};
    this.started=false;
    this.max_laps=level.laps? level.laps : 3;
    this.world = world.build_world(level, world.MODE_STANDALONE);
    this.gui=new GUI.GUI(this.game.display);
    var i;
    //BUILD BACKGROUND FROM TILES
    this.background=utils.renderLevelBackground(level, true);

    this.renderer=new renderer.RaceRenderer(settings.get('SCREEN_WIDTH'), 
                                            settings.get('SCREEN_HEIGHT'), 
                                            this.world, 
                                            this.background, 
                                            this.cache);

    this.handleEvent=function(event){
        if (event.type === gamejs.event.KEY_DOWN) {
            this.keys_down[event.key] = true;
            if(event.key===gamejs.event.K_SPACE){
               this.paused=(!this.paused);
            };
            if(event.key===gamejs.event.K_ESC){
                if(this.dialog){
                    if(!this.dialog.visible){
                        this.paused=true;
                        this.dialog.show();
                    }else{
                        this.paused=false;
                        this.dialog.hide();
                    }
                };
            };
        } else if (event.type === gamejs.event.KEY_UP) {
            this.keys_down[event.key] = false;
        };
        this.gui.despatchEvent(event);
    };

    this.updateZoom=function(msDuration){
        //upd zoom
        if(this.keys_down[gamejs.event.K_p]) this.renderer.increaseZoom();
        else if(this.keys_down[gamejs.event.K_l]) this.renderer.decreaseZoom();
    };
    
    this.destroy=function(){
        //if(settings.get('SOUND')) sounds.engine.stop();  
    };
};


var MultiplayerLevelScene=exports.MultiplayerLevelScene=function(game, level, cache){
    MultiplayerLevelScene.superConstructor.apply(this, [game, level, cache]);
    this.game=game;
    this.processed_events={};
    this.world.mode=world.MODE_CLIENT;
    this.last_event_no=0; //the last event that was processed
    this.last_known_event_no=0; //the last known event
    this.queued_updates=[];
    this.time_to_start=3000;
    this.player_car=null;
    this.upds_stacked=0;
    this.time=0;
    this.delta=0;
    this.last_t=null;
    this.deltas=[];
    this.delta_q=0;
    this.states={};
    this.queued_events={};
    this.extradelay=50;
    this.last_upd_time=0;
    this.carid=null;
    this.bfs=0;//bad frames;
    this.send_update=true; //send update to server?
    this.time_since_last_update_sent=0;
    this.state=1; // 1 - participating, 2- finished

    this.controllers[this.controllers.length]=this.controller=new controllers.MultiplayerController();

    this.setState=function(target_time){
        /*
        set state of object for target server time
        */

        //find the two nearest known states from both sides of target time
        var mint=0;
        var maxt=0;
        for(var t in this.states){
            if(t==target_time){
                mint=t;
                maxt=0;
                break;
            }
            if(t<target_time && t > mint)mint=t;
            else if(t>target_time && (t<maxt || maxt===0))maxt=t;
        }
        
        if(mint||maxt){
            var minst=this.states[mint];
            var maxst=maxt ? this.states[maxt] : null;
            var q=0;

            //if both states are known, calc difference coeficient
            if(mint&&maxt){
                q=(target_time-mint)/(maxt-mint);
            }

            //for each object in first state
            var state, obj;
            for(var objid in minst){
                obj=this.world.getObjectById(objid);
                if(obj){
                    //if second state is known and object is interpolatable, get interpolated state
                    if(maxst && maxst[objid] && obj.interpolate){
                        state=obj.interpolate(minst[objid], maxst[objid], q);
                        this.last_upd_time=target_time;
                    }
                    //else state is min state
                    else{
                        this.bfs++;
                        state=minst[objid];
                        this.last_upd_time=mint;
                    }
                    obj.setState(state);
                }
            }
        }else{
            console.log('no known state!');
        }
    };

    this.update=function(msDuration){
        this.time+=msDuration;
        this.handleWorldUpdate();
        this.paused=false;
        this.updateZoom(msDuration);

        if(this.time_to_start<0)this.started=true;

        var target_time=this.time+this.delta-10;
        this.processEvents(target_time);

        if(this.started){
            //set object state
            this.setState(target_time);

            if(target_time>this.last_upd_time){
                var d=target_time-this.last_upd_time
                this.world.b2world.Step(d/1000, 10, 8);
                this.world.b2world.ClearForces();
                this.last_upd_time=target_time;
            }

            //update controllers
            this.controllers.forEach(function(c) {
                if(c.update(this.keys_down, msDuration)) this.send_update = true;
            }, this);
            //update world
            this.world.update(msDuration);
        }

        this.time_since_last_update_sent+=msDuration;
        if(this.time_since_last_update_sent>1000 && (!this.send_update))this.send_update=true;
        this.sendInfo();
     };

    this.sendInfo=function(){
        //if(this.upds_stacked<5){
         if(this.send_update){
            this.game.getCommunicator().queueMessage('GAME_UPDATE', {'actions':this.controller.actions, 'eventno':this.last_known_event_no});
           // console.log('sent update');
            this.send_update=false;
            this.time_since_last_update_sent=0;
        }
    };

    this.processEvents=function(target_time){
        while(this.queued_events[this.last_event_no+1]&&(this.queued_events[this.last_event_no+1].t<=target_time)){
            var event=this.queued_events[this.last_event_no+1];
            this.world.handleEvent(event.type, event.descr);
            this.last_event_no=event.no;
           // this.send_update=true;
            delete this.queued_events[event.no];
            if((!this.player_car) && this.carid){
                obj=this.world.getObjectById(this.carid);
                if(obj){
                    this.player_car=obj;
                    this.renderer.follow(obj);
                    this.game.getCommunicator().queueMessage('GAME_READY',{});
                }
            }
        }
    };

    this.handleWorldUpdate=function(){
        this.queued_updates.forEach(function(update) {
            this.time_to_start=update.tts;
            this.state=update.st;
            update.events.forEach(function(event) {
                if(event.no>this.last_event_no && (!this.queued_events[event.no])){
                    event.t=update.t;
                    this.queued_events[event.no]=event;
                    this.last_known_event_no=event.no;
                }
            }, this);
            this.carid=update.carid;
            //put this state in states array
            this.states[update.t]=update.states;
            this.last_t=update.t;
            this.upds_stacked=0;
        }, this);

        //remove old states, taking care to leave at least one

        for(var t in this.states){
            if((t < (this.time+this.delta-300)) &&(t!=this.last_t)){
                delete this.states[t];
            }
        }


        if(this.queued_updates.length){
            var update = this.queued_updates[0];
            var delta=this.time-update.t;
            this.deltas.push(delta);
            dlen=this.deltas.length;
            this.delta_q+=delta;
            if(dlen>60){
                this.delta_q-=this.deltas.shift();
                dlen=60;
            }
            this.delta=parseInt(this.delta_q/dlen);
        }
        this.queued_updates=[];
    };

    this.draw=function(display, msDuration){
        //render world
        this.renderer.render(display);
       
        //play engine sounds
        /*if(settings.get('SOUND') && settings.get('ENGINE_SOUND')){
            if(this.renderer.follow_object && (this.renderer.follow_object.type=='car'))
                sounds.engine.play_by_speed(this.renderer.follow_object.getSpeedKMH(), this.renderer.follow_object.max_speed);
                
        }*/

        //if finished, spectate a live player
        if(this.state==2){
            if(this.renderer.follow_object.active==false){
                this.world.objects.car.some(function(car) {
                    if(car.active){
                        this.renderer.follow_object=car;
                        return true;
                    }
                    return false;
                }, this);
            }
        }

       //render HUD
       this.renderer.renderHUD(display, {'car':this.player_car,
                                         'max_laps':this.max_laps,
                                         'time_to_start':this.time_to_start,
                                         'paused':this.paused,
                                         'delta':this.delta,
                                         'msDuration':msDuration,
                                         'bfs':this.bfs,
                                         'message':this.state==2 ? 'Finished!' : ''});
    };

    this.handleMessage=function(cmd, payload){
        if(cmd=='GAME_UPDATE'){
            this.queued_updates[this.queued_updates.length]=payload;
        }
        else if(cmd=='GAME_OVER'){
            this.game.showGameOver(payload.table);
        }
        else if(cmd=='CRITICAL_ERR'){
            this.returnToTitle();
            this.game.title_scene.alert(payload.text);
        }
    };
};
gamejs.utils.objects.extend(MultiplayerLevelScene, LevelScene);

var SingleplayerLevelScene=exports.SingleplayerLevelScene=function(level, ai_test){
    SingleplayerLevelScene.superConstructor.apply(this, [level]);
    
    this.dialog=new SinglePlayerDialog({'parent':this.gui,
                                       'scene':this});

    this.test_ai=ai_test;

    //PLAYER CAR
    //carEventFromDescription=function(position, carpars, alias, engine_sound){
    var pars = cars.get_car_parameters([this.world.start_positions[1].x, this.world.start_positions[1].y],this.world.start_positions[1].angle,
                                        combatracer.game.player.singleplayer.car,
                                        combatracer.game.player.alias,
                                        true);
    this.player_car = this.world.create(cars.Car, pars);
    
    if(!this.test_ai) this.controllers.push(new controllers.PlayerCarController(this.player_car));
    else this.controllers.push(new controllers.AIController(this.player_car, this.world, this));


    var league=leagues[this.game.player.singleplayer.league];
    if(!this.test_ai){
    //BUILD AI CARS
        var aicar;
        for(i=1;i<4;i++){
            if(this.world.start_positions[i+1]){
                var descr = bots[league.bots[i-1]];
                var pars = cars.get_car_parameters([this.world.start_positions[i+1].x, this.world.start_positions[i+1].y],this.world.start_positions[i+1].angle,
                                                    descr,
                                                    descr.name,
                                                    false);
                                                            
                //hell difficulty: buff all stats & weapons
			    if(combatracer.game.player.singleplayer.difficulty == 4){
			    	pars.acc_upgrades = 5;
			    	pars.speed_upgrades = 5;
			    	pars.armor_upgrades = 5;
			    	(['util', 'rear_weapon', 'front_weapon']).forEach(function(t){
			    		if(this[t]){
			    			this[t].ammo_upgrades = Math.min(this[t].ammo_upgrades+2, 5);
			    			this[t].damage_upgrades = Math.min(this[t].damage_upgrades+2, 5);
			    		}
			    	}, pars);
			    }                                            
                                                            
                aicar = this.world.create(cars.Car, pars);
                this.controllers.push(new controllers.AIController(aicar, this.world, this));
            }
        }
    }
    

    this.renderer.follow(this.player_car);

    this.update = function(msDuration) {
        this.updateZoom(msDuration);
        if(this.time_to_start>-1000){
            this.time_to_start-=msDuration;
            if(this.time_to_start<0)this.started=true;
        }
        
        if(!this.paused && this.started){
            //update controllers
            this.controllers.forEach(function(c) {
               c.update(this.keys_down, msDuration);
            }, this);
            
            //update world
            this.world.update(msDuration);
        
            //update physics
            this.world.b2world.Step(msDuration / 1000, 10, 8);
            this.world.b2world.ClearForces();
        }

        //if we reached max laps, end race
        if(this.player_car.lap > this.max_laps){        
            this.game.showSPGameOver(this.genScoreTable(), this.player_car.get_race_position(), this);
            return;
        };
    };

    this.draw = function(display, msDuration) {
        //render world
        this.renderer.render(display);
        
        //play engine sounds
       /* if(settings.get('SOUND')){            
            if(this.renderer.follow_object && (this.renderer.follow_object.has_tag('car')))
                sounds.engine.play_by_speed(this.renderer.follow_object.get_speed_KMH(), this.renderer.follow_object.max_speed);
                
        }*/
  
        //render HUD
        this.renderer.renderHUD(display, {'car':this.player_car,
                                        'max_laps':this.max_laps,
                                        'msDuration':msDuration,
                                        'time_to_start':this.time_to_start,
                                        'paused':this.paused});
        
        if(this.dialog.visible) this.gui.draw(true);
   };
   
   this.genScoreTable=function(){
        var table= this.world.get_objects_by_tag('car').map(function(car, idx) {
             return {'place':car.get_race_position(),
                    'id':idx,
                    'player':car.alias,
                    'kills':car.kills,
                    'deaths': car.deaths
            }
         });
        table.sort(function(a, b){
           if(a.place>b.place) return 1;
           else if(a.place<b.place) return -1;
           return 0;
        });
        
        return table;
   };

   this.handleMessage=function(cmd, payload){
        return; //single player: just ignore server messages.
    };
};
gamejs.utils.objects.extend(SingleplayerLevelScene, LevelScene);



function SinglePlayerDialog(pars){
    pars.size=[220, 200];
    SinglePlayerDialog.superConstructor.apply(this, [pars]);
    this.scene=pars.scene;
    
    this.quitbtn=new ui.Button({'parent':this,
                                'text':'Quit',
                                'size':[180, 40],
                                'lean':'both',
                                'position':[20, 20]});
    
    this.quitbtn.onClick(function(){
        this.close();      
        this.scene.game.showSPGameOver(this.scene.genScoreTable(), 0, this.scene);
    }, this);
    
    
    this.continuebtn=new ui.Button({'parent':this,
                                'text':'Continue',
                                'size':[180, 40],
                                'lean':'both',
                                'position':[20, 70]});
    
    this.continuebtn.onClick(function(){
        this.close();
        this.scene.paused=false;
    }, this);
    
};

gamejs.utils.objects.extend(SinglePlayerDialog, GUI.Dialog);
},{"./bots":2,"./car_descriptions":4,"./cars":5,"./combatracer":6,"./controllers":7,"./gamejs-gui":18,"./leagues":21,"./renderer":26,"./settings":28,"./sounds":30,"./ui":31,"./utils":33,"./world":36,"gamejs":37}],20:[function(require,module,exports){
var gamejs = require('gamejs');
var ui=require('./ui');
var utils=require('./utils');
var levels=require('./levels');
var sounds=require('./sounds');
var car_descriptions=require('./car_descriptions');
var weapon_descriptions=require('./weapon_descriptions');
var GUI=require('./gamejs-gui');
var skin=require('./skin');
var combatracer=require('./combatracer');
var renderer=require('./renderer');

var EURO_SYMBOL='\u20AC';

var SLOT_TO_LABEL={'front_weapon':'Front weapon slot',
                    'util':'Utility slot',
                    'rear_weapon':'Rear weapon slot'};
                    
var UPGRADE_ACC='acc_upgrades';
var UPGRADE_SPEED='speed_upgrades';
var UPGRADE_ARMOR='armor_upgrades';
    
var UPGRADE_TYPE_TO_LABEL={};
UPGRADE_TYPE_TO_LABEL[UPGRADE_ACC]='Acceleration';
UPGRADE_TYPE_TO_LABEL[UPGRADE_SPEED]='Top Speed';
UPGRADE_TYPE_TO_LABEL[UPGRADE_ARMOR]='Armor';

var GarageScene=exports.GarageScene=function(player_data){
    GarageScene.superConstructor.apply(this, []);
    this.player_data=player_data;
    this.car_descr=car_descriptions[this.player_data.car.type];
    this.container.header_height=130;
    this.container.background_color=skin.garage.background_color;
    this.container.refresh();
    this.container.on(GUI.EVT_PAINT, this.paintBackground, this);
    this.container.on(GUI.EVT_AFTER_PAINT, this.afterPaint, this);
    this.selected_item=null;
    this.selected_slot=null;
    this.titlelbl=new GUI.Label({'parent':this.container,
                                'position':[210, 40],
                                'text':'Garage',
                                'font':ui.getFont('header_black')});
    
    this.backbtn=new ui.Button({'parent':this.container,
                               'size':[130, 50],
                               'position':[670, 530],
                               'font':ui.getFont(skin.garage.back_button.font),
                               'hover_font':ui.getFont(skin.garage.back_button.hover_font),
                               'fill':skin.garage.back_button.fill,
                               'hover_fill':skin.garage.back_button.hover_fill,
                               'text':'BACK',
                               'lean':'right'});
    
    this.buy_car_btn=new ui.Button({'parent':this.container,
                                   'size':[300, 50],
                                   'position':[350, 530],
                                   'font':ui.getFont('button2_hover'),
                                   'fill':'#006837',
                                   'hover_fill':'#00381C',
                                   'text':'BUY NEW CAR',
                                   'lean':'both'});
    
    this.buy_car_btn.onClick(function(){
        this.game.showCarDealer(this.player_data);
    }, this);
    
    this.balance_label=new GUI.Label({'parent':this.container,
                                     'font':ui.getFont(skin.garage.balance_font),
                                     'position':[8, 172],
                                     'text':'Balance '+this.player_data.balance+'\u20AC'})
    
    //car title
    new GUI.Label({'parent':this.container,
                  'position':[52, 234],
                  'font':ui.getFont(skin.garage.car_title_font),
                  'text':this.car_descr.name});

    
    this.weapon_info=new WeaponInfo({'parent':this.container,
                                    'scene':this,
                                    'position':[270, 160]});
    
    this.tuning=new Tuning({'parent':this.container,
                           'scene':this,
                           'position':[537, 160]});
    
    this.weapon_info.buy_s.button.onClick(this.buyItem, this);
    
    this.backbtn.onClick(function(){
        this.game.returnTo();
    }, this);
    
    this.shop=new Shop({'parent':this.container,
                       'scene':this,
                'position':[275,440]});
    
    this.shop.on('select', this.selectWeapon, this);
    
    
    this.slots={};
    this.slots['front_weapon']=new EquipmentSlot({'parent':this.container,
                                                    'position':[144, 295],
                                                    'scene':this,
                                                    'slot_type':'front_weapon'});
    
    this.slots['util']=new EquipmentSlot({'parent':this.container,
                                        'position':[80, 390],
                                        'scene':this,
                                        'slot_type':'util'});
    
    this.slots['rear_weapon']=new EquipmentSlot({'parent':this.container,
                                                    'position':[107, 505],
                                                    'scene':this,
                                                    'slot_type':'rear_weapon'});
    
    for(var t in this.slots){
        this.slots[t].on('select', this.selectSlot, this);
    }
    this.slots.front_weapon.select();
    
};
gamejs.utils.objects.extend(GarageScene, ui.UIScene);

GarageScene.prototype.selectSlot=function(event){
    this.shop.selectRow(event.item.slot_type);
    this.selected_slot=event.item;
    this.selected_item=event.item;
    this.weapon_info.setItem(event.item);
};

GarageScene.prototype.credit=function(amount){
    if((this.player_data.balance-amount) <0 ){
        this.alert('Insufficient funds!');
        return false;
    }
    
    this.player_data.balance-=amount;
    this.balance_label.setText('Balance '+this.player_data.balance+'\u20AC');
    return true;
};

GarageScene.prototype.buyItem=function(){
    if ((this.player_data.car[this.selected_slot.slot_type]) && (this.selected_item.weapon==this.player_data.car[this.selected_slot.slot_type].type)){
        this.alert('This weapon is already equipped!');
    }
    if(this.credit(this.selected_item.descr.price)){
        this.player_data.car[this.selected_slot.slot_type]={
            'type':this.selected_item.weapon,
            'ammo_upgrades':0,
            'damage_upgrades':0
        };
        this.selected_slot.deselect();
        this.selected_slot.select();
    }
};

GarageScene.prototype.deselectSlots=function(){
    for(var st in this.slots) this.slots[st].deselect();
};

GarageScene.prototype.deselectAll=function(){
    this.shop.deselectAll();
    this.deselectSlots();
};

GarageScene.prototype.selectWeapon=function(event){
    this.deselectSlots();
    var wt=event.item.weapon;
    for(var st in this.slots){
        if((this.player_data.car[this.slots[st].slot_type]) && (event.item.weapon==this.player_data.car[this.slots[st].slot_type].type)){
            event.item.deselect();
            this.slots[st].select();
            return;
        }
    }
    this.weapon_info.setItem(event.item);
    this.selected_item=event.item;
};

GarageScene.prototype.afterPaint=function(){
    //links to selected slot
    if(this.selected_slot){
        var ptlist=[];
        if(this.selected_slot.slot_type=='front_weapon'){
            ptlist=[[270, 290], [230, 290], [230, 315], [195, 315],
                    [195, 320], [230, 320], [230, 460], [270, 460], [270, 455],
                    [235, 455],                    
                    [235, 295], [270, 295]];
        }else if(this.selected_slot.slot_type=='util'){ //315 ->410 320->415
            ptlist=[[270, 290], [230, 290], [230, 410], [130, 410],
                    [130, 415], [230, 415], [230, 460], [270, 460], [270, 455],
                    [235, 455],                    
                    [235, 295], [270, 295]];
        }else if(this.selected_slot.slot_type=='rear_weapon'){//315 ->525 320->530
            ptlist=[[270, 290], [230, 290], [230, 525], [157, 525],
                    [157, 530], [235, 530], [235, 460],  [270, 460], [270, 455],
                    [235, 455],                    
                    [235, 295], [270, 295]];
        }
        if(ptlist){
            gamejs.draw.polygon(this.container.surface, skin.garage.slot_path, ptlist);
        }
    }
};

GarageScene.prototype.paintBackground=function(){
    //balance background
    var ptlist=[[0, 160], [250, 160], [240, 210], [0, 210]];
    gamejs.draw.polygon(this.container.surface, skin.garage.balance_background, ptlist);
    
    //car title background
    gamejs.draw.rect(this.container.surface, skin.garage.car_title_background, new gamejs.Rect([45, 230], [170, 30]));
    
    //car background
    gamejs.draw.rect(this.container.surface, skin.garage.car_background, new gamejs.Rect([45, 260], [170, 310]))
    
    //car image    
    var img=renderer.cache['static'][this.car_descr.art_filename];
    var sz=img.getSize();
    var size=[parseInt((290/sz[1]) * sz[0]), 290];
    this.container.surface.blit(img, [parseInt(45+(170-size[0])/2), 270]);

    //store background
    gamejs.draw.rect(this.container.surface, skin.garage.store_background, new gamejs.Rect([270, 435], [515, 60]));
    
    //store border
    gamejs.draw.rect(this.container.surface, skin.garage.store_border, new gamejs.Rect([273, 438], [509, 54]), 5);
    
    //link from car to tuning
    gamejs.draw.rect(this.container.surface, '#333333', new gamejs.Rect([215, 242], [322, 5]));
    
};

EquipmentSlot=exports.EquipmentSlot=function(pars){
    pars.size=[50, 50];
    EquipmentSlot.superConstructor.apply(this, [pars]);
    this.type='equipment_slot';
    this.slot_type=pars.slot_type;
    this.selected=false;
    this.scene=pars.scene;
    this.on(GUI.EVT_MOUSE_DOWN, this.select, this);
    this.on(GUI.EVT_MOUSE_DOWN, function(){sounds.play({'filename':'button_click.wav'})});
}
gamejs.utils.objects.extend(EquipmentSlot, GUI.View);

EquipmentSlot.prototype.select=function(){
    if(!this.selected){
        this.scene.deselectAll();
        this.selected=true;
        this.despatchEvent({'type':'select', 'item':this});
        this.refresh();
    }
};

EquipmentSlot.prototype.deselect=function(){
    if(this.selected){
        this.selected=false;
        this.refresh();
    }
};

EquipmentSlot.prototype.paint=function(){
    this.surface.clear();
    this.surface.fill(this.selected ? skin.garage.slot_bg_selected : skin.garage.slot_bg);
    gamejs.draw.rect(this.surface, skin.garage.slot_border, new gamejs.Rect([1, 1], [48, 48]), 2)
    
    if(this.scene.player_data.car[this.slot_type]){
        var img=renderer.cache['static'][weapon_descriptions[this.scene.player_data.car[this.slot_type].type].icon];
        var sz=img.getSize();
        this.surface.blit(img, [parseInt((50-sz[0])/2),parseInt((50-sz[1])/2) ]);
    }
}

var WhiteButton=function(pars){
    pars.fill=skin.garage.white_button.bg;
    pars.hover_fill=skin.garage.white_button.bg_hover;
    pars.font=ui.getFont(skin.garage.white_button.font);
    pars.hover_font=ui.getFont(skin.garage.white_button.hover_font);
    pars.lean='none';
    WhiteButton.superConstructor.apply(this, [pars]);  
};

gamejs.utils.objects.extend(WhiteButton, ui.Button);


var BlackButton=function(pars){
    pars.fill='#4D4D4D';
    pars.hover_fill='#F2F2F2';
    pars.font=ui.getFont(skin.garage.white_button.hover_font);
    pars.hover_font=ui.getFont(skin.garage.white_button.font);
    pars.lean='none';
    BlackButton.superConstructor.apply(this, [pars]);  
};

gamejs.utils.objects.extend(BlackButton, ui.Button);

var WeaponInfoBuySpace=function(pars){
    pars.size=[230, 45];
    WeaponInfoBuySpace.superConstructor.apply(this, [pars]);
    
    new GUI.Image({'parent':this,
                  'position':[10, 8],
                  'image':renderer.cache['static']['ico_ammo.png']});
    
    this.ammo_label=new GUI.Label({'position':[50, 14],
                             'parent':this,
                             'text':'0',
                             'font':ui.getFont(skin.garage.weapon_label_font)});
    
    this.damage_icon=new GUI.Image({'parent':this,
                  'position':[85, 8],
                  'image':renderer.cache['static']['ico_damage.png']});
    
    this.damage_label=new GUI.Label({'position':[125, 14],
                             'parent':this,
                             'text':'0',
                             'font':ui.getFont(skin.garage.weapon_label_font)});
    
    this.button=new WhiteButton({'position':[175, 5],
                                'parent':this,
                                'size':[50, 35],
                                'text':'BUY'});
    
    
};

gamejs.utils.objects.extend(WeaponInfoBuySpace, GUI.View);

WeaponInfoBuySpace.prototype.paint=function(){
    this.surface.fill('#CCCCCC');
};



var Tuning=function(pars){
    pars.size=[250, 240];
    Tuning.superConstructor.apply(this, [pars]);
    this.scene=pars.scene;
    
    this.label=new GUI.Label({'parent':this,
                            'font':ui.getFont('g_white_title'),
                            'position':[20, 10],
                            'text':'Tuning'});
    
    new TuningUpgradeSpace({'parent':this,
                           'position':[10,  45],
                           'upgrade_type':UPGRADE_ACC,
                           'scene':this.scene});
    
    new TuningUpgradeSpace({'parent':this,
                           'position':[10,  110],
                           'upgrade_type':UPGRADE_SPEED,
                           'scene':this.scene});
    
    new TuningUpgradeSpace({'parent':this,
                           'position':[10,  175],
                           'upgrade_type':UPGRADE_ARMOR,
                           'scene':this.scene});
};

gamejs.utils.objects.extend(Tuning, GUI.View);

Tuning.prototype.paint=function(){
    //tuning title background
    gamejs.draw.rect(this.surface, skin.garage.tuning_title_background, new gamejs.Rect([0, 0], [250, 40]));
    
    //tuning background
    gamejs.draw.rect(this.surface, skin.garage.tuning_background, new gamejs.Rect([0, 40], [250, 200]));
};

var WeaponInfo=function(pars){
    pars.size=[250, 240];
    WeaponInfo.superConstructor.apply(this, [pars]);
    this.label=new GUI.Label({'parent':this,
                            'font':ui.getFont(skin.garage.weapon_label_font),
                            'position':[20, 10],
                            'text':'I'});
    this.label.setText(' ');
    this.text=new GUI.Text({'parent':this,
                        'width':220,
                       'font':ui.getFont(skin.garage.weapon_info_text_font),
                       'position':[15, 45],
                       'text':'I'});
    this.scene=pars.scene;
    
    
    this.price_label=new GUI.Label({'position':[10, 10],
                             'parent':this,
                             'text':'? \u20AC',
                             'font':ui.getFont(skin.garage.weapon_label_font)});
    
    this.price_label.on(GUI.EVT_RESIZE, function(){
        this.price_label.move([this.getSize()[0]-this.price_label.getSize()[0]-10, this.price_label.getPosition()[1]]);
    }, this);
    
    this.buy_s=new WeaponInfoBuySpace({'parent':this,
                                      'visible':false,
                                      'position':[10, 185]});
    
    this.damage_upgrade=new UpgradeSpace({'parent':this,
                                         'visible':false,
                                         'scene':this.scene,
                                         'upgrade_type':'damage',
                                         'position':[10, 110]});
    
    this.ammo_upgrade=new UpgradeSpace({'parent':this,
                                         'visible':false,
                                         'scene':this.scene,
                                         'upgrade_type':'ammo',
                                         'position':[10, 165]})
};

gamejs.utils.objects.extend(WeaponInfo, GUI.View);

WeaponInfo.prototype.paint=function(){
    //weapon info title background
    gamejs.draw.rect(this.surface, skin.garage.weapon_info_title_background, new gamejs.Rect([0, 0], [250, 40]));
    
    //weapon info background
    gamejs.draw.rect(this.surface, skin.garage.weapon_info_background, new gamejs.Rect([0, 40], [250, 200]));
};

WeaponInfo.prototype.setItem=function(item){
    var descr=false;
    this.item=item;
    if(item.type=='shop_item'){
        descr=item.descr;
        this.buy_s.show();
        this.ammo_upgrade.hide();
        this.damage_upgrade.hide();
        this.price_label.show();
        this.price_label.setText(descr.price+' '+EURO_SYMBOL);
        this.buy_s.ammo_label.setText(String(descr.ammo_capacity));
        
        if(descr.damage_upgrade){
            this.buy_s.damage_label.show();
            this.buy_s.damage_icon.show();
            this.buy_s.damage_label.setText(String(descr.damage));
        }else{
            this.buy_s.damage_label.hide();
            this.buy_s.damage_icon.hide();
        }
    }
    else if(item.type=='equipment_slot'){
        this.buy_s.hide();       
        this.price_label.hide();
        if(this.scene.player_data.car[item.slot_type]){
            descr=weapon_descriptions[this.scene.player_data.car[item.slot_type].type];
            this.ammo_upgrade.show();
            this.ammo_upgrade.setDescr(this.scene.player_data.car[item.slot_type]);
            if(descr.damage_upgrade){
                this.damage_upgrade.show();
                this.damage_upgrade.setDescr(this.scene.player_data.car[item.slot_type]);
            }else{
                this.damage_upgrade.hide();
            }
        }else{
            this.ammo_upgrade.hide();
            this.damage_upgrade.hide();
            this.label.setText(SLOT_TO_LABEL[item.slot_type]);
            this.text.setText('This slot is empty. Buy something from the shop below to fill it!');
        }
    }
    
    if(descr){
        this.label.setText(descr.name);
        this.text.setText(descr.description);
    }
};

var Shop=exports.Shop=function(pars){
    this.rows={};
    this.items=[];
    pars.size=[510, 50];
    this.scene=pars.scene;
    Shop.superConstructor.apply(this, [pars]);
    
    var row=new ShopItemRow({'parent':this,
                            'size':this.getSize(),
                            'position':[0, 0],
                            'type':'front_weapon',
                            'visible':false});
    this.rows['front_weapon']=row;
    
    row=new ShopItemRow({'parent':this,
                        'size':this.getSize(),
                        'position':[0, 0],
                        'type':'util',
                        'visible':false});
    this.rows['util']=row;
    
    row=new ShopItemRow({'parent':this,
                        'size':this.getSize(),
                        'position':[0, 0],
                        'type':'rear_weapon',
                        'visible':false});
    this.rows['rear_weapon']=row;
    
    var descr, item;
    for(var weapon in weapon_descriptions){
        descr=weapon_descriptions[weapon];
        row=this.rows[descr.type];
        if(row.children.length){
            new ShopItemSep({'parent':row});
        }
        item=new ShopItem({'parent':row,
                            'weapon':weapon,
                            'descr':descr});
        item.on('select', this.selectItem, this);
        this.items.push(item);  
    }
    
    for(var type in this.rows){
        GUI.layout.horizontal(this.rows[type].children);
    }
    
};
gamejs.utils.objects.extend(Shop, GUI.View);



Shop.prototype.deselectAll=function(){
    this.items.forEach(function(item){
        item.deselect();
    });
};

Shop.prototype.selectItem=function(event){
    this.despatchEvent(event);  
};

Shop.prototype.selectRow=function(type){
    for(var t in this.rows){
        if(t==type){
            this.rows[t].show();
        }
        else{
            this.rows[t].hide();
        }
    }
};

var ShopItemSep=exports.ShopItemSep=function(pars){
    pars.size=[5, 50];
    ShopItemSep.superConstructor.apply(this, [pars]);
};

gamejs.utils.objects.extend(ShopItemSep, GUI.View);

ShopItemSep.prototype.paint=function(){
    this.surface.clear();
    gamejs.draw.rect(this.surface, skin.garage.store_border, new gamejs.Rect([0, 8], [5, 34]));
};

var ShopItemRow=exports.ShopItemRow=function(pars){
    this.type=pars.type;
    ShopItemRow.superConstructor.apply(this, [pars]);   
};
gamejs.utils.objects.extend(ShopItemRow, GUI.View);
/**
 *
 *descr - weapon description
 */
var ShopItem=exports.ShopItem=function(pars){
    this.descr=pars.descr;
    this.weapon=pars.weapon;
    pars.size=[50, 50];
    ShopItem.superConstructor.apply(this, [pars]);
    this.type='shop_item';
    this.img=renderer.cache['static'][this.descr.icon];
    this.selected=false;
    this.on(GUI.EVT_MOUSE_DOWN, this.select, this);
    this.on(GUI.EVT_MOUSE_DOWN, function(){sounds.play({'filename':'button_click.wav'});});
};
gamejs.utils.objects.extend(ShopItem, GUI.View);

ShopItem.prototype.select=function(){
    if(!this.selected){
        this.parent.parent.scene.deselectAll();
        this.selected=true;
        this.despatchEvent({'type':'select', 'item':this});
        this.refresh();
    }
};

ShopItem.prototype.paint=function(){
    GUI.View.prototype.paint.apply(this, []);
    if(this.selected) this.surface.fill(skin.garage.selected_shop_item_bg);
    var sz=this.img.getSize();
    this.surface.blit(this.img, [parseInt((50-sz[0])/2), parseInt((50-sz[1])/2)]);
};

ShopItem.prototype.deselect=function(){
    if(this.selected){
        this.selected=false;
        this.refresh();
    }
};

var TuningUpgradeSpace=function(pars){
    pars.size=[230, 60];
    this.scene=pars.scene;
    this.upgrade_type=pars.upgrade_type;
    this.descr=car_descriptions[this.scene.player_data.car.type];
    TuningUpgradeSpace.superConstructor.apply(this, [pars]);
   
    new GUI.Label({'parent':this,
                  'position':[20, 0],
                  'parent':this,
                  'font':ui.getFont('g_white_title'),
                  'text':UPGRADE_TYPE_TO_LABEL[this.upgrade_type]});
    
    this.stars=new ui.Stars({'position':[2, 25],
                            'parent':this,
                            'stars':this.getValue()});
    
    this.price_label=new GUI.Label({'position':[0, 29],
                               'parent':this,
                               'text':this.descr.upgrade_price+EURO_SYMBOL,
                               'font':ui.getFont('g_white_title'),
                               'visible':this.getValue()<5});
    
    this.button=new BlackButton({'position':[135, 20],
                                'parent':this,
                                'size':[90, 35],
                                'text':'UPGRADE',
                                'visible':this.getValue()<5});
    
    
    
    this.button.onClick(this.buy, this);
    
    this.price_label.on(GUI.EVT_RESIZE, function(){
        this.price_label.move([this.getSize()[0]-this.button.getSize()[0]-this.price_label.getSize()[0]-10, this.price_label.getPosition()[1]]);
    }, this);
    this.price_label.resize(this.price_label.getSize());
    
};

gamejs.utils.objects.extend(TuningUpgradeSpace, GUI.View);

TuningUpgradeSpace.prototype.getValue=function(){
    return this.scene.player_data.car[this.upgrade_type];
};


TuningUpgradeSpace.prototype.buy=function(){
    if(this.getValue()>=5){
        this.scene.alert('Upgrade maxed out!');
        return;
    }
    
    if(this.scene.credit(this.descr.upgrade_price)){
        this.scene.player_data.car[this.upgrade_type]++;
        this.stars.setStars(this.getValue());
        if(this.getValue()>=5){
            this.price_label.hide();
            this.button.hide();
        }
    }
};

TuningUpgradeSpace.prototype.paint=function(){
    this.surface.clear();
    gamejs.draw.rect(this.surface, '#333333', new gamejs.Rect([0, 15], [this.getSize()[0], this.getSize()[1]-15]));
};

var UpgradeSpace=function(pars){
    pars.size=[230, 60];
    this.upgrade_type=pars.upgrade_type;
    this.descr=null;
    this.weapon_descr=null;
    this.scene=pars.scene;
    UpgradeSpace.superConstructor.apply(this, [pars]);
    
    new GUI.Image({'parent':this,
                  'position':[5, 23],
                  'image':renderer.cache['static']['ico_'+this.upgrade_type+'.png']});
    
    this.stars=new ui.Stars({'position':[40, 0],
                            'parent':this,
                            'stars':0})
    
    this.label=new GUI.Label({'position':[35, 29],
                             'parent':this,
                             'text':'0',
                             'font':ui.getFont(skin.garage.weapon_label_font)});
    
    this.price_label=new GUI.Label({'position':[0, 29],
                               'parent':this,
                               'text':'0 '+EURO_SYMBOL,
                               'font':ui.getFont(skin.garage.weapon_label_font)})
    
    
    
    this.button=new WhiteButton({'position':[135, 20],
                                'parent':this,
                                'size':[90, 35],
                                'text':'UPGRADE'});
    
    
    
    this.button.onClick(this.buy, this);
    
    this.price_label.on(GUI.EVT_RESIZE, function(){
        this.price_label.move([this.getSize()[0]-this.button.getSize()[0]-this.price_label.getSize()[0]-10, this.price_label.getPosition()[1]]);
    }, this);
};


gamejs.utils.objects.extend(UpgradeSpace, GUI.View);

UpgradeSpace.prototype.setDescr=function(descr){
    this.descr=descr;
    if(descr){
        this.weapon_descr=weapon_descriptions[this.descr.type];
        var upgrades=this.descr[this.upgrade_type+'_upgrades'];
        this.stars.setStars(upgrades);
        this.label.setText(String(this.getCurValue()));
        this.price_label.setText(this.weapon_descr[this.upgrade_type+'_upgrade_price']+EURO_SYMBOL);
        if(upgrades<5){
            this.button.show();
            this.price_label.show();
        } else {
            this.button.hide();
            this.price_label.hide();
        }
    }
};

UpgradeSpace.prototype.buy=function(){
    if(this.descr[this.upgrade_type+'_upgrades']>=5) return;
    if(this.scene.credit(this.weapon_descr[this.upgrade_type+'_upgrade_price'])){
        this.descr[this.upgrade_type+'_upgrades']++;
        this.setDescr(this.descr);
    }
};  

UpgradeSpace.prototype.getCurValue=function(){
  return (this.upgrade_type=='damage' ? this.weapon_descr.damage : this.weapon_descr.ammo_capacity)+(this.descr[this.upgrade_type+'_upgrades']* this.weapon_descr[this.upgrade_type+'_upgrade'])};


UpgradeSpace.prototype.paint=function(){
    this.surface.clear();
    gamejs.draw.rect(this.surface, '#CCCCCC', new gamejs.Rect([0, 15], [this.getSize()[0], this.getSize()[1]-15]));
};


var BuyCarScene=exports.BuyCarScene=function(player_data){
    BuyCarScene.superConstructor.apply(this, []);
    this.player_data=player_data;
    this.container.header_height=130;
    this.container.background_color=skin.garage.background_color;
    this.container.on(GUI.EVT_PAINT, this.paint, this);
    this.container.refresh();
    
    this.titlelbl=new GUI.Label({'parent':this.container,
                                'position':[210, 40],
                                'text':'Car Deal',
                                'font':ui.getFont('header_black')});
    
    this.backbtn=new ui.Button({'parent':this.container,
                               'size':[130, 50],
                               'position':[0, 540],
                               'font':ui.getFont(skin.garage.back_button.font),
                               'hover_font':ui.getFont(skin.garage.back_button.hover_font),
                               'fill':skin.garage.back_button.fill,
                               'hover_fill':skin.garage.back_button.hover_fill,
                               'text':'BACK',
                               'lean':'left'});
    
    this.backbtn.onClick(function(){
        this.game.showGarage(this.player_data);
    }, this);
    
    
    this.car_list=new CarList({'position':[25, 160],
                              'parent':this.container,
                              'scene':this});
    
    this.carinfo=new CarInfo({'position':[800-350, 160],
                             'parent':this.container,
                             'scene':this});
    
    this.balance_label=new GUI.Label({'parent':this.container,
                                     'font':ui.getFont(skin.garage.balance_font),
                                     'position':[260, 550],
                                     'text':'Balance '+this.player_data.balance+'\u20AC'});
    
    this.buy_car_btn=new ui.Button({'parent':this.container,
                                   'size':[100, 50],
                                   'position':[700, 540],
                                   'font':ui.getFont('button2_hover'),
                                   'fill':'#006837',
                                   'hover_fill':'#00381C',
                                   'text':'BUY',
                                   'lean':'right',
                                   'visible':false});
    
    this.buy_car_btn.onClick(this.buy, this);
};

gamejs.utils.objects.extend(BuyCarScene, ui.UIScene);

BuyCarScene.prototype.paint=function(){
    gamejs.draw.rect(this.container.surface, '#B3B3B3',
                     new gamejs.Rect([250, 540], [300, 50]));
};

BuyCarScene.prototype.buy=function(){
    if(this.carinfo.descr){
        if(this.credit(this.carinfo.descr.price)){
            this.player_data.car.type=this.carinfo.descr.id;
            this.player_data.car.acc_upgrades=0;
            this.player_data.car.speed_upgrades=0;
            this.player_data.car.armor_upgrades=0;
            this.game.showGarage(this.player_data);
        }
    };
};

BuyCarScene.prototype.credit=function(amount){
    if((this.player_data.balance-amount) <0 ){
        this.alert('Insufficient funds!');
        return false;
    }
    
    this.player_data.balance-=amount;
    this.balance_label.setText('Balance '+this.player_data.balance+'\u20AC');
    return true;
};

var CarListSep=function(pars){
    CarListSep.superConstructor.apply(this, [pars]);
};
gamejs.utils.objects.extend(CarListSep, GUI.View);

CarListSep.prototype.paint=function(){
    this.surface.fill('#CCCCCC');
};

var CarListItem=function(pars){
    this.descr=pars.descr;
    CarListItem.superConstructor.apply(this, [pars]);
    var w=this.getSize()[0];
    var h=this.getSize()[1];
    
    var img=renderer.cache.getCarSprite(this.descr.filenames[0], 0);
    new GUI.Image({'parent':this,
                    'image':img,
                    'position':[5+parseInt(((50)-img.getSize()[0])/2), 5+parseInt(((h-10)-img.getSize()[1])/2)]});
              
    new GUI.Label({'parent':this,
                  'font':ui.getFont('16_33'),
                  'text':this.descr.name,
                  'position':[60, 5]});
    
    new GUI.Text({'parent':this,
                 'font':ui.getFont('13_grayish'),
                 'text':this.descr.description,
                 'width':w-h,
                 'position':[60, 28]});
    
    var lbl= new GUI.Label({'parent':this,
                  'font':ui.getFont('16_33'),
                  'text':this.descr.price+EURO_SYMBOL,
                  'position':[w-100, h-25]});
    
    lbl.move([this.getSize()[0]-lbl.getSize()[0]-10, lbl.getPosition()[1]]);
    
    this.on(GUI.EVT_MOUSE_DOWN, function(){
        sounds.play({'filename':'button_click.wav'});
        this.parent.parent.scene.carinfo.setDescr(this.descr);
    }, this);
    
};

gamejs.utils.objects.extend(CarListItem, GUI.View);

CarListItem.prototype.paint=function(){
    if(this.isHovered()){
        this.surface.fill('#E2E2E2');
    }else{
        this.surface.clear();
    }
};

var CarList=function(pars){
    pars.size=[330, 360];
    this.scene=pars.scene;
    CarList.superConstructor.apply(this, [pars]);
    
    this.scw=new GUI.ScrollableView({'parent':this,
                                    'position':[5, 5],
                                    'size':[this.getSize()[0]-25, this.getSize()[1]-10]});
    
    var scrollbar=new GUI.VerticalScrollbar({'parent':this,
                                            'position':[this.getSize()[0]-20, 5],
                                            'size':[20, this.getSize()[1]-10]});
    this.scw.setVerticalScrollbar(scrollbar);
    
    var descrs=[];
    for(var id in car_descriptions){
        descrs.push(car_descriptions[id]);
    }
    
    descrs.sort(function(a, b){
        return a.price-b.price;
    });
    
    descrs.forEach(function(descr){
        if(this.scw.children.length){
            new CarListSep({'parent':this.scw,
                           'position':[10, 0],
                           'size':[this.scw.getSize()[0]-20, 5]});
        }
        new CarListItem({'parent':this.scw,
                        'size':[this.scw.getSize()[0], 100],
                        'descr':descr});
    }, this);
    GUI.layout.vertical(this.scw.children);
    this.scw.autoSetScrollableArea();
};

gamejs.utils.objects.extend(CarList, GUI.View);

CarList.prototype.paint=function(){
    this.surface.clear();
    var h=this.getSize()[1];
    var w=this.getSize()[0];
    gamejs.draw.rect(this.surface, '#999999', new gamejs.Rect([0, 0], [w, 5]));
    gamejs.draw.rect(this.surface, '#999999', new gamejs.Rect([0, h-5], [w, 5]));
    
    gamejs.draw.rect(this.surface, '#999999', new gamejs.Rect([0, 5], [5, h-10]));
   // gamejs.draw.rect(this.surface, '#CCCCCC', new gamejs.Rect([w-20, 5], [20, h-10]));
    
    gamejs.draw.rect(this.surface, '#F2F2F2', new gamejs.Rect([5, 5], [w-5, h-10]));
};

var CarInfo=function(pars){
    pars.size=[330, 360];
    this.scene=pars.scene;
    this.descr=null;
    CarInfo.superConstructor.apply(this, [pars]);
    this.carimg=null;
    
    this.cartitle=new GUI.Label({'parent':this,
                                'position':[20, 178],
                                'text':'Car not selected',
                                'font':ui.getFont('alias')});
    
    this.cardescr=new GUI.Text({'parent':this,
                               'position':[20, 213],
                               'width':310,
                               'font':ui.getFont('16_33'),
                               'text':'Select a car!'});
    
    this.pricelabel=new GUI.Label({'parent':this,
                                  'position':[230, 178],
                                  'font':ui.getFont('alias'),
                                  'text':'0'+EURO_SYMBOL,
                                  'visible':false});
    
    this.acceleration_label=new GUI.Label({'parent':this,
                                 'position':[20, 240],
                                 'font':ui.getFont('16_33'),
                                 'text':'Acceleration:',
                                 'visible':false});
    
    this.acceleration_stars=new ui.Stars({'parent':this,
                                         'position':[135, 240],
                                         'stars':0,
                                        'visible':false});
    
    this.speed_label=new GUI.Label({'parent':this,
                                 'position':[20, 270],
                                 'font':ui.getFont('16_33'),
                                 'text':'Top Speed:',
                                 'visible':false});
    
    this.speed_stars=new ui.Stars({'parent':this,
                                         'position':[135, 270],
                                         'stars':0,
                                 'visible':false});
    
    this.armor_label=new GUI.Label({'parent':this,
                                 'position':[20, 300],
                                 'font':ui.getFont('16_33'),
                                 'text':'Armor:',
                                 'visible':false});
    
    this.armor_stars=new ui.Stars({'parent':this,
                                    'position':[135, 300],
                                    'stars':0,
                                 'visible':false});
    
    this.handling_label=new GUI.Label({'parent':this,
                                 'position':[20, 330],
                                 'font':ui.getFont('16_33'),
                                 'text':'Handling:',
                                 'visible':false});
    
    this.handling_stars=new ui.Stars({'parent':this,
                                    'position':[135, 330],
                                    'stars':0,
                                 'visible':false});
    
    
    
    
    this.pricelabel.on(GUI.EVT_RESIZE, function(){
        this.pricelabel.move([this.getSize()[0]-this.pricelabel.getSize()[0]-10, this.pricelabel.getPosition()[1]]);
    }, this);
};

gamejs.utils.objects.extend(CarInfo, GUI.View);


CarInfo.prototype.paint=function(){
    this.surface.fill('#B3B3B3');
    gamejs.draw.rect(this.surface, '#F5F5F5', new gamejs.Rect([0, 0], [this.getSize()[0], 180]));
    if(this.carimg){
        this.surface.blit(this.carimg, [20, 5]);
    }
    
    
};

CarInfo.prototype.setDescr=function(descr){
    this.descr=descr;
    this.carimg=gamejs.transform.rotate(renderer.cache['static'][this.descr.art_filename], 90);
    this.cartitle.setText(descr.name);
    this.cardescr.setText(descr.description);
    this.pricelabel.show();
    if(this.scene.player_data.car.type!=descr.id){
        this.pricelabel.setText(descr.price+EURO_SYMBOL);
        this.scene.buy_car_btn.show();
    }else{
        this.pricelabel.setText('OWNED');
        this.scene.buy_car_btn.hide();
    }
    this.acceleration_stars.setStars(descr.acceleration_stars);
    this.speed_stars.setStars(descr.speed_stars);
    this.armor_stars.setStars(descr.armor_stars);
    this.handling_stars.setStars(descr.handling_stars);
    
    this.acceleration_label.show();
    this.armor_label.show();
    this.speed_label.show();
    this.handling_label.show();
    this.acceleration_stars.show();
    this.speed_stars.show();
    this.armor_stars.show();
    this.handling_stars.show();
    
    
    
    this.refresh();
};
},{"./car_descriptions":4,"./combatracer":6,"./gamejs-gui":18,"./levels":22,"./renderer":26,"./skin":29,"./sounds":30,"./ui":31,"./utils":33,"./weapon_descriptions":34,"gamejs":37}],21:[function(require,module,exports){
exports[0]={'name':'Begginer League',
            'tracks':['drycircuit', 'snowpeakcircuit', 'greenring', 'frogfoot', '1_bloodbathlane'],
            'bots':['Bob', 'CatLady', 'Dominator'],
            'reward_1':1000,
            'reward_2':600,
            'reward_3':300};
            
exports[1] = {'name':'Veteran League',
	            'tracks':['spiralraceway', 'deathvalley', '2_icemanloops', '2_vultureplains', '2_queersands'],
	            'bots':['HotShot', 'TheDude', 'Ratman'],
	            'reward_1':2000,
	            'reward_2':1000,
	            'reward_3':500};
            
exports[2] = {'name':'Badass League',
			  'tracks':['3_bullpen', '3_hunter_end', '3_lullabycircuit', '3_peril_flats', '3_radiator'],
			  'bots':['Bulldog', 'JC', 'PainKid'],
			  'reward_1':3500,
			  'reward_2':2000,
			  'reward_3':1000};

},{}],22:[function(require,module,exports){
var resources=require('./resources');
var gamejs=require('gamejs');

try{
	var compiled = require('./levels_compiled').levels;
}catch(e){
	var compiled = {};
}

exports.all = [];
exports.init=function(){
	if(!exports.all.length){
	    var lname='';
	    for(var i=0; i<resources.levels.length;i++){
	        lname=resources.levels[i];
	        var level;
	        if(compiled[lname]) level = compiled[lname];
	        else level = gamejs.http.load('/levels/'+lname+'.json');
	        level.id = lname;
	        exports[lname] = level;
	        exports.all.push(level);
	    }
	}
}

},{"./levels_compiled":23,"./resources":27,"gamejs":37}],23:[function(require,module,exports){
exports.levels={"snowpeakcircuit":{"size":[2800,2200],"title":"Snowpeak Circuit","bgtile":"snow.png","props":[{"p":[233,677],"f":1,"a":0},{"p":[359,647],"f":2,"a":0},{"p":[373,620],"f":2,"a":0},{"p":[396,600],"f":2,"a":0},{"p":[426,588],"f":2,"a":0},{"p":[458,465],"f":1,"a":270},{"p":[729,553],"f":3,"a":270},{"p":[820,554],"f":3,"a":270},{"p":[912,588],"f":2,"a":0},{"p":[942,601],"f":2,"a":0},{"p":[963,622],"f":2,"a":0},{"p":[981,650],"f":2,"a":0},{"p":[955,680],"f":3,"a":180},{"p":[952,762],"f":3,"a":165},{"p":[982,844],"f":3,"a":150},{"p":[1035,914],"f":3,"a":135},{"p":[1117,965],"f":3,"a":105},{"p":[1216,986],"f":3,"a":90},{"p":[1308,896],"f":1,"a":270},{"p":[1580,986],"f":3,"a":90},{"p":[1673,987],"f":3,"a":90},{"p":[1746,949],"f":3,"a":60},{"p":[1817,895],"f":3,"a":45},{"p":[1869,821],"f":3,"a":30},{"p":[1906,747],"f":3,"a":0},{"p":[1907,657],"f":3,"a":0},{"p":[1952,629],"f":2,"a":0},{"p":[1974,608],"f":2,"a":0},{"p":[2002,589],"f":2,"a":0},{"p":[2033,465],"f":1,"a":270},{"p":[2293,551],"f":3,"a":285},{"p":[2360,595],"f":3,"a":150},{"p":[2306,697],"f":1,"a":180},{"p":[2307,969],"f":1,"a":180},{"p":[2398,1243],"f":3,"a":180},{"p":[2415,1319],"f":3,"a":165},{"p":[2435,1418],"f":3,"a":180},{"p":[2412,1502],"f":3,"a":195},{"p":[2398,1600],"f":3,"a":180},{"p":[2349,1667],"f":3,"a":225},{"p":[2104,1628],"f":1,"a":90},{"p":[2011,1716],"f":3,"a":270},{"p":[1917,1657],"f":3,"a":315},{"p":[1909,1594],"f":3,"a":0},{"p":[1896,1494],"f":3,"a":345},{"p":[1857,1403],"f":3,"a":330},{"p":[1800,1329],"f":3,"a":315},{"p":[1731,1288],"f":3,"a":285},{"p":[1470,1197],"f":1,"a":90},{"p":[1200,1198],"f":1,"a":90},{"p":[928,1196],"f":1,"a":90},{"p":[655,1199],"f":1,"a":90},{"p":[562,1288],"f":3,"a":270},{"p":[472,1290],"f":3,"a":270},{"p":[369,1259],"f":3,"a":300},{"p":[319,1201],"f":3,"a":345},{"p":[231,942],"f":1,"a":0},{"p":[427,1424],"f":1,"a":270},{"p":[697,1423],"f":1,"a":270},{"p":[969,1424],"f":1,"a":270},{"p":[1240,1424],"f":1,"a":270},{"p":[1512,1515],"f":3,"a":270},{"p":[1583,1512],"f":3,"a":300},{"p":[1646,1576],"f":3,"a":330},{"p":[1677,1678],"f":3,"a":0},{"p":[1676,1757],"f":3,"a":345},{"p":[1711,1834],"f":3,"a":330},{"p":[1778,1893],"f":3,"a":300},{"p":[1871,1930],"f":3,"a":285},{"p":[1971,1860],"f":1,"a":270},{"p":[2242,1859],"f":1,"a":270},{"p":[2490,1905],"f":3,"a":240},{"p":[2556,1840],"f":3,"a":210},{"p":[2601,1763],"f":3,"a":195},{"p":[2626,1683],"f":3,"a":180},{"p":[2535,1411],"f":1,"a":180},{"p":[2535,1137],"f":1,"a":180},{"p":[2536,865],"f":1,"a":180},{"p":[2534,593],"f":1,"a":180},{"p":[2599,493],"f":3,"a":165},{"p":[2554,405],"f":3,"a":150},{"p":[2486,347],"f":3,"a":120},{"p":[2407,322],"f":3,"a":105},{"p":[2322,325],"f":3,"a":90},{"p":[2046,235],"f":1,"a":90},{"p":[1953,322],"f":3,"a":90},{"p":[1852,325],"f":3,"a":75},{"p":[1761,362],"f":3,"a":60},{"p":[1700,433],"f":3,"a":30},{"p":[1676,523],"f":3,"a":15},{"p":[1675,623],"f":3,"a":0},{"p":[1639,693],"f":3,"a":30},{"p":[1646,783],"f":2,"a":0},{"p":[1376,670],"f":1,"a":90},{"p":[1286,754],"f":3,"a":90},{"p":[1190,697],"f":3,"a":135},{"p":[1186,633],"f":3,"a":180},{"p":[1186,543],"f":3,"a":180},{"p":[1142,441],"f":3,"a":150},{"p":[1080,367],"f":3,"a":135},{"p":[1006,331],"f":3,"a":105},{"p":[746,238],"f":1,"a":90},{"p":[473,239],"f":1,"a":90},{"p":[382,325],"f":3,"a":90},{"p":[290,334],"f":3,"a":75},{"p":[206,366],"f":3,"a":60},{"p":[138,427],"f":3,"a":45},{"p":[100,511],"f":3,"a":15},{"p":[89,605],"f":3,"a":0},{"p":[1,695],"f":1,"a":0},{"p":[2,967],"f":1,"a":0},{"p":[335,1517],"f":3,"a":270},{"p":[220,1472],"f":3,"a":300},{"p":[143,1412],"f":3,"a":315},{"p":[101,1346],"f":3,"a":345},{"p":[92,1238],"f":3,"a":0},{"p":[125,1327],"f":2,"a":0}],"decals":[{"p":[156,1230],"f":4,"a":270},{"p":[468,1302],"f":5,"a":0},{"p":[756,1302],"f":5,"a":0},{"p":[1044,1302],"f":5,"a":0},{"p":[1332,1302],"f":5,"a":0},{"p":[1620,1350],"f":4,"a":90},{"p":[1740,1662],"f":4,"a":270},{"p":[2052,1734],"f":5,"a":0},{"p":[2340,1662],"f":4,"a":180},{"p":[2460,1470],"f":6,"a":0},{"p":[2460,1278],"f":7,"a":0},{"p":[2460,1086],"f":8,"a":0},{"p":[2460,894],"f":8,"a":0},{"p":[2460,702],"f":8,"a":0},{"p":[2340,390],"f":4,"a":90},{"p":[2052,342],"f":5,"a":180},{"p":[1740,390],"f":4,"a":0},{"p":[1620,702],"f":4,"a":180},{"p":[1332,774],"f":5,"a":180},{"p":[1020,702],"f":4,"a":270},{"p":[900,390],"f":4,"a":90},{"p":[612,342],"f":5,"a":180},{"p":[108,942],"f":5,"a":270},{"p":[156,750],"f":8,"a":0},{"p":[156,390],"f":4,"a":0},{"p":[468,390],"f":8,"a":90},{"p":[156,702],"f":8,"a":180},{"p":[1374,1356],"f":9,"a":270},{"p":[1374,1434],"f":9,"a":270},{"p":[1356,1368],"f":10,"a":90},{"p":[1260,1476],"f":10,"a":90},{"p":[1164,1368],"f":10,"a":90},{"p":[1050,1476],"f":10,"a":90},{"p":[948,1368],"f":10,"a":90},{"p":[828,1476],"f":10,"a":90}],"laps":4,"ai_waypoints":[{"p":[1459,1440],"n":1},{"p":[1728,1536],"n":2},{"p":[1954,1793],"n":3},{"p":[2420,1800],"n":4},{"p":[2527,1549],"n":5},{"p":[2566,1121],"n":6},{"p":[2580,824],"n":7},{"p":[2411,548],"n":8},{"p":[1916,556],"n":9},{"p":[1676,829],"n":10},{"p":[1205,822],"n":11},{"p":[981,549],"n":12},{"p":[363,526],"n":13},{"p":[218,866],"n":14},{"p":[279,1336],"n":15}],"checkpoints":[{"p":[1418,1297],"n":1},{"p":[2035,1746],"n":2},{"p":[2433,1140],"n":3},{"p":[2377,416],"n":4},{"p":[1729,420],"n":5},{"p":[991,685],"n":6},{"p":[163,380],"n":7},{"p":[176,1264],"n":8}],"start_positions":[{"p":[1306,1361],"n":1,"a":90},{"p":[1214,1469],"n":2,"a":90},{"p":[1116,1362],"n":3,"a":90},{"p":[1000,1469],"n":4,"a":90},{"p":[901,1364],"n":5,"a":90},{"p":[780,1471],"n":6,"a":90}],"dict":{"1":"9tires.png","2":"tire.png","3":"3tires.png","4":"dideliskampas.png","5":"ilgas.png","6":"sonaslenktas2.png","7":"sonaslenktas1.png","8":"paprastas.png","9":"startbar.png","10":"white_bar.png"}},"drycircuit":{"size":[2800,1700],"title":"Dry Circuit","bgtile":"sand.png","props":[{"p":[1511,1097],"f":1,"a":270},{"p":[1781,1096],"f":1,"a":270},{"p":[2052,1096],"f":1,"a":270},{"p":[2323,1185],"f":2,"a":270},{"p":[2394,1150],"f":2,"a":240},{"p":[2448,1085],"f":2,"a":195},{"p":[2379,822],"f":1,"a":180},{"p":[2420,723],"f":2,"a":135},{"p":[2362,701],"f":2,"a":90},{"p":[2269,699],"f":2,"a":90},{"p":[2170,732],"f":2,"a":0},{"p":[2234,728],"f":3,"a":0},{"p":[2158,814],"f":2,"a":15},{"p":[2123,893],"f":2,"a":30},{"p":[2065,960],"f":2,"a":45},{"p":[1993,1013],"f":2,"a":75},{"p":[1908,1035],"f":2,"a":90},{"p":[1636,947],"f":1,"a":90},{"p":[1362,947],"f":1,"a":90},{"p":[1270,1042],"f":2,"a":90},{"p":[1168,1023],"f":2,"a":105},{"p":[1078,976],"f":2,"a":135},{"p":[1023,905],"f":2,"a":150},{"p":[932,654],"f":1,"a":0},{"p":[932,383],"f":1,"a":0},{"p":[1022,291],"f":2,"a":180},{"p":[1052,258],"f":3,"a":0},{"p":[962,854],"f":2,"a":210},{"p":[897,921],"f":2,"a":240},{"p":[821,961],"f":2,"a":255},{"p":[559,892],"f":1,"a":270},{"p":[468,982],"f":2,"a":270},{"p":[377,981],"f":2,"a":270},{"p":[277,991],"f":2,"a":225},{"p":[258,1087],"f":2,"a":180},{"p":[282,1141],"f":2,"a":135},{"p":[373,1180],"f":2,"a":105},{"p":[464,1250],"f":3,"a":0},{"p":[494,1132],"f":1,"a":270},{"p":[765,1135],"f":1,"a":270},{"p":[1038,1133],"f":1,"a":270},{"p":[1310,1223],"f":2,"a":90},{"p":[1387,1204],"f":2,"a":75},{"p":[1483,1220],"f":3,"a":0},{"p":[1517,1325],"f":1,"a":270},{"p":[1788,1324],"f":1,"a":270},{"p":[2060,1325],"f":1,"a":270},{"p":[2331,1414],"f":2,"a":90},{"p":[2420,1411],"f":2,"a":90},{"p":[2501,1394],"f":2,"a":75},{"p":[2582,1352],"f":2,"a":60},{"p":[2642,1287],"f":2,"a":30},{"p":[2680,1206],"f":2,"a":15},{"p":[2606,946],"f":1,"a":180},{"p":[2605,674],"f":1,"a":180},{"p":[2650,572],"f":2,"a":330},{"p":[2587,505],"f":2,"a":300},{"p":[2506,473],"f":2,"a":285},{"p":[2247,384],"f":1,"a":90},{"p":[2156,472],"f":2,"a":270},{"p":[2059,467],"f":2,"a":255},{"p":[1975,507],"f":2,"a":225},{"p":[1940,596],"f":2,"a":195},{"p":[1940,698],"f":2,"a":180},{"p":[1882,757],"f":2,"a":225},{"p":[1639,715],"f":1,"a":90},{"p":[1368,716],"f":1,"a":90},{"p":[1337,836],"f":3,"a":0},{"p":[1305,835],"f":3,"a":0},{"p":[1286,808],"f":3,"a":0},{"p":[1166,536],"f":1,"a":0},{"p":[1168,261],"f":1,"a":0},{"p":[1257,170],"f":2,"a":0},{"p":[1215,67],"f":2,"a":330},{"p":[1148,4],"f":2,"a":300},{"p":[1079,-5],"f":2,"a":270},{"p":[987,-7],"f":2,"a":270},{"p":[883,-5],"f":2,"a":240},{"p":[811,49],"f":2,"a":225},{"p":[780,135],"f":2,"a":195},{"p":[697,236],"f":1,"a":0},{"p":[789,508],"f":2,"a":180},{"p":[790,599],"f":2,"a":180},{"p":[760,671],"f":2,"a":210},{"p":[698,733],"f":2,"a":255},{"p":[436,661],"f":1,"a":270},{"p":[342,752],"f":2,"a":270},{"p":[249,753],"f":2,"a":270},{"p":[145,766],"f":2,"a":240},{"p":[66,821],"f":2,"a":225},{"p":[27,902],"f":2,"a":195},{"p":[-69,1000],"f":1,"a":180},{"p":[29,1253],"f":2,"a":150},{"p":[80,1327],"f":2,"a":135},{"p":[160,1384],"f":2,"a":105},{"p":[258,1413],"f":2,"a":90},{"p":[350,1416],"f":2,"a":90},{"p":[419,1379],"f":2,"a":60},{"p":[523,1284],"f":1,"a":90},{"p":[795,1281],"f":1,"a":90},{"p":[1066,1281],"f":1,"a":90},{"p":[1338,1370],"f":2,"a":90},{"p":[1412,1375],"f":2,"a":120}],"decals":[{"p":[852,60],"f":4,"a":0},{"p":[1068,60],"f":4,"a":90},{"p":[1044,276],"f":5,"a":90},{"p":[804,270],"f":5,"a":90},{"p":[1044,558],"f":5,"a":90},{"p":[1092,846],"f":4,"a":270},{"p":[1308,822],"f":5,"a":180},{"p":[1596,822],"f":5,"a":180},{"p":[1884,750],"f":6,"a":180},{"p":[2004,534],"f":4,"a":0},{"p":[2220,534],"f":7,"a":270},{"p":[2412,534],"f":6,"a":90},{"p":[2484,846],"f":5,"a":270},{"p":[2412,1128],"f":6,"a":180},{"p":[2124,1200],"f":5,"a":0},{"p":[1836,1200],"f":5,"a":0},{"p":[1548,1200],"f":5,"a":0},{"p":[1356,1248],"f":8,"a":0},{"p":[1164,1248],"f":9,"a":0},{"p":[972,1248],"f":9,"a":0},{"p":[780,1248],"f":9,"a":0},{"p":[588,1248],"f":9,"a":0},{"p":[396,1248],"f":8,"a":180},{"p":[84,1128],"f":6,"a":270},{"p":[84,816],"f":6,"a":0},{"p":[396,768],"f":5,"a":180},{"p":[732,696],"f":6,"a":180},{"p":[852,552],"f":10,"a":180},{"p":[852,504],"f":10,"a":180},{"p":[594,816],"f":10,"a":270},{"p":[1656,1260],"f":11,"a":90},{"p":[1758,1374],"f":11,"a":90},{"p":[1866,1260],"f":11,"a":90},{"p":[1980,1374],"f":11,"a":90},{"p":[2100,1260],"f":11,"a":90},{"p":[2214,1374],"f":11,"a":90},{"p":[2226,1254],"f":12,"a":270},{"p":[2226,1332],"f":12,"a":270}],"laps":4,"ai_waypoints":[{"p":[2476,1270],"n":1},{"p":[2640,980],"n":2},{"p":[2493,656],"n":3},{"p":[2154,650],"n":4},{"p":[1906,893],"n":5},{"p":[1520,981],"n":6},{"p":[1221,840],"n":7},{"p":[1228,431],"n":8},{"p":[1215,319],"n":9},{"p":[966,618],"n":12},{"p":[818,852],"n":13},{"p":[251,984],"n":14},{"p":[223,1208],"n":15},{"p":[495,1343],"n":16},{"p":[1444,1323],"n":17},{"p":[1050,152],"n":10},{"p":[891,323],"n":11}],"checkpoints":[{"p":[2270,1203],"n":1},{"p":[2427,526],"n":2},{"p":[1900,777],"n":3},{"p":[1068,793],"n":4},{"p":[931,24],"n":5},{"p":[733,743],"n":6},{"p":[163,777],"n":7},{"p":[304,1201],"n":8}],"start_positions":[{"p":[2168,1369],"n":1,"a":90},{"p":[2054,1252],"n":2,"a":90},{"p":[1935,1371],"n":3,"a":90},{"p":[1822,1255],"n":4,"a":90},{"p":[1715,1367],"n":5,"a":90},{"p":[1611,1256],"n":6,"a":90}],"dict":{"1":"9tires.png","2":"3tires.png","3":"tire.png","4":"lenktas.png","5":"ilgas.png","6":"dideliskampas.png","7":"paprastas.png","8":"siaurasiplatu.png","9":"siauras.png","10":"trumpas.png","11":"white_bar.png","12":"startbar.png"}},"deathvalley":{"size":[2400,2200],"title":"Death Valley","bgtile":"sand.png","props":[{"p":[233,455],"f":1,"a":0},{"p":[329,351],"f":2,"a":30},{"p":[404,314],"f":2,"a":255},{"p":[504,225],"f":1,"a":270},{"p":[778,225],"f":1,"a":270},{"p":[913,378],"f":1,"a":180},{"p":[972,618],"f":2,"a":270},{"p":[869,611],"f":2,"a":255},{"p":[780,634],"f":2,"a":240},{"p":[709,687],"f":2,"a":225},{"p":[671,774],"f":2,"a":195},{"p":[578,876],"f":1,"a":180},{"p":[671,1151],"f":2,"a":180},{"p":[672,1244],"f":2,"a":180},{"p":[702,1335],"f":3,"a":0},{"p":[462,1248],"f":1,"a":90},{"p":[369,1338],"f":2,"a":90},{"p":[234,1097],"f":1,"a":0},{"p":[234,827],"f":1,"a":0},{"p":[323,732],"f":2,"a":0},{"p":[366,-3],"f":1,"a":270},{"p":[639,-4],"f":1,"a":270},{"p":[912,85],"f":2,"a":270},{"p":[1003,83],"f":2,"a":270},{"p":[1084,82],"f":2,"a":285},{"p":[1153,119],"f":2,"a":315},{"p":[1214,200],"f":2,"a":345},{"p":[1237,301],"f":2,"a":0},{"p":[1148,395],"f":1,"a":180},{"p":[1300,525],"f":1,"a":270},{"p":[1571,614],"f":2,"a":270},{"p":[1630,556],"f":2,"a":225},{"p":[1584,314],"f":1,"a":180},{"p":[1677,213],"f":2,"a":210},{"p":[1738,145],"f":2,"a":240},{"p":[1841,137],"f":2,"a":270},{"p":[1933,137],"f":2,"a":270},{"p":[2012,137],"f":2,"a":285},{"p":[2081,178],"f":2,"a":330},{"p":[2129,269],"f":2,"a":345},{"p":[2058,372],"f":1,"a":180},{"p":[2109,622],"f":2,"a":30},{"p":[2106,727],"f":2,"a":0},{"p":[2108,821],"f":2,"a":0},{"p":[2125,897],"f":2,"a":345},{"p":[1824,398],"f":1,"a":180},{"p":[1969,665],"f":3,"a":0},{"p":[1956,699],"f":2,"a":0},{"p":[1957,794],"f":2,"a":0},{"p":[1889,663],"f":2,"a":15},{"p":[1836,731],"f":2,"a":45},{"p":[1766,787],"f":2,"a":60},{"p":[1688,825],"f":2,"a":75},{"p":[1424,755],"f":1,"a":270},{"p":[1329,843],"f":2,"a":90},{"p":[1298,873],"f":3,"a":0},{"p":[1230,864],"f":2,"a":345},{"p":[1919,863],"f":2,"a":45},{"p":[1925,960],"f":3,"a":0},{"p":[1282,922],"f":2,"a":300},{"p":[1385,862],"f":1,"a":270},{"p":[1657,861],"f":1,"a":270},{"p":[2146,995],"f":2,"a":0},{"p":[2104,1068],"f":2,"a":30},{"p":[2045,1135],"f":2,"a":60},{"p":[1797,1088],"f":1,"a":270},{"p":[1525,1089],"f":1,"a":270},{"p":[1253,1090],"f":1,"a":270},{"p":[1146,1147],"f":2,"a":120},{"p":[1068,1094],"f":2,"a":135},{"p":[1013,1022],"f":2,"a":150},{"p":[1008,952],"f":2,"a":180},{"p":[1041,922],"f":3,"a":0},{"p":[1037,888],"f":3,"a":0},{"p":[934,850],"f":2,"a":60},{"p":[893,930],"f":2,"a":15},{"p":[805,1029],"f":1,"a":180},{"p":[897,1300],"f":2,"a":0},{"p":[961,1242],"f":1,"a":90},{"p":[1209,1286],"f":2,"a":225},{"p":[1281,1237],"f":2,"a":240},{"p":[1383,1141],"f":1,"a":90},{"p":[1656,1230],"f":2,"a":270},{"p":[1738,1232],"f":2,"a":285},{"p":[1809,1269],"f":2,"a":315},{"p":[1909,1334],"f":2,"a":270},{"p":[1993,1332],"f":2,"a":285},{"p":[2071,1358],"f":2,"a":300},{"p":[2141,1412],"f":2,"a":315},{"p":[2195,1496],"f":2,"a":345},{"p":[2128,1593],"f":1,"a":180},{"p":[2176,1846],"f":2,"a":30},{"p":[2118,1912],"f":2,"a":60},{"p":[2049,1965],"f":2,"a":75},{"p":[1787,1904],"f":1,"a":90},{"p":[1693,1996],"f":2,"a":90},{"p":[1600,1995],"f":2,"a":90},{"p":[1564,2007],"f":3,"a":0},{"p":[1480,1953],"f":2,"a":90},{"p":[1389,1952],"f":2,"a":90},{"p":[1358,1980],"f":3,"a":0},{"p":[1258,1960],"f":2,"a":45},{"p":[1016,1905],"f":1,"a":90},{"p":[1842,1571],"f":2,"a":45},{"p":[1922,1565],"f":2,"a":300},{"p":[1981,1656],"f":2,"a":0},{"p":[1928,1718],"f":2,"a":45},{"p":[1684,1675],"f":1,"a":90},{"p":[1411,1675],"f":1,"a":90},{"p":[1140,1673],"f":1,"a":90},{"p":[1049,1765],"f":2,"a":90},{"p":[941,1731],"f":2,"a":120},{"p":[892,1672],"f":2,"a":165},{"p":[897,1593],"f":2,"a":180},{"p":[962,1471],"f":1,"a":90},{"p":[1205,1572],"f":2,"a":135},{"p":[1284,1629],"f":2,"a":120},{"p":[1385,1580],"f":1,"a":90},{"p":[1657,1672],"f":2,"a":90},{"p":[1741,1648],"f":2,"a":75},{"p":[1838,1663],"f":3,"a":0},{"p":[1430,1360],"f":1,"a":90},{"p":[1701,1480],"f":3,"a":0},{"p":[923,1997],"f":2,"a":90},{"p":[824,1973],"f":2,"a":105},{"p":[741,1920],"f":2,"a":135},{"p":[679,1852],"f":2,"a":150},{"p":[577,1605],"f":1,"a":0},{"p":[424,1476],"f":1,"a":270},{"p":[330,1566],"f":2,"a":90},{"p":[224,1546],"f":2,"a":105},{"p":[135,1501],"f":2,"a":135},{"p":[92,1434],"f":2,"a":165},{"p":[1,1172],"f":1,"a":0},{"p":[3,900],"f":1,"a":0},{"p":[2,628],"f":1,"a":0},{"p":[0,356],"f":1,"a":0},{"p":[90,255],"f":2,"a":195},{"p":[125,172],"f":2,"a":225},{"p":[194,114],"f":2,"a":240},{"p":[271,87],"f":2,"a":255}],"decals":[{"p":[156,150],"f":4,"a":0},{"p":[468,102],"f":5,"a":0},{"p":[756,102],"f":5,"a":0},{"p":[1044,150],"f":6,"a":90},{"p":[1020,366],"f":5,"a":90},{"p":[1044,654],"f":7,"a":0},{"p":[1068,894],"f":4,"a":270},{"p":[1380,966],"f":5,"a":180},{"p":[1668,966],"f":5,"a":180},{"p":[1956,990],"f":6,"a":180},{"p":[1980,798],"f":8,"a":0},{"p":[1980,606],"f":9,"a":0},{"p":[1980,414],"f":10,"a":0},{"p":[1956,198],"f":6,"a":90},{"p":[1740,198],"f":6,"a":0},{"p":[1284,630],"f":5,"a":0},{"p":[1620,558],"f":4,"a":180},{"p":[1740,414],"f":11,"a":0},{"p":[1740,366],"f":11,"a":0},{"p":[1476,678],"f":11,"a":90},{"p":[732,678],"f":4,"a":0},{"p":[684,990],"f":5,"a":90},{"p":[1044,1398],"f":10,"a":270},{"p":[1134,1290],"f":12,"a":270},{"p":[1440,1242],"f":5,"a":180},{"p":[1440,1458],"f":5,"a":180},{"p":[1626,1290],"f":12,"a":90},{"p":[1932,1398],"f":4,"a":90},{"p":[1932,1710],"f":4,"a":180},{"p":[1644,1782],"f":5,"a":180},{"p":[1452,1830],"f":13,"a":270},{"p":[1260,1830],"f":14,"a":270},{"p":[708,1374],"f":15,"a":0},{"p":[900,1398],"f":11,"a":270},{"p":[732,1230],"f":11,"a":0},{"p":[732,1710],"f":4,"a":270},{"p":[996,1830],"f":11,"a":90},{"p":[1086,1830],"f":11,"a":90},{"p":[1116,1830],"f":11,"a":90},{"p":[732,1566],"f":11,"a":180},{"p":[156,462],"f":10,"a":180},{"p":[156,654],"f":10,"a":180},{"p":[156,846],"f":10,"a":180},{"p":[156,1038],"f":10,"a":180},{"p":[516,1398],"f":10,"a":270},{"p":[156,1188],"f":10,"a":0},{"p":[156,1374],"f":6,"a":270},{"p":[324,1398],"f":11,"a":270},{"p":[372,1398],"f":11,"a":270},{"p":[1104,606],"f":16,"a":90},{"p":[1182,606],"f":16,"a":90},{"p":[1314,714],"f":16,"a":180},{"p":[1314,792],"f":16,"a":180},{"p":[162,600],"f":17,"a":0},{"p":[240,600],"f":17,"a":0},{"p":[174,672],"f":18,"a":0},{"p":[276,762],"f":18,"a":0},{"p":[174,864],"f":18,"a":0},{"p":[276,960],"f":18,"a":0},{"p":[174,1092],"f":18,"a":0},{"p":[276,1206],"f":18,"a":0}],"ai_waypoints":[{"p":[235,467],"n":1},{"p":[390,295],"n":2},{"p":[1045,289],"n":4},{"p":[1208,966],"n":5},{"p":[1776,1157],"n":6},{"p":[2056,648],"n":8},{"p":[663,184],"n":3},{"p":[2092,454],"n":9},{"p":[1966,318],"n":10},{"p":[961,795],"n":12},{"p":[777,1094],"n":13},{"p":[2063,1594],"n":16},{"p":[2007,1829],"n":17},{"p":[913,1826],"n":19},{"p":[1574,1332],"n":15},{"p":[2035,904],"n":7},{"p":[869,1402],"n":14},{"p":[743,1566],"n":20},{"p":[1261,1930],"n":18},{"p":[321,1401],"n":21},{"p":[1673,727],"n":11}],"checkpoints":[{"p":[108,376],"n":1},{"p":[1008,119],"n":2},{"p":[1033,870],"n":3},{"p":[1945,883],"n":4},{"p":[1813,176],"n":5},{"p":[749,650],"n":6},{"p":[742,1329],"n":7},{"p":[1838,1370],"n":8},{"p":[1688,1780],"n":9},{"p":[706,1742],"n":10},{"p":[136,1351],"n":11}],"start_positions":[{"p":[172,707],"n":1,"a":0},{"p":[272,796],"n":2,"a":0},{"p":[170,902],"n":3,"a":0},{"p":[268,1001],"n":4,"a":0},{"p":[171,1129],"n":5,"a":0},{"p":[271,1243],"n":6,"a":0}],"dict":{"1":"9tires.png","2":"3tires.png","3":"tire.png","4":"dideliskampas.png","5":"ilgas.png","6":"lenktas.png","7":"kryzius.png","8":"siaurejantis2.png","9":"siaurejantis1.png","10":"paprastas.png","11":"trumpas.png","12":"issisakojimas.png","13":"sonaslenktas2.png","14":"sonaslenktas1.png","15":"susikerta.png","16":"arrow.png","17":"startbar.png","18":"white_bar.png"}},"spiralraceway":{"size":[2500,1800],"title":"Spiral Raceway","bgtile":"grass.png","props":[{"p":[1169,1308],"f":1,"a":345},{"p":[1220,1366],"f":1,"a":300},{"p":[1204,1053],"f":1,"a":270},{"p":[1668,1052],"f":1,"a":270},{"p":[1730,1001],"f":1,"a":225},{"p":[1784,934],"f":1,"a":195},{"p":[1570,756],"f":1,"a":180},{"p":[1536,694],"f":1,"a":90},{"p":[1538,817],"f":1,"a":90},{"p":[1265,601],"f":2,"a":270},{"p":[1268,727],"f":2,"a":270},{"p":[1238,847],"f":3,"a":0},{"p":[1172,788],"f":1,"a":0},{"p":[1200,756],"f":3,"a":0},{"p":[1205,724],"f":3,"a":0},{"p":[1234,720],"f":3,"a":0},{"p":[1683,474],"f":1,"a":300},{"p":[1750,533],"f":1,"a":330},{"p":[1793,634],"f":1,"a":0},{"p":[1812,1397],"f":1,"a":90},{"p":[1901,1394],"f":1,"a":90},{"p":[1964,1348],"f":1,"a":45},{"p":[2017,1281],"f":1,"a":15},{"p":[2037,1200],"f":1,"a":0},{"p":[1783,1332],"f":1,"a":0},{"p":[1830,1274],"f":1,"a":75},{"p":[1906,1229],"f":1,"a":60},{"p":[2005,1239],"f":3,"a":0},{"p":[2034,1212],"f":3,"a":0},{"p":[1906,276],"f":1,"a":300},{"p":[1972,335],"f":1,"a":330},{"p":[2023,422],"f":1,"a":345},{"p":[1992,301],"f":1,"a":315},{"p":[1850,1536],"f":2,"a":270},{"p":[2101,1585],"f":1,"a":240},{"p":[2174,1531],"f":1,"a":225},{"p":[2233,1464],"f":1,"a":195},{"p":[2175,1205],"f":2,"a":180},{"p":[2174,935],"f":2,"a":180},{"p":[2175,665],"f":2,"a":180},{"p":[2040,769],"f":1,"a":180},{"p":[2175,393],"f":2,"a":180},{"p":[2266,299],"f":1,"a":180},{"p":[2241,200],"f":1,"a":165},{"p":[2185,115],"f":1,"a":135},{"p":[2113,65],"f":1,"a":120},{"p":[2046,53],"f":1,"a":90},{"p":[1771,-39],"f":2,"a":90},{"p":[1502,-42],"f":2,"a":90},{"p":[1408,49],"f":1,"a":90},{"p":[1317,48],"f":1,"a":90},{"p":[1284,81],"f":3,"a":0},{"p":[1176,53],"f":1,"a":60},{"p":[973,150],"f":2,"a":90},{"p":[703,150],"f":2,"a":90},{"p":[602,234],"f":1,"a":75},{"p":[924,-6],"f":2,"a":90},{"p":[652,-7],"f":2,"a":90},{"p":[545,49],"f":1,"a":135},{"p":[541,73],"f":3,"a":0},{"p":[450,46],"f":1,"a":90},{"p":[349,48],"f":1,"a":75},{"p":[261,76],"f":1,"a":60},{"p":[193,136],"f":1,"a":30},{"p":[165,228],"f":1,"a":15},{"p":[465,276],"f":1,"a":60},{"p":[399,338],"f":1,"a":30},{"p":[73,331],"f":2,"a":0},{"p":[75,604],"f":2,"a":0},{"p":[74,878],"f":2,"a":0},{"p":[169,1129],"f":1,"a":330},{"p":[221,1200],"f":1,"a":315},{"p":[305,1255],"f":1,"a":285},{"p":[403,1196],"f":2,"a":270},{"p":[674,1197],"f":2,"a":270},{"p":[945,1315],"f":3,"a":0},{"p":[977,1316],"f":3,"a":0},{"p":[945,1349],"f":1,"a":180},{"p":[945,1428],"f":1,"a":165},{"p":[980,1505],"f":1,"a":150},{"p":[1043,1569],"f":1,"a":120},{"p":[1135,1611],"f":1,"a":105},{"p":[1237,1540],"f":2,"a":270},{"p":[1581,1536],"f":2,"a":270},{"p":[1506,1658],"f":3,"a":0},{"p":[1541,1657],"f":3,"a":0},{"p":[1232,1287],"f":1,"a":90},{"p":[1262,1341],"f":1,"a":0},{"p":[393,938],"f":1,"a":0},{"p":[404,1003],"f":1,"a":315},{"p":[501,1061],"f":1,"a":270},{"p":[419,952],"f":1,"a":330},{"p":[490,1003],"f":1,"a":300},{"p":[914,1053],"f":1,"a":270},{"p":[697,821],"f":1,"a":270},{"p":[604,760],"f":1,"a":330},{"p":[598,689],"f":1,"a":0},{"p":[598,598],"f":1,"a":0},{"p":[611,497],"f":1,"a":45},{"p":[789,822],"f":1,"a":90},{"p":[881,821],"f":1,"a":90},{"p":[856,610],"f":2,"a":180},{"p":[965,512],"f":1,"a":45},{"p":[1038,479],"f":1,"a":90},{"p":[711,389],"f":2,"a":90},{"p":[980,506],"f":3,"a":0},{"p":[1010,505],"f":3,"a":0}],"decals":[{"p":[228,114],"f":4,"a":0},{"p":[1692,66],"f":5,"a":0},{"p":[1980,114],"f":4,"a":90},{"p":[228,426],"f":6,"a":0},{"p":[228,618],"f":6,"a":0},{"p":[228,810],"f":6,"a":0},{"p":[228,1002],"f":4,"a":270},{"p":[540,1074],"f":5,"a":0},{"p":[828,1074],"f":5,"a":0},{"p":[1116,1074],"f":5,"a":0},{"p":[1404,1074],"f":5,"a":0},{"p":[2052,426],"f":5,"a":90},{"p":[2052,714],"f":5,"a":90},{"p":[1758,1002],"f":4,"a":180},{"p":[1614,1122],"f":7,"a":90},{"p":[1878,816],"f":6,"a":0},{"p":[1878,624],"f":6,"a":0},{"p":[1758,312],"f":4,"a":90},{"p":[1470,264],"f":5,"a":180},{"p":[1182,264],"f":5,"a":180},{"p":[894,264],"f":5,"a":180},{"p":[432,312],"f":4,"a":0},{"p":[744,264],"f":5,"a":180},{"p":[432,576],"f":7,"a":180},{"p":[432,672],"f":7,"a":180},{"p":[1608,528],"f":8,"a":90},{"p":[1632,696],"f":7,"a":180},{"p":[1632,750],"f":7,"a":180},{"p":[1320,480],"f":5,"a":0},{"p":[984,1098],"f":9,"a":0},{"p":[984,858],"f":9,"a":0},{"p":[792,882],"f":6,"a":270},{"p":[432,762],"f":4,"a":270},{"p":[690,882],"f":7,"a":270},{"p":[1008,528],"f":8,"a":0},{"p":[1176,528],"f":7,"a":90},{"p":[1008,696],"f":7,"a":180},{"p":[1008,720],"f":7,"a":180},{"p":[1224,882],"f":6,"a":270},{"p":[1608,858],"f":8,"a":180},{"p":[1320,834],"f":5,"a":0},{"p":[1008,1338],"f":4,"a":270},{"p":[1320,1410],"f":5,"a":0},{"p":[1608,1410],"f":5,"a":0},{"p":[2052,1002],"f":5,"a":90},{"p":[1980,1338],"f":4,"a":180},{"p":[1836,1458],"f":7,"a":270},{"p":[2100,1206],"f":7,"a":0},{"p":[540,114],"f":10,"a":180},{"p":[732,114],"f":11,"a":0},{"p":[924,114],"f":11,"a":0},{"p":[1116,114],"f":10,"a":0},{"p":[1308,66],"f":5,"a":180},{"p":[1548,114],"f":7,"a":90},{"p":[1812,1464],"f":12,"a":90},{"p":[1812,1542],"f":12,"a":90},{"p":[1794,1476],"f":13,"a":90},{"p":[1704,1584],"f":13,"a":90},{"p":[1620,1476],"f":13,"a":90},{"p":[1518,1584],"f":13,"a":90},{"p":[1428,1476],"f":13,"a":90},{"p":[1326,1584],"f":13,"a":90},{"p":[1050,822],"f":14,"a":90},{"p":[1122,822],"f":14,"a":90},{"p":[948,924],"f":14,"a":0},{"p":[948,996],"f":14,"a":0},{"p":[1050,1080],"f":14,"a":90},{"p":[1122,1080],"f":14,"a":90},{"p":[948,1158],"f":14,"a":0},{"p":[948,1242],"f":14,"a":0}],"ai_waypoints":[{"p":[1966,1498],"n":1},{"p":[2135,1365],"n":2},{"p":[2220,531],"n":3},{"p":[2067,264],"n":4},{"p":[1265,196],"n":5},{"p":[553,187],"n":6},{"p":[348,341],"n":7},{"p":[278,662],"n":8},{"p":[379,1108],"n":9},{"p":[1083,1199],"n":10},{"p":[1560,1240],"n":11},{"p":[1877,1117],"n":12},{"p":[1995,696],"n":13},{"p":[1873,488],"n":14},{"p":[1488,345],"n":15},{"p":[582,469],"n":16},{"p":[479,648],"n":17},{"p":[671,933],"n":18},{"p":[1098,955],"n":19},{"p":[1645,910],"n":20},{"p":[1701,781],"n":21},{"p":[1609,650],"n":22},{"p":[1359,571],"n":23},{"p":[1125,693],"n":24},{"p":[1079,1089],"n":25},{"p":[1146,1464],"n":26},{"p":[1524,1535],"n":27}],"checkpoints":[{"p":[1856,1415],"n":1},{"p":[1973,97],"n":2},{"p":[369,76],"n":3},{"p":[259,1068],"n":4},{"p":[1761,1018],"n":5},{"p":[1751,338],"n":6},{"p":[455,319],"n":7},{"p":[448,808],"n":8},{"p":[1563,818],"n":9},{"p":[1552,501],"n":10},{"p":[978,506],"n":11},{"p":[965,1319],"n":12}],"start_positions":[{"p":[1747,1470],"n":1,"a":90},{"p":[1656,1579],"n":2,"a":90},{"p":[1575,1472],"n":3,"a":90},{"p":[1473,1578],"n":4,"a":90},{"p":[1382,1468],"n":5,"a":90},{"p":[1278,1579],"n":6,"a":90}],"dict":{"1":"3tires.png","2":"9tires.png","3":"tire.png","4":"dideliskampas.png","5":"ilgas.png","6":"paprastas.png","7":"trumpas.png","8":"lenktas.png","9":"kryzius.png","10":"siaurasiplatu.png","11":"siauras.png","12":"startbar.png","13":"white_bar.png","14":"arrow.png"}},"greenring":{"size":[2700,2100],"title":"Grennglade Ring","bgtile":"grass.png","props":[{"p":[998,187],"f":1,"a":270},{"p":[1268,187],"f":1,"a":270},{"p":[1540,187],"f":1,"a":270},{"p":[1810,188],"f":1,"a":270},{"p":[2081,277],"f":2,"a":270},{"p":[2173,277],"f":2,"a":270},{"p":[2252,281],"f":2,"a":285},{"p":[2327,310],"f":2,"a":300},{"p":[2388,374],"f":2,"a":330},{"p":[2428,463],"f":2,"a":345},{"p":[2357,563],"f":1,"a":0},{"p":[2448,834],"f":2,"a":0},{"p":[2425,912],"f":2,"a":15},{"p":[2374,981],"f":2,"a":45},{"p":[2307,1042],"f":2,"a":60},{"p":[2228,1084],"f":2,"a":75},{"p":[2150,1101],"f":2,"a":90},{"p":[2046,1101],"f":2,"a":60},{"p":[2049,1189],"f":3,"a":0},{"p":[1927,1219],"f":1,"a":0},{"p":[2018,1490],"f":2,"a":0},{"p":[1975,1559],"f":2,"a":30},{"p":[1919,1629],"f":2,"a":45},{"p":[1853,1687],"f":2,"a":75},{"p":[1778,1718],"f":2,"a":90},{"p":[1507,1630],"f":1,"a":270},{"p":[1235,1629],"f":1,"a":270},{"p":[965,1631],"f":1,"a":270},{"p":[692,1629],"f":1,"a":270},{"p":[589,1670],"f":2,"a":120},{"p":[522,1608],"f":2,"a":150},{"p":[489,1531],"f":2,"a":165},{"p":[398,1271],"f":1,"a":180},{"p":[500,1170],"f":2,"a":30},{"p":[561,1102],"f":2,"a":60},{"p":[645,1066],"f":2,"a":75},{"p":[743,1061],"f":2,"a":90},{"p":[834,1090],"f":3,"a":0},{"p":[852,1062],"f":3,"a":0},{"p":[768,964],"f":2,"a":135},{"p":[525,860],"f":1,"a":90},{"p":[434,955],"f":2,"a":90},{"p":[345,954],"f":2,"a":90},{"p":[245,915],"f":2,"a":120},{"p":[165,864],"f":2,"a":135},{"p":[111,793],"f":2,"a":150},{"p":[13,542],"f":1,"a":0},{"p":[101,451],"f":2,"a":180},{"p":[100,360],"f":2,"a":180},{"p":[99,271],"f":2,"a":180},{"p":[104,169],"f":2,"a":210},{"p":[154,95],"f":2,"a":225},{"p":[230,47],"f":2,"a":240},{"p":[334,-54],"f":1,"a":270},{"p":[605,34],"f":2,"a":270},{"p":[694,35],"f":2,"a":270},{"p":[783,35],"f":2,"a":270},{"p":[853,46],"f":2,"a":300},{"p":[915,109],"f":2,"a":330},{"p":[957,213],"f":2,"a":0},{"p":[511,180],"f":1,"a":270},{"p":[726,331],"f":2,"a":0},{"p":[737,401],"f":2,"a":330},{"p":[801,465],"f":2,"a":300},{"p":[903,417],"f":1,"a":270},{"p":[1173,418],"f":1,"a":270},{"p":[1443,416],"f":1,"a":270},{"p":[1713,415],"f":1,"a":270},{"p":[1985,504],"f":2,"a":270},{"p":[2075,504],"f":2,"a":270},{"p":[2144,505],"f":2,"a":300},{"p":[2120,593],"f":1,"a":180},{"p":[2152,832],"f":2,"a":240},{"p":[2080,867],"f":2,"a":270},{"p":[1979,865],"f":2,"a":255},{"p":[1889,890],"f":2,"a":240},{"p":[1822,950],"f":2,"a":210},{"p":[1787,1038],"f":2,"a":195},{"p":[1692,1138],"f":1,"a":180},{"p":[1763,1398],"f":2,"a":195},{"p":[1702,1457],"f":2,"a":240},{"p":[1452,1401],"f":1,"a":90},{"p":[1182,1402],"f":1,"a":90},{"p":[910,1402],"f":1,"a":90},{"p":[809,1477],"f":2,"a":285},{"p":[719,1427],"f":2,"a":315},{"p":[716,1352],"f":2,"a":15},{"p":[778,1292],"f":2,"a":75},{"p":[878,1290],"f":2,"a":90},{"p":[945,1244],"f":2,"a":60},{"p":[1012,1186],"f":2,"a":30},{"p":[967,935],"f":1,"a":0},{"p":[1008,836],"f":2,"a":330},{"p":[951,761],"f":2,"a":315},{"p":[879,724],"f":2,"a":285},{"p":[617,634],"f":1,"a":270},{"p":[408,264],"f":2,"a":255},{"p":[342,322],"f":2,"a":195},{"p":[248,422],"f":1,"a":180},{"p":[346,669],"f":2,"a":135},{"p":[443,718],"f":2,"a":90},{"p":[530,724],"f":2,"a":90}],"decals":[{"p":[168,102],"f":4,"a":0},{"p":[480,54],"f":5,"a":0},{"p":[768,102],"f":6,"a":90},{"p":[792,318],"f":6,"a":270},{"p":[480,738],"f":5,"a":0},{"p":[168,666],"f":4,"a":270},{"p":[168,474],"f":7,"a":0},{"p":[168,366],"f":8,"a":0},{"p":[1008,294],"f":5,"a":180},{"p":[1296,294],"f":5,"a":180},{"p":[1584,294],"f":5,"a":180},{"p":[1872,294],"f":5,"a":180},{"p":[768,786],"f":4,"a":90},{"p":[864,1098],"f":6,"a":180},{"p":[552,1122],"f":4,"a":0},{"p":[552,1434],"f":4,"a":270},{"p":[864,1506],"f":5,"a":180},{"p":[1152,1506],"f":5,"a":180},{"p":[1440,1506],"f":5,"a":180},{"p":[1728,1434],"f":4,"a":180},{"p":[1848,1242],"f":7,"a":0},{"p":[1848,930],"f":4,"a":0},{"p":[2160,342],"f":4,"a":90},{"p":[2160,810],"f":4,"a":180},{"p":[2280,666],"f":8,"a":0},{"p":[2280,606],"f":8,"a":0},{"p":[1806,360],"f":9,"a":90},{"p":[1746,462],"f":9,"a":90},{"p":[1674,360],"f":9,"a":90},{"p":[1596,462],"f":9,"a":90},{"p":[1512,360],"f":9,"a":90},{"p":[1422,462],"f":9,"a":90},{"p":[1848,348],"f":10,"a":90},{"p":[1848,426],"f":10,"a":90}],"ai_waypoints":[{"p":[2175,455],"n":1},{"p":[2315,618],"n":2},{"p":[2286,910],"n":3},{"p":[1985,1128],"n":4},{"p":[1862,1523],"n":5},{"p":[1605,1666],"n":6},{"p":[762,1595],"n":7},{"p":[645,1442],"n":8},{"p":[737,1272],"n":9},{"p":[918,1088],"n":10},{"p":[813,932],"n":11},{"p":[337,779],"n":12},{"p":[250,505],"n":13},{"p":[335,248],"n":14},{"p":[567,217],"n":15},{"p":[804,262],"n":16},{"p":[1044,400],"n":17},{"p":[1584,411],"n":18}],"checkpoints":[{"p":[1891,294],"n":1},{"p":[2202,831],"n":2},{"p":[1773,1459],"n":3},{"p":[548,1473],"n":4},{"p":[604,1107],"n":5},{"p":[701,743],"n":6},{"p":[163,700],"n":7},{"p":[219,75],"n":8},{"p":[710,95],"n":9}],"start_positions":[{"p":[1758,354],"n":1,"a":90},{"p":[1698,456],"n":2,"a":90},{"p":[1626,354],"n":3,"a":90},{"p":[1548,456],"n":4,"a":90},{"p":[1464,354],"n":5,"a":90},{"p":[1374,456],"n":6,"a":90}],"dict":{"1":"9tires.png","2":"3tires.png","3":"tire.png","4":"dideliskampas.png","5":"ilgas.png","6":"lenktas.png","7":"paprastas.png","8":"trumpas.png","9":"white_bar.png","10":"startbar.png"}},"frogfoot":{"size":[2500,2500],"title":"Frogfoot Circuit","bgtile":"sand.png","props":[{"p":[63,1250],"f":1,"a":0},{"p":[59,980],"f":1,"a":0},{"p":[147,888],"f":2,"a":0},{"p":[152,789],"f":2,"a":15},{"p":[189,705],"f":2,"a":45},{"p":[260,649],"f":2,"a":60},{"p":[349,624],"f":2,"a":75},{"p":[450,539],"f":1,"a":270},{"p":[720,629],"f":2,"a":90},{"p":[658,388],"f":1,"a":180},{"p":[745,284],"f":2,"a":210},{"p":[794,207],"f":2,"a":225},{"p":[878,173],"f":2,"a":255},{"p":[978,174],"f":2,"a":270},{"p":[1059,171],"f":2,"a":285},{"p":[1134,198],"f":2,"a":300},{"p":[1195,272],"f":2,"a":345},{"p":[1133,371],"f":1,"a":180},{"p":[1252,641],"f":3,"a":0},{"p":[1250,550],"f":1,"a":90},{"p":[1521,633],"f":2,"a":270},{"p":[1600,628],"f":2,"a":285},{"p":[1680,653],"f":2,"a":300},{"p":[1748,713],"f":2,"a":330},{"p":[1799,800],"f":2,"a":345},{"p":[1819,900],"f":2,"a":0},{"p":[1876,859],"f":1,"a":90},{"p":[2135,945],"f":2,"a":285},{"p":[2207,981],"f":2,"a":315},{"p":[2257,1069],"f":2,"a":345},{"p":[2278,1166],"f":2,"a":0},{"p":[2265,1247],"f":2,"a":15},{"p":[2221,1321],"f":2,"a":45},{"p":[2155,1380],"f":2,"a":60},{"p":[1903,1323],"f":1,"a":90},{"p":[1871,1441],"f":3,"a":0},{"p":[1820,1465],"f":2,"a":0},{"p":[1796,1545],"f":2,"a":15},{"p":[1744,1613],"f":2,"a":45},{"p":[1676,1677],"f":2,"a":60},{"p":[1597,1711],"f":2,"a":75},{"p":[1337,1639],"f":1,"a":90},{"p":[1249,1726],"f":2,"a":90},{"p":[1130,1787],"f":1,"a":0},{"p":[1200,2045],"f":2,"a":15},{"p":[1145,2114],"f":2,"a":45},{"p":[1075,2161],"f":2,"a":75},{"p":[997,2181],"f":2,"a":90},{"p":[896,2166],"f":2,"a":105},{"p":[804,2129],"f":2,"a":120},{"p":[749,2063],"f":2,"a":150},{"p":[660,1812],"f":1,"a":0},{"p":[782,1780],"f":3,"a":0},{"p":[770,1754],"f":3,"a":0},{"p":[498,1635],"f":1,"a":270},{"p":[407,1723],"f":2,"a":90},{"p":[307,1698],"f":2,"a":105},{"p":[220,1649],"f":2,"a":135},{"p":[166,1580],"f":2,"a":150},{"p":[151,1514],"f":2,"a":180},{"p":[1015,1984],"f":3,"a":0},{"p":[1015,1780],"f":3,"a":0},{"p":[1016,640],"f":3,"a":0},{"p":[1018,432],"f":3,"a":0},{"p":[2079,1211],"f":3,"a":0},{"p":[1881,1210],"f":3,"a":0},{"p":[290,1192],"f":1,"a":180},{"p":[389,1434],"f":2,"a":135},{"p":[483,1402],"f":1,"a":90},{"p":[752,1402],"f":1,"a":90},{"p":[1023,1402],"f":1,"a":90},{"p":[1293,1402],"f":1,"a":90},{"p":[1535,1444],"f":2,"a":45},{"p":[1496,1199],"f":1,"a":0},{"p":[1588,1106],"f":2,"a":0},{"p":[1590,1013],"f":2,"a":0},{"p":[1561,908],"f":2,"a":330},{"p":[1501,861],"f":2,"a":285},{"p":[1239,773],"f":1,"a":270},{"p":[969,772],"f":1,"a":270},{"p":[701,770],"f":1,"a":270},{"p":[610,857],"f":2,"a":270},{"p":[520,855],"f":2,"a":270},{"p":[418,859],"f":2,"a":240},{"p":[376,937],"f":2,"a":195},{"p":[377,1035],"f":2,"a":180},{"p":[408,1160],"f":3,"a":0},{"p":[407,1125],"f":3,"a":0}],"decals":[{"p":[216,696],"f":4,"a":0},{"p":[528,648],"f":5,"a":0},{"p":[816,552],"f":6,"a":0},{"p":[1248,648],"f":5,"a":0},{"p":[1536,696],"f":4,"a":90},{"p":[1560,1008],"f":6,"a":90},{"p":[1536,1440],"f":4,"a":180},{"p":[1248,1512],"f":5,"a":0},{"p":[816,1464],"f":6,"a":180},{"p":[528,1512],"f":5,"a":0},{"p":[216,1440],"f":4,"a":270},{"p":[168,1008],"f":5,"a":90},{"p":[216,1296],"f":7,"a":0},{"p":[216,1248],"f":7,"a":0},{"p":[816,456],"f":8,"a":0},{"p":[1056,456],"f":8,"a":0},{"p":[816,240],"f":9,"a":0},{"p":[1032,240],"f":9,"a":90},{"p":[1896,1008],"f":8,"a":90},{"p":[1896,1248],"f":8,"a":90},{"p":[2088,1224],"f":9,"a":180},{"p":[2088,1008],"f":9,"a":90},{"p":[1056,1800],"f":8,"a":180},{"p":[816,1800],"f":8,"a":180},{"p":[816,1992],"f":9,"a":270},{"p":[1032,1992],"f":9,"a":180},{"p":[342,1068],"f":10,"a":0},{"p":[234,1140],"f":10,"a":0},{"p":[342,1212],"f":10,"a":0},{"p":[234,1296],"f":10,"a":0},{"p":[336,1374],"f":10,"a":0},{"p":[228,1452],"f":10,"a":0},{"p":[222,1002],"f":11,"a":0},{"p":[300,1002],"f":11,"a":0},{"p":[954,738],"f":12,"a":180},{"p":[954,810],"f":12,"a":180},{"p":[1092,546],"f":13,"a":270},{"p":[1164,546],"f":13,"a":270},{"p":[876,630],"f":14,"a":270},{"p":[930,630],"f":14,"a":270},{"p":[1698,1086],"f":12,"a":270},{"p":[1776,1086],"f":12,"a":270},{"p":[1938,1290],"f":13,"a":0},{"p":[1944,1356],"f":13,"a":0},{"p":[1884,1056],"f":14,"a":0},{"p":[1884,1128],"f":14,"a":0},{"p":[852,1866],"f":13,"a":90},{"p":[930,1860],"f":13,"a":90},{"p":[1104,1788],"f":14,"a":90},{"p":[1176,1788],"f":14,"a":90},{"p":[1092,1596],"f":12,"a":0},{"p":[1092,1668],"f":12,"a":0}],"ai_waypoints":[{"p":[333,907],"n":1},{"p":[467,792],"n":2},{"p":[1073,712],"n":3},{"p":[1124,479],"n":4},{"p":[1007,356],"n":5},{"p":[871,576],"n":6},{"p":[1094,800],"n":7},{"p":[1582,820],"n":8},{"p":[1834,1278],"n":9},{"p":[2156,1266],"n":10},{"p":[2119,1132],"n":11},{"p":[1794,1150],"n":12},{"p":[1678,1508],"n":13},{"p":[1453,1619],"n":14},{"p":[954,1713],"n":15},{"p":[953,2055],"n":16},{"p":[1079,2056],"n":17},{"p":[1162,1867],"n":18},{"p":[959,1654],"n":19},{"p":[446,1605],"n":20},{"p":[325,1491],"n":21},{"p":[295,1199],"n":22}],"checkpoints":[{"p":[158,778],"n":1},{"p":[984,630],"n":2},{"p":[992,205],"n":3},{"p":[777,218],"n":4},{"p":[801,633],"n":5},{"p":[1556,732],"n":6},{"p":[1638,1188],"n":7},{"p":[2055,1203],"n":8},{"p":[2029,972],"n":9},{"p":[1633,998],"n":10},{"p":[1435,1522],"n":11},{"p":[779,1546],"n":12},{"p":[792,1954],"n":13},{"p":[1003,1958],"n":14},{"p":[982,1522],"n":15},{"p":[197,1467],"n":16}],"start_positions":[{"p":[336,1104],"n":1,"a":0},{"p":[228,1176],"n":2,"a":0},{"p":[336,1248],"n":3,"a":0},{"p":[228,1332],"n":4,"a":0},{"p":[330,1416],"n":5,"a":0},{"p":[222,1488],"n":6,"a":0}],"dict":{"1":"9tires.png","2":"3tires.png","3":"tire.png","4":"dideliskampas.png","5":"ilgas.png","6":"uglyduckling.png","7":"trumpas.png","8":"paprastas.png","9":"lenktas.png","10":"white_bar.png","11":"startbar.png","12":"arrow4.png","13":"arrow.png","14":"arrow5.png"}},"2_icemanloops":{"size":[3400,2500],"title":"Iceman Loops","bgtile":"snow.png","props":[{"p":[785,184],"f":1,"a":270},{"p":[683,278],"f":2,"a":240},{"p":[606,326],"f":2,"a":225},{"p":[553,399],"f":2,"a":210},{"p":[455,500],"f":1,"a":180},{"p":[687,611],"f":1,"a":180},{"p":[792,513],"f":2,"a":225},{"p":[1056,183],"f":1,"a":90},{"p":[1327,274],"f":2,"a":270},{"p":[1418,272],"f":2,"a":270},{"p":[1498,274],"f":2,"a":285},{"p":[1569,307],"f":2,"a":315},{"p":[1628,379],"f":2,"a":330},{"p":[1669,470],"f":2,"a":345},{"p":[1685,570],"f":2,"a":0},{"p":[1592,659],"f":1,"a":0},{"p":[894,413],"f":1,"a":270},{"p":[793,851],"f":2,"a":315},{"p":[893,808],"f":1,"a":270},{"p":[1164,413],"f":1,"a":270},{"p":[1164,808],"f":1,"a":270},{"p":[1433,927],"f":3,"a":0},{"p":[1463,929],"f":3,"a":0},{"p":[1487,903],"f":3,"a":0},{"p":[1366,633],"f":1,"a":180},{"p":[1407,523],"f":2,"a":315},{"p":[1713,899],"f":2,"a":270},{"p":[1794,954],"f":3,"a":0},{"p":[1822,941],"f":2,"a":270},{"p":[1912,940],"f":2,"a":270},{"p":[1984,903],"f":2,"a":240},{"p":[1991,690],"f":1,"a":180},{"p":[2082,932],"f":3,"a":0},{"p":[2080,599],"f":2,"a":180},{"p":[2077,500],"f":2,"a":195},{"p":[2108,414],"f":2,"a":225},{"p":[2189,373],"f":2,"a":255},{"p":[2289,280],"f":1,"a":90},{"p":[2560,281],"f":1,"a":90},{"p":[2806,380],"f":2,"a":300},{"p":[2871,438],"f":2,"a":330},{"p":[2917,539],"f":2,"a":0},{"p":[2828,630],"f":1,"a":0},{"p":[2340,505],"f":1,"a":270},{"p":[2216,654],"f":1,"a":180},{"p":[2339,810],"f":1,"a":90},{"p":[2600,880],"f":2,"a":255},{"p":[2659,820],"f":2,"a":210},{"p":[2609,594],"f":2,"a":270},{"p":[2670,615],"f":2,"a":345},{"p":[2693,713],"f":2,"a":0},{"p":[2721,807],"f":3,"a":0},{"p":[2920,903],"f":2,"a":0},{"p":[2875,974],"f":2,"a":30},{"p":[2817,1046],"f":2,"a":45},{"p":[2748,1095],"f":2,"a":75},{"p":[2489,1034],"f":1,"a":90},{"p":[2399,1126],"f":2,"a":90},{"p":[2369,1155],"f":3,"a":0},{"p":[2339,1160],"f":3,"a":0},{"p":[2218,1191],"f":1,"a":0},{"p":[2306,1462],"f":2,"a":0},{"p":[2304,1533],"f":2,"a":330},{"p":[2376,1596],"f":2,"a":285},{"p":[2475,1618],"f":2,"a":270},{"p":[2541,1629],"f":2,"a":300},{"p":[2604,1693],"f":2,"a":330},{"p":[2643,1794],"f":2,"a":0},{"p":[2641,1884],"f":2,"a":0},{"p":[2621,1963],"f":2,"a":15},{"p":[2559,2024],"f":2,"a":45},{"p":[2490,2069],"f":2,"a":75},{"p":[2231,1994],"f":1,"a":90},{"p":[1961,1994],"f":1,"a":90},{"p":[1691,1996],"f":1,"a":90},{"p":[1421,1996],"f":1,"a":90},{"p":[1331,2085],"f":2,"a":90},{"p":[1231,2063],"f":2,"a":105},{"p":[1148,2009],"f":2,"a":135},{"p":[1113,1940],"f":2,"a":165},{"p":[1118,1861],"f":2,"a":180},{"p":[1116,1769],"f":2,"a":180},{"p":[1129,1672],"f":2,"a":225},{"p":[1201,1619],"f":2,"a":240},{"p":[1305,1617],"f":2,"a":270},{"p":[1375,1583],"f":2,"a":240},{"p":[1436,1518],"f":2,"a":195},{"p":[1457,1427],"f":2,"a":225},{"p":[1498,1365],"f":2,"a":180},{"p":[1498,1274],"f":2,"a":180},{"p":[1453,1175],"f":2,"a":135},{"p":[1247,1030],"f":1,"a":90},{"p":[1485,1177],"f":3,"a":0},{"p":[975,1033],"f":1,"a":90},{"p":[884,1124],"f":2,"a":90},{"p":[793,1124],"f":2,"a":90},{"p":[693,1098],"f":2,"a":105},{"p":[608,1045],"f":2,"a":135},{"p":[555,975],"f":2,"a":150},{"p":[542,905],"f":2,"a":180},{"p":[542,816],"f":2,"a":180},{"p":[574,780],"f":3,"a":0},{"p":[1379,1883],"f":3,"a":0},{"p":[1590,1640],"f":1,"a":0},{"p":[1741,1763],"f":1,"a":270},{"p":[1525,1880],"f":3,"a":0},{"p":[1630,1847],"f":3,"a":0},{"p":[1683,1546],"f":2,"a":180},{"p":[1648,1437],"f":2,"a":135},{"p":[1642,1372],"f":2,"a":180},{"p":[1641,1278],"f":2,"a":180},{"p":[1646,1177],"f":2,"a":225},{"p":[1715,1169],"f":3,"a":0},{"p":[1724,1096],"f":2,"a":240},{"p":[1831,1088],"f":2,"a":270},{"p":[1927,1084],"f":2,"a":270},{"p":[1996,1092],"f":2,"a":300},{"p":[1989,1159],"f":1,"a":180},{"p":[1988,1432],"f":1,"a":180},{"p":[2077,1702],"f":2,"a":180},{"p":[2077,1792],"f":2,"a":180},{"p":[2012,1853],"f":2,"a":90},{"p":[2104,1882],"f":3,"a":0},{"p":[2439,1878],"f":3,"a":0},{"p":[2284,1882],"f":3,"a":0},{"p":[2171,1843],"f":3,"a":0}],"decals":[{"p":[606,840],"f":4,"a":270},{"p":[918,912],"f":5,"a":180},{"p":[1206,912],"f":5,"a":180},{"p":[1494,936],"f":6,"a":0},{"p":[1734,960],"f":7,"a":180},{"p":[1926,960],"f":7,"a":0},{"p":[2118,936],"f":6,"a":0},{"p":[2346,912],"f":5,"a":180},{"p":[2634,840],"f":4,"a":180},{"p":[2754,648],"f":8,"a":0},{"p":[2730,432],"f":9,"a":90},{"p":[2094,648],"f":5,"a":270},{"p":[2442,384],"f":5,"a":0},{"p":[2142,432],"f":9,"a":0},{"p":[2310,432],"f":10,"a":270},{"p":[2094,1176],"f":5,"a":90},{"p":[1518,1176],"f":7,"a":270},{"p":[1518,1368],"f":7,"a":90},{"p":[2142,1416],"f":10,"a":0},{"p":[1470,648],"f":5,"a":270},{"p":[1398,336],"f":4,"a":90},{"p":[1110,288],"f":5,"a":0},{"p":[606,648],"f":8,"a":180},{"p":[606,336],"f":4,"a":0},{"p":[918,336],"f":8,"a":270},{"p":[1398,1560],"f":4,"a":180},{"p":[1182,1680],"f":9,"a":0},{"p":[1182,1896],"f":9,"a":270},{"p":[1398,1872],"f":5,"a":180},{"p":[1686,1872],"f":5,"a":180},{"p":[1974,1872],"f":5,"a":180},{"p":[2142,1560],"f":4,"a":270},{"p":[2454,1680],"f":9,"a":90},{"p":[2454,1896],"f":9,"a":180},{"p":[2262,1920],"f":8,"a":270},{"p":[864,966],"f":11,"a":90},{"p":[864,1044],"f":11,"a":90},{"p":[912,978],"f":12,"a":270},{"p":[972,1080],"f":12,"a":270},{"p":[1032,978],"f":12,"a":270},{"p":[1092,1080],"f":12,"a":270},{"p":[1146,978],"f":12,"a":270},{"p":[1194,1080],"f":12,"a":270}],"laps":3,"ai_waypoints":[{"p":[789,977],"n":1},{"p":[715,852],"n":2},{"p":[717,569],"n":3},{"p":[840,464],"n":4},{"p":[1428,463],"n":5},{"p":[1547,593],"n":6},{"p":[1588,1038],"n":7},{"p":[1595,1522],"n":8},{"p":[1306,1820],"n":9},{"p":[1408,2030],"n":10},{"p":[2326,2047],"n":11},{"p":[2500,1873],"n":12},{"p":[2373,1705],"n":13},{"p":[2258,1574],"n":14},{"p":[2222,1039],"n":15},{"p":[2207,666],"n":16},{"p":[2319,546],"n":17},{"p":[2760,575],"n":18},{"p":[2830,800],"n":19},{"p":[2687,977],"n":20},{"p":[2179,1048],"n":21},{"p":[1547,1040],"n":22}],"checkpoints":[{"p":[640,904],"n":1},{"p":[601,337],"n":2},{"p":[1408,364],"n":3},{"p":[1471,923],"n":4},{"p":[1462,1468],"n":5},{"p":[1129,1882],"n":6},{"p":[2437,1868],"n":7},{"p":[2096,1429],"n":8},{"p":[2097,925],"n":9},{"p":[2137,421],"n":10},{"p":[2681,427],"n":11},{"p":[2666,879],"n":12},{"p":[1778,901],"n":13}],"start_positions":[{"p":[948,972],"n":1,"a":270},{"p":[1008,1074],"n":2,"a":270},{"p":[1068,972],"n":3,"a":270},{"p":[1128,1074],"n":4,"a":270},{"p":[1188,972],"n":5,"a":270},{"p":[1236,1074],"n":6,"a":270}],"dict":{"1":"9tires.png","2":"3tires.png","3":"tire.png","4":"dideliskampas.png","5":"ilgas.png","6":"kryzius.png","7":"siaurasiplatu.png","8":"paprastas.png","9":"lenktas.png","10":"trumpas.png","11":"startbar.png","12":"white_bar.png"}},"2_vultureplains":{"size":[3100,1900],"title":"Vulture Plains","bgtile":"sand.png","props":[{"p":[1003,334],"f":1,"a":180},{"p":[1077,233],"f":2,"a":345},{"p":[1039,145],"f":2,"a":330},{"p":[983,71],"f":2,"a":315},{"p":[914,32],"f":2,"a":285},{"p":[656,-66],"f":1,"a":90},{"p":[386,-67],"f":1,"a":90},{"p":[284,28],"f":2,"a":240},{"p":[207,79],"f":2,"a":225},{"p":[152,148],"f":2,"a":210},{"p":[144,250],"f":2,"a":180},{"p":[53,341],"f":1,"a":0},{"p":[54,612],"f":1,"a":0},{"p":[52,881],"f":1,"a":0},{"p":[141,1149],"f":2,"a":180},{"p":[154,1216],"f":2,"a":150},{"p":[223,1273],"f":2,"a":120},{"p":[324,1311],"f":2,"a":90},{"p":[415,1342],"f":3,"a":0},{"p":[446,1342],"f":3,"a":0},{"p":[431,1372],"f":2,"a":0},{"p":[430,1452],"f":2,"a":345},{"p":[462,1526],"f":2,"a":330},{"p":[528,1586],"f":2,"a":300},{"p":[616,1629],"f":2,"a":285},{"p":[715,1557],"f":1,"a":270},{"p":[659,818],"f":2,"a":180},{"p":[719,780],"f":2,"a":90},{"p":[772,1070],"f":2,"a":75},{"p":[832,1007],"f":2,"a":30},{"p":[404,1087],"f":2,"a":90},{"p":[368,1027],"f":2,"a":180},{"p":[434,1025],"f":2,"a":180},{"p":[429,713],"f":2,"a":0},{"p":[443,614],"f":2,"a":45},{"p":[514,557],"f":2,"a":60},{"p":[615,555],"f":2,"a":90},{"p":[397,768],"f":3,"a":0},{"p":[364,676],"f":2,"a":180},{"p":[365,586],"f":2,"a":180},{"p":[372,292],"f":2,"a":30},{"p":[448,249],"f":2,"a":75},{"p":[803,262],"f":2,"a":315},{"p":[857,357],"f":2,"a":0},{"p":[832,555],"f":2,"a":270},{"p":[896,552],"f":3,"a":0},{"p":[1087,811],"f":2,"a":0},{"p":[1147,783],"f":2,"a":270},{"p":[1087,901],"f":2,"a":180},{"p":[656,1329],"f":2,"a":165},{"p":[719,1309],"f":2,"a":90},{"p":[808,1308],"f":2,"a":90},{"p":[712,1394],"f":2,"a":105},{"p":[808,1417],"f":2,"a":90},{"p":[399,394],"f":3,"a":0},{"p":[800,281],"f":3,"a":0},{"p":[895,522],"f":3,"a":0},{"p":[1152,462],"f":1,"a":270},{"p":[1422,461],"f":1,"a":270},{"p":[1694,552],"f":2,"a":90},{"p":[1784,582],"f":3,"a":0},{"p":[1804,552],"f":3,"a":0},{"p":[1772,461],"f":2,"a":0},{"p":[1773,357],"f":2,"a":30},{"p":[1825,283],"f":2,"a":45},{"p":[1898,229],"f":2,"a":60},{"p":[1998,219],"f":2,"a":90},{"p":[2090,130],"f":1,"a":270},{"p":[2360,131],"f":1,"a":270},{"p":[2609,229],"f":2,"a":120},{"p":[2680,281],"f":2,"a":135},{"p":[2737,366],"f":2,"a":165},{"p":[2679,465],"f":1,"a":180},{"p":[2680,737],"f":1,"a":180},{"p":[2768,1009],"f":2,"a":180},{"p":[2756,1091],"f":2,"a":195},{"p":[2716,1171],"f":2,"a":210},{"p":[2655,1239],"f":2,"a":240},{"p":[2580,1287],"f":2,"a":255},{"p":[2502,1309],"f":2,"a":270},{"p":[2416,1309],"f":2,"a":270},{"p":[2325,1307],"f":2,"a":270},{"p":[2293,1337],"f":3,"a":0},{"p":[2269,1363],"f":3,"a":0},{"p":[2239,1393],"f":2,"a":180},{"p":[2161,1541],"f":2,"a":225},{"p":[2093,1601],"f":2,"a":240},{"p":[2218,1472],"f":2,"a":195},{"p":[1842,1554],"f":1,"a":90},{"p":[1570,1556],"f":1,"a":90},{"p":[987,1558],"f":1,"a":90},{"p":[1256,1559],"f":1,"a":90},{"p":[1538,1675],"f":3,"a":0},{"p":[897,1330],"f":1,"a":90},{"p":[1169,1328],"f":1,"a":90},{"p":[1439,1330],"f":1,"a":90},{"p":[1712,1329],"f":1,"a":90},{"p":[1953,1369],"f":2,"a":225},{"p":[2044,1367],"f":3,"a":0},{"p":[2047,1338],"f":3,"a":0},{"p":[2017,1342],"f":3,"a":0},{"p":[1924,1309],"f":2,"a":90},{"p":[1822,1258],"f":2,"a":135},{"p":[1766,1189],"f":2,"a":150},{"p":[1677,939],"f":1,"a":0},{"p":[1770,849],"f":2,"a":180},{"p":[1563,692],"f":1,"a":270},{"p":[1236,691],"f":1,"a":270},{"p":[1506,810],"f":3,"a":0},{"p":[1533,809],"f":3,"a":0},{"p":[886,1288],"f":2,"a":75},{"p":[962,1248],"f":2,"a":60},{"p":[1027,1185],"f":2,"a":30},{"p":[1067,1110],"f":2,"a":15},{"p":[1089,1035],"f":2,"a":0},{"p":[1119,997],"f":3,"a":0},{"p":[2036,1108],"f":3,"a":0},{"p":[2034,817],"f":3,"a":0},{"p":[2035,559],"f":2,"a":270},{"p":[2000,488],"f":2,"a":210},{"p":[2411,446],"f":2,"a":270},{"p":[2476,453],"f":2,"a":315},{"p":[2524,540],"f":2,"a":345},{"p":[2271,1086],"f":2,"a":270},{"p":[2242,1024],"f":2,"a":180},{"p":[2452,1065],"f":2,"a":75},{"p":[2511,1001],"f":2,"a":30}],"decals":[{"p":[204,90],"f":4,"a":0},{"p":[516,42],"f":5,"a":180},{"p":[804,90],"f":4,"a":90},{"p":[924,402],"f":6,"a":0},{"p":[156,402],"f":5,"a":270},{"p":[156,690],"f":5,"a":270},{"p":[756,618],"f":7,"a":90},{"p":[660,618],"f":7,"a":90},{"p":[492,618],"f":8,"a":0},{"p":[444,834],"f":5,"a":270},{"p":[468,1122],"f":9,"a":0},{"p":[924,834],"f":6,"a":0},{"p":[804,1026],"f":4,"a":180},{"p":[660,1146],"f":7,"a":270},{"p":[324,1146],"f":7,"a":270},{"p":[204,930],"f":7,"a":0},{"p":[204,1122],"f":8,"a":270},{"p":[204,978],"f":7,"a":0},{"p":[492,1362],"f":4,"a":270},{"p":[804,1434],"f":5,"a":0},{"p":[1092,1434],"f":5,"a":0},{"p":[1380,1434],"f":5,"a":0},{"p":[1668,1434],"f":5,"a":0},{"p":[1956,1362],"f":4,"a":180},{"p":[1140,618],"f":6,"a":90},{"p":[900,594],"f":10,"a":0},{"p":[1836,1122],"f":8,"a":270},{"p":[2292,1146],"f":6,"a":270},{"p":[2484,1026],"f":4,"a":180},{"p":[1788,834],"f":5,"a":90},{"p":[2052,1122],"f":10,"a":90},{"p":[1716,618],"f":7,"a":90},{"p":[1812,594],"f":9,"a":90},{"p":[2052,618],"f":8,"a":90},{"p":[2028,834],"f":5,"a":90},{"p":[1836,282],"f":4,"a":0},{"p":[2556,738],"f":5,"a":90},{"p":[2148,234],"f":5,"a":180},{"p":[2484,282],"f":4,"a":90},{"p":[2604,594],"f":6,"a":0},{"p":[2346,282],"f":7,"a":90},{"p":[1332,570],"f":5,"a":180},{"p":[1572,618],"f":7,"a":90},{"p":[1620,618],"f":7,"a":90},{"p":[1050,1488],"f":11,"a":90},{"p":[1050,1566],"f":11,"a":90},{"p":[1134,1500],"f":12,"a":270},{"p":[1212,1602],"f":12,"a":270},{"p":[1290,1500],"f":12,"a":270},{"p":[1368,1602],"f":12,"a":270},{"p":[1446,1500],"f":12,"a":270},{"p":[1524,1602],"f":12,"a":270},{"p":[534,1356],"f":13,"a":270},{"p":[606,1356],"f":13,"a":270},{"p":[708,1188],"f":13,"a":180},{"p":[708,1260],"f":13,"a":180},{"p":[1788,654],"f":13,"a":0},{"p":[1788,720],"f":13,"a":0},{"p":[1878,834],"f":13,"a":270},{"p":[1944,834],"f":13,"a":270}],"laps":3,"ai_waypoints":[{"p":[722,1530],"n":1},{"p":[577,1339],"n":2},{"p":[538,1004],"n":3},{"p":[630,743],"n":4},{"p":[778,679],"n":5},{"p":[963,800],"n":6},{"p":[949,1103],"n":7},{"p":[667,1251],"n":8},{"p":[326,1151],"n":9},{"p":[281,698],"n":10},{"p":[327,302],"n":11},{"p":[464,211],"n":12},{"p":[871,223],"n":13},{"p":[961,338],"n":14},{"p":[1096,655],"n":15},{"p":[1757,649],"n":16},{"p":[2084,763],"n":17},{"p":[2179,954],"n":18},{"p":[2063,1163],"n":19},{"p":[1951,1098],"n":20},{"p":[1908,847],"n":21},{"p":[1953,498],"n":22},{"p":[2106,400],"n":23},{"p":[2523,398],"n":24},{"p":[2646,574],"n":25},{"p":[2681,810],"n":26},{"p":[2622,1080],"n":27},{"p":[2489,1181],"n":28},{"p":[2212,1295],"n":29},{"p":[2062,1469],"n":30},{"p":[1632,1558],"n":31}],"checkpoints":[{"p":[825,1441],"n":1},{"p":[449,1336],"n":2},{"p":[455,603],"n":3},{"p":[844,620],"n":4},{"p":[793,1058],"n":5},{"p":[213,1081],"n":6},{"p":[155,542],"n":7},{"p":[202,112],"n":8},{"p":[848,118],"n":9},{"p":[910,571],"n":10},{"p":[1981,582],"n":11},{"p":[2024,1093],"n":12},{"p":[1801,1085],"n":13},{"p":[1810,335],"n":14},{"p":[2538,335],"n":15},{"p":[2521,1032],"n":16},{"p":[2064,1107],"n":17},{"p":[1723,1420],"n":18}],"start_positions":[{"p":[1170,1494],"n":1,"a":270},{"p":[1248,1596],"n":2,"a":270},{"p":[1326,1494],"n":3,"a":270},{"p":[1404,1596],"n":4,"a":270},{"p":[1482,1494],"n":5,"a":270},{"p":[1560,1596],"n":6,"a":270}],"dict":{"1":"9tires.png","2":"3tires.png","3":"tire.png","4":"dideliskampas.png","5":"ilgas.png","6":"paprastas.png","7":"trumpas.png","8":"lenktas.png","9":"kryzius.png","10":"susikerta.png","11":"startbar.png","12":"white_bar.png","13":"arrow.png"}},"2_queersands":{"size":[2500,2500],"title":"Queer Sands","bgtile":"sand.png","props":[{"p":[964,321],"f":1,"a":0},{"p":[1372,322],"f":1,"a":0},{"p":[487,405],"f":2,"a":90},{"p":[579,405],"f":2,"a":270},{"p":[670,405],"f":2,"a":270},{"p":[436,463],"f":2,"a":180},{"p":[435,555],"f":2,"a":180},{"p":[1890,906],"f":2,"a":180},{"p":[1485,940],"f":2,"a":270},{"p":[1614,940],"f":2,"a":270},{"p":[1576,967],"f":1,"a":285},{"p":[1422,1180],"f":2,"a":270},{"p":[832,1965],"f":2,"a":180},{"p":[1421,1660],"f":2,"a":90},{"p":[1150,1570],"f":3,"a":90},{"p":[1718,1802],"f":3,"a":270},{"p":[1223,1810],"f":3,"a":270},{"p":[1357,1961],"f":3,"a":180},{"p":[1723,1571],"f":3,"a":90},{"p":[1718,1134],"f":1,"a":285},{"p":[1706,1102],"f":1,"a":285},{"p":[1688,1067],"f":1,"a":285},{"p":[1677,1032],"f":1,"a":285},{"p":[1677,1000],"f":1,"a":285},{"p":[1318,1182],"f":2,"a":75},{"p":[1236,1225],"f":2,"a":45},{"p":[1219,1329],"f":2,"a":0},{"p":[1997,526],"f":3,"a":180},{"p":[1838,530],"f":3,"a":180},{"p":[2132,498],"f":1,"a":285},{"p":[1126,863],"f":3,"a":180},{"p":[1461,614],"f":3,"a":90},{"p":[580,1986],"f":2,"a":345},{"p":[521,1909],"f":2,"a":300},{"p":[450,1897],"f":2,"a":270},{"p":[595,2079],"f":2,"a":345},{"p":[628,2152],"f":2,"a":315},{"p":[715,2209],"f":2,"a":285},{"p":[828,2231],"f":2,"a":270},{"p":[918,2211],"f":2,"a":255},{"p":[996,2155],"f":2,"a":225},{"p":[1051,2083],"f":2,"a":195},{"p":[1070,1989],"f":2,"a":195},{"p":[1119,1910],"f":2,"a":240},{"p":[1451,2226],"f":2,"a":165},{"p":[1491,2300],"f":2,"a":135},{"p":[1565,2363],"f":2,"a":120},{"p":[1661,2407],"f":2,"a":105},{"p":[1766,2427],"f":2,"a":90},{"p":[1858,2427],"f":2,"a":90},{"p":[1950,2428],"f":2,"a":90},{"p":[2043,2428],"f":2,"a":90},{"p":[2127,2404],"f":2,"a":75},{"p":[2205,2360],"f":2,"a":60},{"p":[1691,1601],"f":2,"a":0},{"p":[1646,1494],"f":2,"a":330},{"p":[1581,1444],"f":2,"a":285},{"p":[1485,1420],"f":2,"a":270},{"p":[1573,1386],"f":2,"a":255},{"p":[1644,1321],"f":2,"a":225},{"p":[1693,1241],"f":2,"a":195},{"p":[1715,1162],"f":2,"a":180},{"p":[1765,1152],"f":2,"a":105},{"p":[1867,1174],"f":2,"a":90},{"p":[1964,1173],"f":2,"a":90},{"p":[2036,1125],"f":2,"a":60},{"p":[2093,1057],"f":2,"a":30},{"p":[2121,981],"f":2,"a":0},{"p":[2090,864],"f":2,"a":330},{"p":[2124,404],"f":2,"a":180},{"p":[2103,300],"f":2,"a":165},{"p":[2054,209],"f":2,"a":135},{"p":[1983,174],"f":2,"a":105},{"p":[1719,84],"f":3,"a":270},{"p":[1645,314],"f":3,"a":270},{"p":[1625,173],"f":2,"a":90},{"p":[1522,154],"f":2,"a":105},{"p":[1445,97],"f":2,"a":120},{"p":[1366,63],"f":2,"a":105},{"p":[1273,67],"f":2,"a":75},{"p":[1543,401],"f":2,"a":75},{"p":[1454,443],"f":2,"a":60},{"p":[1378,492],"f":2,"a":75},{"p":[1290,495],"f":2,"a":105},{"p":[1201,453],"f":2,"a":120},{"p":[1182,104],"f":2,"a":45},{"p":[1198,457],"f":1,"a":0},{"p":[1171,435],"f":1,"a":0},{"p":[1141,456],"f":1,"a":0},{"p":[1190,201],"f":1,"a":0},{"p":[1162,209],"f":1,"a":0},{"p":[1132,183],"f":1,"a":0},{"p":[1042,446],"f":2,"a":60},{"p":[966,493],"f":2,"a":75},{"p":[876,494],"f":2,"a":105},{"p":[786,449],"f":2,"a":120},{"p":[1038,96],"f":2,"a":120},{"p":[956,65],"f":2,"a":105},{"p":[865,71],"f":2,"a":75},{"p":[771,103],"f":2,"a":60},{"p":[700,156],"f":2,"a":75},{"p":[615,179],"f":2,"a":90},{"p":[581,210],"f":1,"a":0},{"p":[761,435],"f":1,"a":0},{"p":[786,453],"f":1,"a":0},{"p":[487,179],"f":2,"a":90},{"p":[395,179],"f":2,"a":90},{"p":[289,184],"f":2,"a":60},{"p":[219,247],"f":2,"a":30},{"p":[211,351],"f":2,"a":0},{"p":[117,446],"f":3,"a":180},{"p":[435,646],"f":2,"a":0},{"p":[307,721],"f":3,"a":180},{"p":[396,994],"f":2,"a":0},{"p":[356,1060],"f":2,"a":45},{"p":[349,1162],"f":2,"a":0},{"p":[351,1254],"f":2,"a":0},{"p":[208,718],"f":2,"a":0},{"p":[208,809],"f":2,"a":0},{"p":[177,883],"f":2,"a":30},{"p":[166,986],"f":2,"a":0},{"p":[169,1059],"f":2,"a":330},{"p":[202,1163],"f":2,"a":0},{"p":[202,1257],"f":2,"a":0},{"p":[157,1325],"f":2,"a":15},{"p":[375,1326],"f":2,"a":345},{"p":[69,1426],"f":3,"a":180},{"p":[398,1428],"f":2,"a":0},{"p":[397,1521],"f":2,"a":0},{"p":[397,1594],"f":2,"a":330},{"p":[475,1651],"f":2,"a":285},{"p":[580,1668],"f":2,"a":270},{"p":[655,1673],"f":2,"a":300},{"p":[730,1725],"f":2,"a":315},{"p":[785,1811],"f":2,"a":345},{"p":[164,1687],"f":2,"a":345},{"p":[196,1765],"f":2,"a":330},{"p":[263,1832],"f":2,"a":300},{"p":[351,1874],"f":2,"a":285},{"p":[832,1876],"f":2,"a":0},{"p":[859,1810],"f":2,"a":15},{"p":[903,1723],"f":2,"a":45},{"p":[991,1684],"f":2,"a":75},{"p":[1093,1706],"f":1,"a":0},{"p":[1120,1692],"f":1,"a":0},{"p":[1273,1599],"f":2,"a":120},{"p":[1219,1528],"f":2,"a":150},{"p":[1217,1457],"f":2,"a":180},{"p":[1246,1419],"f":1,"a":0},{"p":[2264,2286],"f":2,"a":210},{"p":[2304,2204],"f":2,"a":195},{"p":[2320,2121],"f":2,"a":180},{"p":[2321,2025],"f":2,"a":180},{"p":[2319,1932],"f":2,"a":180},{"p":[2292,1833],"f":2,"a":165},{"p":[2236,1742],"f":2,"a":135},{"p":[2166,1687],"f":2,"a":120},{"p":[2087,1660],"f":2,"a":105},{"p":[2001,1662],"f":2,"a":90},{"p":[1983,1889],"f":2,"a":105},{"p":[2049,1934],"f":2,"a":150},{"p":[1688,1953],"f":2,"a":180},{"p":[1691,2044],"f":2,"a":180},{"p":[1690,2117],"f":2,"a":150},{"p":[1765,2177],"f":2,"a":105},{"p":[1867,2195],"f":2,"a":90},{"p":[1958,2195],"f":2,"a":90},{"p":[2084,2040],"f":2,"a":0},{"p":[2056,2112],"f":2,"a":30},{"p":[2048,2218],"f":1,"a":0},{"p":[2057,2188],"f":1,"a":0},{"p":[1244,1100],"f":2,"a":315},{"p":[1344,1184],"f":1,"a":0},{"p":[1232,760],"f":2,"a":225},{"p":[1353,702],"f":2,"a":255},{"p":[1729,701],"f":2,"a":285},{"p":[1805,733],"f":2,"a":315},{"p":[1892,828],"f":1,"a":0},{"p":[1906,856],"f":1,"a":0},{"p":[1960,804],"f":1,"a":0},{"p":[1961,836],"f":1,"a":0},{"p":[1960,867],"f":1,"a":0},{"p":[1931,875],"f":1,"a":0},{"p":[1330,767],"f":1,"a":0},{"p":[2116,855],"f":1,"a":0},{"p":[2116,795],"f":1,"a":0},{"p":[2114,825],"f":1,"a":0},{"p":[1917,435],"f":1,"a":0},{"p":[1925,465],"f":1,"a":0},{"p":[1937,498],"f":1,"a":0}],"decals":[{"p":[486,192],"f":4,"a":0},{"p":[672,132],"f":5,"a":270},{"p":[876,132],"f":5,"a":90},{"p":[1080,132],"f":5,"a":270},{"p":[1284,132],"f":5,"a":90},{"p":[270,240],"f":6,"a":0},{"p":[270,456],"f":7,"a":0},{"p":[270,648],"f":8,"a":180},{"p":[228,840],"f":8,"a":0},{"p":[228,1032],"f":9,"a":180},{"p":[228,1224],"f":10,"a":180},{"p":[228,1416],"f":7,"a":0},{"p":[540,1728],"f":11,"a":90},{"p":[660,2040],"f":6,"a":270},{"p":[876,2040],"f":6,"a":180},{"p":[900,1728],"f":11,"a":0},{"p":[1212,1680],"f":4,"a":180},{"p":[1500,1704],"f":12,"a":0},{"p":[1524,1944],"f":7,"a":0},{"p":[1740,1680],"f":4,"a":180},{"p":[1524,2136],"f":11,"a":270},{"p":[2028,1728],"f":11,"a":90},{"p":[2028,2136],"f":11,"a":180},{"p":[1836,2256],"f":7,"a":270},{"p":[2148,1992],"f":13,"a":0},{"p":[1500,1488],"f":6,"a":90},{"p":[1284,1464],"f":6,"a":270},{"p":[1284,1248],"f":6,"a":0},{"p":[1500,1224],"f":6,"a":180},{"p":[1500,1008],"f":6,"a":90},{"p":[1284,984],"f":6,"a":270},{"p":[1284,768],"f":6,"a":0},{"p":[1500,768],"f":7,"a":270},{"p":[1692,768],"f":6,"a":90},{"p":[1716,984],"f":6,"a":270},{"p":[1932,984],"f":6,"a":180},{"p":[1956,792],"f":14,"a":90},{"p":[1590,192],"f":4,"a":180},{"p":[1956,648],"f":15,"a":90},{"p":[1956,456],"f":14,"a":270},{"p":[1932,240],"f":6,"a":90},{"p":[1788,240],"f":13,"a":270},{"p":[1596,1704],"f":16,"a":90},{"p":[1596,1890],"f":16,"a":90},{"p":[1518,1812],"f":16,"a":180},{"p":[1698,1812],"f":16,"a":180},{"p":[228,1608],"f":11,"a":270},{"p":[702,252],"f":17,"a":270},{"p":[702,312],"f":17,"a":270},{"p":[702,372],"f":17,"a":270},{"p":[606,372],"f":17,"a":270},{"p":[606,312],"f":17,"a":270},{"p":[606,252],"f":17,"a":270},{"p":[696,324],"f":18,"a":90},{"p":[696,246],"f":18,"a":90}],"laps":3,"ai_waypoints":[{"p":[951,256],"n":1},{"p":[1367,387],"n":2},{"p":[1799,272],"n":3},{"p":[2014,436],"n":4},{"p":[2037,927],"n":5},{"p":[1920,1044],"n":6},{"p":[1699,897],"n":7},{"p":[1569,831],"n":8},{"p":[1405,955],"n":9},{"p":[1556,1205],"n":10},{"p":[1383,1468],"n":11},{"p":[1547,1643],"n":12},{"p":[1579,2034],"n":13},{"p":[1722,2288],"n":14},{"p":[2107,2286],"n":15},{"p":[2236,2062],"n":16},{"p":[2070,1860],"n":17},{"p":[1598,1803],"n":18},{"p":[1078,1881],"n":19},{"p":[882,2096],"n":20},{"p":[642,1908],"n":21},{"p":[349,1648],"n":22},{"p":[300,1350],"n":23},{"p":[333,687],"n":24},{"p":[417,376],"n":25}],"checkpoints":[{"p":[741,210],"n":1},{"p":[1886,224],"n":2},{"p":[1935,942],"n":3},{"p":[1458,1180],"n":4},{"p":[1207,1472],"n":5},{"p":[1483,2179],"n":6},{"p":[2095,2195],"n":7},{"p":[2086,1698],"n":8},{"p":[896,1701],"n":9},{"p":[739,2035],"n":10},{"p":[182,1666],"n":11},{"p":[210,176],"n":12}],"start_positions":[{"p":[660,246],"n":1,"a":90},{"p":[660,306],"n":2,"a":90},{"p":[564,306],"n":3,"a":90},{"p":[564,246],"n":4,"a":90},{"p":[660,366],"n":5,"a":90},{"p":[564,366],"n":6,"a":90}],"dict":{"1":"tire.png","2":"3tires.png","3":"9tires.png","4":"ilgas.png","5":"issisakojimas.png","6":"lenktas.png","7":"paprastas.png","8":"sonaslenktas2.png","9":"siaurejantis2.png","10":"siaurejantis1.png","11":"dideliskampas.png","12":"kryzius.png","13":"trumpas.png","14":"siaurasiplatu.png","15":"siauras.png","16":"arrow.png","17":"white_bar.png","18":"startbar.png"}},"1_bloodbathlane":{"size":[2800,1000],"title":"Bloodbath Lane","bgtile":"snow.png","props":[{"p":[739,144],"f":1,"a":270},{"p":[1011,144],"f":1,"a":270},{"p":[1280,144],"f":1,"a":270},{"p":[1550,143],"f":1,"a":270},{"p":[1820,238],"f":2,"a":270},{"p":[1911,235],"f":2,"a":270},{"p":[2001,265],"f":3,"a":0},{"p":[2033,262],"f":3,"a":0},{"p":[2007,171],"f":2,"a":180},{"p":[2023,75],"f":2,"a":225},{"p":[2097,26],"f":2,"a":240},{"p":[2202,20],"f":2,"a":270},{"p":[2292,17],"f":2,"a":270},{"p":[2373,22],"f":2,"a":285},{"p":[2452,52],"f":2,"a":300},{"p":[2512,115],"f":2,"a":330},{"p":[2553,208],"f":2,"a":345},{"p":[2575,307],"f":2,"a":0},{"p":[2575,401],"f":2,"a":0},{"p":[2554,480],"f":2,"a":15},{"p":[2510,558],"f":2,"a":30},{"p":[2444,619],"f":2,"a":60},{"p":[2365,660],"f":2,"a":75},{"p":[2284,683],"f":2,"a":90},{"p":[2195,683],"f":2,"a":90},{"p":[2092,647],"f":2,"a":120},{"p":[2024,587],"f":2,"a":150},{"p":[2009,518],"f":2,"a":180},{"p":[2234,411],"f":2,"a":180},{"p":[2233,318],"f":2,"a":180},{"p":[2252,258],"f":2,"a":120},{"p":[2324,339],"f":2,"a":180},{"p":[2270,400],"f":2,"a":225},{"p":[1798,372],"f":1,"a":270},{"p":[1528,374],"f":1,"a":270},{"p":[1258,376],"f":1,"a":270},{"p":[987,377],"f":1,"a":270},{"p":[895,465],"f":2,"a":90},{"p":[802,464],"f":2,"a":90},{"p":[774,491],"f":3,"a":0},{"p":[694,484],"f":2,"a":15},{"p":[665,564],"f":2,"a":30},{"p":[609,637],"f":2,"a":60},{"p":[538,678],"f":2,"a":90},{"p":[448,680],"f":2,"a":90},{"p":[255,627],"f":2,"a":120},{"p":[186,569],"f":2,"a":150},{"p":[347,662],"f":2,"a":105},{"p":[149,495],"f":2,"a":165},{"p":[51,236],"f":1,"a":180},{"p":[149,133],"f":2,"a":30},{"p":[201,59],"f":2,"a":45},{"p":[288,21],"f":2,"a":75},{"p":[386,-73],"f":1,"a":90},{"p":[624,40],"f":2,"a":315},{"p":[684,124],"f":2,"a":345},{"p":[739,226],"f":3,"a":0},{"p":[364,314],"f":2,"a":15},{"p":[425,252],"f":2,"a":75},{"p":[476,312],"f":2,"a":0},{"p":[475,407],"f":2,"a":0},{"p":[377,386],"f":2,"a":315},{"p":[474,468],"f":3,"a":0}],"decals":[{"p":[204,78],"f":4,"a":0},{"p":[204,390],"f":4,"a":270},{"p":[516,486],"f":5,"a":180},{"p":[516,78],"f":5,"a":90},{"p":[540,294],"f":6,"a":0},{"p":[726,300],"f":6,"a":90},{"p":[918,252],"f":7,"a":180},{"p":[1206,252],"f":7,"a":180},{"p":[1494,252],"f":7,"a":180},{"p":[1782,252],"f":7,"a":180},{"p":[2070,300],"f":6,"a":180},{"p":[2070,84],"f":5,"a":0},{"p":[2070,492],"f":5,"a":270},{"p":[2286,396],"f":4,"a":180},{"p":[2286,84],"f":4,"a":90},{"p":[1932,300],"f":8,"a":90},{"p":[1464,306],"f":9,"a":90},{"p":[1464,384],"f":9,"a":90},{"p":[1452,324],"f":10,"a":90},{"p":[1392,426],"f":10,"a":90},{"p":[1320,324],"f":10,"a":90},{"p":[1242,426],"f":10,"a":90},{"p":[1182,324],"f":10,"a":90},{"p":[1110,426],"f":10,"a":90},{"p":[1620,426],"f":11,"a":0},{"p":[1770,426],"f":11,"a":0},{"p":[1902,426],"f":11,"a":0},{"p":[2034,426],"f":12,"a":0},{"p":[2130,432],"f":12,"a":0},{"p":[2160,552],"f":13,"a":270},{"p":[2136,264],"f":12,"a":90},{"p":[2202,270],"f":12,"a":90},{"p":[1896,324],"f":11,"a":180},{"p":[1764,324],"f":11,"a":180},{"p":[1608,324],"f":11,"a":180},{"p":[936,336],"f":11,"a":180},{"p":[762,336],"f":12,"a":180},{"p":[630,330],"f":12,"a":180},{"p":[612,492],"f":12,"a":270},{"p":[624,414],"f":12,"a":270},{"p":[750,414],"f":11,"a":0},{"p":[918,414],"f":11,"a":0}],"laps":5,"ai_waypoints":[{"p":[1869,352],"n":1},{"p":[2088,438],"n":2},{"p":[2273,561],"n":3},{"p":[2440,442],"n":4},{"p":[2410,269],"n":5},{"p":[2231,218],"n":6},{"p":[2056,340],"n":7},{"p":[1671,328],"n":8},{"p":[1132,382],"n":9},{"p":[685,326],"n":10},{"p":[503,203],"n":11},{"p":[297,317],"n":12},{"p":[350,487],"n":13},{"p":[503,568],"n":14},{"p":[689,425],"n":15},{"p":[1049,374],"n":16}],"checkpoints":[{"p":[1510,254],"n":1},{"p":[2042,448],"n":2},{"p":[2352,251],"n":3},{"p":[2035,67],"n":4},{"p":[1193,248],"n":5},{"p":[471,54],"n":6},{"p":[147,201],"n":7},{"p":[478,451],"n":8}],"start_positions":[{"p":[1404,318],"n":1,"a":90},{"p":[1338,420],"n":2,"a":90},{"p":[1266,318],"n":3,"a":90},{"p":[1188,420],"n":4,"a":90},{"p":[1128,318],"n":5,"a":90},{"p":[1056,420],"n":6,"a":90}],"dict":{"1":"9tires.png","2":"3tires.png","3":"tire.png","4":"dideliskampas.png","5":"lenktas.png","6":"paprastas.png","7":"ilgas.png","8":"trumpas.png","9":"startbar.png","10":"white_bar.png","11":"arrow.png","12":"arrow3.png","13":"arrow4.png"}},"3_bullpen":{"size":[2900,2500],"title":"Bullpen","bgtile":"sand.png","props":[{"p":[363,1552],"f":1,"a":135},{"p":[554,1743],"f":1,"a":135},{"p":[804,1905],"f":1,"a":105},{"p":[1097,1978],"f":1,"a":90},{"p":[1367,1978],"f":1,"a":90},{"p":[1637,1978],"f":1,"a":90},{"p":[1843,1863],"f":1,"a":60},{"p":[2078,1727],"f":1,"a":60},{"p":[2091,376],"f":1,"a":300},{"p":[2101,741],"f":1,"a":225},{"p":[1907,927],"f":1,"a":225},{"p":[1885,1153],"f":1,"a":150},{"p":[2047,1354],"f":1,"a":135},{"p":[2326,1572],"f":2,"a":75},{"p":[2390,1514],"f":2,"a":45},{"p":[2342,1271],"f":1,"a":0},{"p":[2342,1000],"f":1,"a":0},{"p":[2431,911],"f":2,"a":0},{"p":[2370,812],"f":2,"a":315},{"p":[2396,576],"f":2,"a":270},{"p":[2476,579],"f":2,"a":285},{"p":[2545,612],"f":2,"a":315},{"p":[2609,684],"f":2,"a":330},{"p":[2648,776],"f":2,"a":345},{"p":[2575,877],"f":1,"a":0},{"p":[2573,1149],"f":1,"a":0},{"p":[2574,1419],"f":1,"a":0},{"p":[2383,1809],"f":2,"a":270},{"p":[2463,1788],"f":2,"a":255},{"p":[2539,1746],"f":2,"a":240},{"p":[2606,1686],"f":2,"a":210},{"p":[2682,1682],"f":3,"a":0},{"p":[1857,241],"f":1,"a":300},{"p":[1620,105],"f":1,"a":300},{"p":[399,183],"f":1,"a":240},{"p":[635,49],"f":1,"a":240},{"p":[938,31],"f":1,"a":270},{"p":[1209,27],"f":1,"a":270},{"p":[1466,116],"f":2,"a":105},{"p":[1554,140],"f":2,"a":105},{"p":[1651,202],"f":3,"a":0},{"p":[374,381],"f":2,"a":90},{"p":[273,381],"f":2,"a":75},{"p":[185,413],"f":2,"a":45},{"p":[130,481],"f":2,"a":30},{"p":[97,568],"f":2,"a":15},{"p":[7,667],"f":1,"a":180},{"p":[10,940],"f":1,"a":180},{"p":[101,1210],"f":2,"a":0},{"p":[97,1302],"f":2,"a":0},{"p":[91,1384],"f":2,"a":345},{"p":[117,1463],"f":2,"a":330},{"p":[169,1537],"f":2,"a":315},{"p":[256,1591],"f":2,"a":285},{"p":[360,1614],"f":2,"a":270},{"p":[379,1359],"f":2,"a":300},{"p":[330,1298],"f":2,"a":345},{"p":[239,1037],"f":1,"a":180},{"p":[239,766],"f":1,"a":180},{"p":[332,667],"f":2,"a":15},{"p":[392,609],"f":2,"a":75},{"p":[398,563],"f":1,"a":135},{"p":[588,758],"f":1,"a":135},{"p":[413,1175],"f":1,"a":60},{"p":[619,1002],"f":1,"a":45},{"p":[846,1013],"f":2,"a":330},{"p":[1128,1110],"f":3,"a":0},{"p":[1416,1138],"f":3,"a":0},{"p":[1738,1174],"f":3,"a":0}],"decals":[{"p":[114,756],"f":4,"a":270},{"p":[114,1044],"f":4,"a":90},{"p":[162,444],"f":5,"a":0},{"p":[162,1332],"f":5,"a":270},{"p":[2376,1524],"f":5,"a":180},{"p":[2448,1236],"f":4,"a":90},{"p":[2448,948],"f":4,"a":90},{"p":[2376,636],"f":5,"a":90},{"p":[2412,678],"f":6,"a":0},{"p":[2406,774],"f":6,"a":0},{"p":[402,1470],"f":6,"a":180},{"p":[402,1572],"f":6,"a":180},{"p":[168,816],"f":7,"a":180},{"p":[246,816],"f":7,"a":180},{"p":[408,486],"f":8,"a":0},{"p":[408,570],"f":8,"a":0},{"p":[2388,1674],"f":8,"a":180},{"p":[2388,1752],"f":8,"a":180},{"p":[282,876],"f":9,"a":180},{"p":[186,960],"f":9,"a":180},{"p":[282,1050],"f":9,"a":180},{"p":[180,1140],"f":9,"a":180},{"p":[282,1242],"f":9,"a":180},{"p":[180,1332],"f":9,"a":180}],"laps":5,"ai_waypoints":[{"p":[277,672],"n":1},{"p":[428,550],"n":2},{"p":[1032,558],"n":3},{"p":[1927,656],"n":4},{"p":[2438,788],"n":5},{"p":[2611,971],"n":6},{"p":[2622,1350],"n":7},{"p":[2493,1616],"n":8},{"p":[2013,1746],"n":9},{"p":[1107,1684],"n":10},{"p":[377,1469],"n":11},{"p":[265,1337],"n":12},{"p":[233,1047],"n":13}],"checkpoints":[{"p":[131,591],"n":1},{"p":[411,388],"n":2},{"p":[2376,613],"n":3},{"p":[2375,1572],"n":4},{"p":[197,1400],"n":5}],"start_positions":[{"p":[276,912],"n":1,"a":0},{"p":[180,996],"n":2,"a":0},{"p":[276,1086],"n":3,"a":0},{"p":[174,1176],"n":4,"a":0},{"p":[276,1278],"n":5,"a":0},{"p":[174,1368],"n":6,"a":0}],"dict":{"1":"9tires.png","2":"3tires.png","3":"tire.png","4":"ilgas.png","5":"dideliskampas.png","6":"arrow2.png","7":"startbar.png","8":"arrow.png","9":"white_bar.png"}},"3_hunter_end":{"size":[2500,2900],"title":"Hunter End","bgtile":"grass.png","props":[{"p":[850,1857],"f":1,"a":180},{"p":[696,1736],"f":1,"a":90},{"p":[425,1736],"f":1,"a":90},{"p":[335,1826],"f":2,"a":90},{"p":[244,1825],"f":2,"a":90},{"p":[144,1773],"f":2,"a":135},{"p":[101,1706],"f":2,"a":165},{"p":[98,1625],"f":2,"a":180},{"p":[96,1533],"f":2,"a":180},{"p":[107,1430],"f":2,"a":30},{"p":[173,1363],"f":2,"a":60},{"p":[276,1359],"f":2,"a":90},{"p":[368,1361],"f":2,"a":90},{"p":[433,1351],"f":3,"a":60},{"p":[350,1259],"f":2,"a":135},{"p":[313,1187],"f":2,"a":165},{"p":[220,926],"f":1,"a":0},{"p":[267,819],"f":2,"a":135},{"p":[210,750],"f":2,"a":150},{"p":[207,678],"f":2,"a":180},{"p":[211,576],"f":2,"a":195},{"p":[250,493],"f":2,"a":225},{"p":[315,441],"f":2,"a":180},{"p":[309,336],"f":2,"a":195},{"p":[331,243],"f":2,"a":210},{"p":[393,175],"f":2,"a":240},{"p":[480,139],"f":2,"a":255},{"p":[583,42],"f":1,"a":270},{"p":[856,131],"f":2,"a":270},{"p":[936,127],"f":2,"a":285},{"p":[1018,152],"f":2,"a":300},{"p":[1089,205],"f":2,"a":315},{"p":[1144,298],"f":2,"a":345},{"p":[1078,398],"f":1,"a":180},{"p":[1194,664],"f":3,"a":60},{"p":[1194,695],"f":3,"a":60},{"p":[1220,716],"f":3,"a":60},{"p":[1257,602],"f":1,"a":90},{"p":[1529,601],"f":1,"a":90},{"p":[1800,598],"f":1,"a":90},{"p":[2072,687],"f":2,"a":270},{"p":[2152,686],"f":2,"a":285},{"p":[2222,723],"f":2,"a":315},{"p":[2279,811],"f":2,"a":345},{"p":[2300,911],"f":2,"a":0},{"p":[2285,995],"f":2,"a":15},{"p":[2242,1073],"f":2,"a":30},{"p":[2178,1129],"f":2,"a":75},{"p":[2098,1152],"f":2,"a":90},{"p":[2007,1151],"f":2,"a":90},{"p":[1914,1153],"f":2,"a":90},{"p":[1901,1183],"f":2,"a":135},{"p":[1961,1257],"f":2,"a":150},{"p":[2005,1360],"f":2,"a":180},{"p":[1918,1450],"f":1,"a":0},{"p":[2009,1719],"f":2,"a":180},{"p":[2006,1812],"f":2,"a":180},{"p":[2015,1895],"f":3,"a":60},{"p":[1993,1920],"f":3,"a":60},{"p":[1878,1955],"f":1,"a":0},{"p":[1966,2225],"f":2,"a":180},{"p":[1992,2314],"f":3,"a":60},{"p":[1992,2336],"f":2,"a":165},{"p":[2013,2438],"f":2,"a":180},{"p":[1989,2520],"f":2,"a":195},{"p":[1940,2594],"f":2,"a":225},{"p":[1872,2660],"f":2,"a":240},{"p":[1792,2702],"f":2,"a":255},{"p":[1711,2719],"f":2,"a":270},{"p":[1614,2740],"f":2,"a":225},{"p":[1544,2795],"f":2,"a":255},{"p":[1462,2818],"f":2,"a":270},{"p":[1359,2780],"f":2,"a":300},{"p":[1280,2722],"f":2,"a":315},{"p":[1497,2628],"f":3,"a":60},{"p":[1216,2716],"f":2,"a":270},{"p":[1115,2694],"f":2,"a":285},{"p":[1027,2645],"f":2,"a":315},{"p":[966,2581],"f":2,"a":330},{"p":[935,2502],"f":2,"a":345},{"p":[844,2241],"f":1,"a":0},{"p":[937,2152],"f":2,"a":0},{"p":[962,2118],"f":3,"a":60},{"p":[352,1620],"f":3,"a":60},{"p":[383,1620],"f":3,"a":60},{"p":[937,1617],"f":3,"a":60},{"p":[957,1391],"f":3,"a":60},{"p":[906,1616],"f":3,"a":60},{"p":[925,1392],"f":3,"a":60},{"p":[910,1145],"f":2,"a":270},{"p":[964,1137],"f":3,"a":60},{"p":[965,1104],"f":3,"a":60},{"p":[548,1082],"f":2,"a":330},{"p":[635,1163],"f":3,"a":60},{"p":[564,1067],"f":3,"a":60},{"p":[666,1166],"f":3,"a":60},{"p":[459,698],"f":3,"a":90},{"p":[554,815],"f":2,"a":225},{"p":[616,747],"f":2,"a":210},{"p":[650,675],"f":2,"a":180},{"p":[617,566],"f":2,"a":150},{"p":[559,486],"f":2,"a":135},{"p":[538,408],"f":2,"a":210},{"p":[611,359],"f":2,"a":255},{"p":[824,361],"f":2,"a":270},{"p":[888,375],"f":2,"a":315},{"p":[942,475],"f":2,"a":0},{"p":[942,909],"f":2,"a":0},{"p":[1220,952],"f":3,"a":90},{"p":[1251,952],"f":3,"a":90},{"p":[1199,1180],"f":3,"a":90},{"p":[1229,1180],"f":3,"a":90},{"p":[2093,953],"f":3,"a":90},{"p":[2063,951],"f":3,"a":90},{"p":[1725,1382],"f":2,"a":135},{"p":[1661,1369],"f":2,"a":90},{"p":[1776,1481],"f":2,"a":180},{"p":[1195,1367],"f":2,"a":270},{"p":[1169,1579],"f":2,"a":0},{"p":[1194,1426],"f":3,"a":90},{"p":[1195,1458],"f":3,"a":90},{"p":[1165,2331],"f":2,"a":0},{"p":[1163,2401],"f":2,"a":330},{"p":[1227,2464],"f":2,"a":300},{"p":[1293,2432],"f":2,"a":225},{"p":[1377,2390],"f":2,"a":255},{"p":[1479,2385],"f":2,"a":270},{"p":[1550,2390],"f":2,"a":300},{"p":[1623,2441],"f":2,"a":315},{"p":[1706,2450],"f":2,"a":240},{"p":[1765,2381],"f":2,"a":195},{"p":[1822,2360],"f":3,"a":90},{"p":[1847,2335],"f":3,"a":90},{"p":[1728,2064],"f":1,"a":0},{"p":[1816,1970],"f":2,"a":180},{"p":[1786,1863],"f":2,"a":150},{"p":[1689,1611],"f":1,"a":0},{"p":[1808,1576],"f":3,"a":90},{"p":[1077,2059],"f":1,"a":0},{"p":[1078,1784],"f":1,"a":0},{"p":[1169,1693],"f":2,"a":180},{"p":[1199,1666],"f":3,"a":90},{"p":[1166,1489],"f":2,"a":180},{"p":[1562,1368],"f":2,"a":90}],"decals":[{"p":[978,1182],"f":4,"a":0},{"p":[906,750],"f":5,"a":90},{"p":[858,1422],"f":5,"a":270},{"p":[1242,702],"f":6,"a":0},{"p":[1242,942],"f":6,"a":0},{"p":[1530,702],"f":6,"a":0},{"p":[1530,942],"f":6,"a":0},{"p":[1818,702],"f":6,"a":0},{"p":[1818,942],"f":6,"a":0},{"p":[2106,750],"f":7,"a":90},{"p":[2106,966],"f":7,"a":180},{"p":[666,1374],"f":6,"a":0},{"p":[666,1614],"f":6,"a":0},{"p":[378,1374],"f":6,"a":0},{"p":[378,1614],"f":6,"a":0},{"p":[162,1422],"f":7,"a":0},{"p":[162,1638],"f":7,"a":270},{"p":[690,1158],"f":6,"a":0},{"p":[378,1086],"f":8,"a":270},{"p":[378,198],"f":8,"a":0},{"p":[690,198],"f":9,"a":270},{"p":[1002,558],"f":9,"a":180},{"p":[882,198],"f":8,"a":90},{"p":[1002,462],"f":10,"a":0},{"p":[954,1854],"f":6,"a":90},{"p":[1218,1158],"f":6,"a":0},{"p":[1458,1206],"f":10,"a":270},{"p":[270,408],"f":11,"a":0},{"p":[270,612],"f":11,"a":180},{"p":[378,948],"f":10,"a":180},{"p":[378,870],"f":10,"a":180},{"p":[954,2142],"f":6,"a":90},{"p":[1002,2430],"f":8,"a":270},{"p":[1212,2442],"f":11,"a":270},{"p":[1416,2442],"f":11,"a":90},{"p":[1722,2430],"f":8,"a":180},{"p":[1842,2238],"f":12,"a":90},{"p":[1842,2046],"f":13,"a":270},{"p":[1842,1854],"f":12,"a":270},{"p":[1794,1566],"f":6,"a":90},{"p":[1722,1206],"f":8,"a":90},{"p":[1842,1470],"f":10,"a":180},{"p":[1554,1206],"f":10,"a":270},{"p":[1578,1206],"f":10,"a":270},{"p":[1008,1950],"f":14,"a":180},{"p":[1086,1950],"f":14,"a":180},{"p":[1122,2010],"f":15,"a":180},{"p":[1020,2088],"f":15,"a":180},{"p":[1122,2172],"f":15,"a":180},{"p":[1020,2256],"f":15,"a":180},{"p":[1122,2352],"f":15,"a":180},{"p":[1020,2436],"f":15,"a":180},{"p":[1026,1656],"f":16,"a":90},{"p":[1098,1650],"f":16,"a":90},{"p":[870,1458],"f":17,"a":180},{"p":[876,1542],"f":17,"a":180},{"p":[888,1704],"f":16,"a":180},{"p":[888,1788],"f":16,"a":180},{"p":[1032,1374],"f":16,"a":90},{"p":[1038,816],"f":16,"a":270},{"p":[1116,810],"f":16,"a":270},{"p":[1332,1020],"f":17,"a":0},{"p":[1332,1104],"f":17,"a":0},{"p":[1302,780],"f":16,"a":0},{"p":[1302,858],"f":16,"a":0},{"p":[1140,1212],"f":16,"a":270}],"laps":3,"ai_waypoints":[{"p":[1038,1612],"n":1},{"p":[789,1485],"n":2},{"p":[297,1530],"n":3},{"p":[260,1712],"n":4},{"p":[980,1714],"n":5},{"p":[1087,1465],"n":6},{"p":[983,1329],"n":7},{"p":[549,1222],"n":8},{"p":[460,1045],"n":9},{"p":[373,739],"n":10},{"p":[541,346],"n":11},{"p":[775,289],"n":12},{"p":[1017,381],"n":13},{"p":[1133,975],"n":14},{"p":[1577,1117],"n":15},{"p":[2137,1024],"n":16},{"p":[2117,811],"n":17},{"p":[1623,779],"n":18},{"p":[1142,921],"n":19},{"p":[1059,1117],"n":20},{"p":[1264,1323],"n":21},{"p":[1781,1316],"n":22},{"p":[1918,1536],"n":23},{"p":[1915,2346],"n":24},{"p":[1793,2585],"n":25},{"p":[1505,2707],"n":26},{"p":[1171,2562],"n":27},{"p":[1079,2316],"n":28}],"checkpoints":[{"p":[967,1726],"n":1},{"p":[650,1394],"n":2},{"p":[115,1499],"n":3},{"p":[649,1649],"n":4},{"p":[905,1195],"n":5},{"p":[382,1127],"n":6},{"p":[331,736],"n":7},{"p":[365,192],"n":8},{"p":[885,193],"n":9},{"p":[956,927],"n":10},{"p":[2076,819],"n":11},{"p":[992,739],"n":12},{"p":[970,1176],"n":13},{"p":[1740,1192],"n":14},{"p":[1781,2359],"n":15},{"p":[975,2446],"n":16}],"start_positions":[{"p":[1116,2046],"n":1,"a":0},{"p":[1014,2124],"n":2,"a":0},{"p":[1116,2208],"n":3,"a":0},{"p":[1014,2292],"n":4,"a":0},{"p":[1116,2388],"n":5,"a":0},{"p":[1014,2472],"n":6,"a":0}],"dict":{"1":"9tires.png","2":"3tires.png","3":"tire.png","4":"susikerta.png","5":"uglyduckling.png","6":"ilgas.png","7":"lenktas.png","8":"dideliskampas.png","9":"paprastas.png","10":"trumpas.png","11":"issisakojimas.png","12":"siaurasiplatu.png","13":"siauras.png","14":"startbar.png","15":"white_bar.png","16":"arrow4.png","17":"arrow.png"}},"3_lullabycircuit":{"size":[2500,2400],"title":"Lullaby Circuit","bgtile":"sand.png","props":[{"p":[1579,1097],"f":1,"a":270},{"p":[1849,1098],"f":1,"a":270},{"p":[2122,1189],"f":2,"a":90},{"p":[2212,1188],"f":2,"a":90},{"p":[2282,1147],"f":2,"a":60},{"p":[2357,1088],"f":2,"a":45},{"p":[2415,1019],"f":2,"a":15},{"p":[2352,761],"f":1,"a":180},{"p":[2405,658],"f":2,"a":330},{"p":[2350,580],"f":2,"a":315},{"p":[2276,530],"f":2,"a":300},{"p":[2025,437],"f":1,"a":90},{"p":[1988,551],"f":3,"a":45},{"p":[1955,545],"f":3,"a":45},{"p":[1918,462],"f":2,"a":180},{"p":[1877,359],"f":2,"a":150},{"p":[1819,292],"f":2,"a":120},{"p":[1567,196],"f":1,"a":90},{"p":[1476,287],"f":2,"a":90},{"p":[1443,336],"f":3,"a":45},{"p":[1178,237],"f":1,"a":90},{"p":[907,238],"f":1,"a":90},{"p":[870,353],"f":3,"a":45},{"p":[840,350],"f":3,"a":45},{"p":[816,328],"f":3,"a":45},{"p":[553,198],"f":1,"a":90},{"p":[461,286],"f":2,"a":90},{"p":[423,311],"f":3,"a":45},{"p":[391,312],"f":3,"a":45},{"p":[361,319],"f":3,"a":45},{"p":[266,304],"f":2,"a":225},{"p":[208,374],"f":2,"a":210},{"p":[207,477],"f":2,"a":180},{"p":[207,567],"f":2,"a":180},{"p":[211,639],"f":2,"a":150},{"p":[274,705],"f":2,"a":120},{"p":[375,751],"f":2,"a":90},{"p":[455,753],"f":2,"a":105},{"p":[513,803],"f":2,"a":150},{"p":[510,886],"f":2,"a":210},{"p":[446,938],"f":2,"a":255},{"p":[366,957],"f":2,"a":270},{"p":[262,961],"f":2,"a":240},{"p":[186,1007],"f":2,"a":225},{"p":[129,1078],"f":2,"a":210},{"p":[25,1179],"f":1,"a":0},{"p":[117,1439],"f":2,"a":165},{"p":[153,1510],"f":2,"a":135},{"p":[229,1570],"f":2,"a":120},{"p":[334,1614],"f":2,"a":90},{"p":[426,1617],"f":2,"a":90},{"p":[488,1630],"f":2,"a":135},{"p":[568,1721],"f":3,"a":45},{"p":[559,1753],"f":3,"a":45},{"p":[475,1728],"f":2,"a":90},{"p":[373,1730],"f":2,"a":75},{"p":[285,1765],"f":2,"a":45},{"p":[231,1836],"f":2,"a":30},{"p":[199,1923],"f":2,"a":15},{"p":[201,2023],"f":2,"a":0},{"p":[202,2115],"f":2,"a":0},{"p":[206,2196],"f":2,"a":345},{"p":[240,2265],"f":2,"a":315},{"p":[312,2327],"f":2,"a":300},{"p":[402,2366],"f":2,"a":285},{"p":[504,2386],"f":2,"a":270},{"p":[597,2383],"f":2,"a":270},{"p":[676,2363],"f":2,"a":255},{"p":[745,2312],"f":2,"a":225},{"p":[808,2247],"f":2,"a":210},{"p":[853,2169],"f":2,"a":195},{"p":[871,2087],"f":2,"a":180},{"p":[872,1984],"f":2,"a":210},{"p":[964,1961],"f":2,"a":270},{"p":[1024,1972],"f":2,"a":315},{"p":[1071,2074],"f":2,"a":0},{"p":[1073,2164],"f":2,"a":0},{"p":[1086,2234],"f":2,"a":330},{"p":[1139,2305],"f":2,"a":315},{"p":[1226,2360],"f":2,"a":285},{"p":[1326,2293],"f":1,"a":270},{"p":[1575,2345],"f":2,"a":240},{"p":[1645,2288],"f":2,"a":225},{"p":[1700,2213],"f":2,"a":210},{"p":[1733,2142],"f":2,"a":180},{"p":[1734,2050],"f":2,"a":180},{"p":[1731,1957],"f":2,"a":180},{"p":[1690,1852],"f":2,"a":150},{"p":[1635,1774],"f":2,"a":135},{"p":[1566,1734],"f":2,"a":105},{"p":[1484,1727],"f":2,"a":90},{"p":[1448,1747],"f":3,"a":45},{"p":[1419,1725],"f":3,"a":45},{"p":[1395,1638],"f":2,"a":0},{"p":[1360,1532],"f":2,"a":330},{"p":[1308,1454],"f":2,"a":315},{"p":[1349,1419],"f":2,"a":255},{"p":[1426,1379],"f":2,"a":240},{"p":[1488,1316],"f":2,"a":210},{"p":[1531,1245],"f":2,"a":180},{"p":[1070,1219],"f":2,"a":180},{"p":[997,1187],"f":2,"a":240},{"p":[957,1264],"f":2,"a":195},{"p":[973,1336],"f":2,"a":135},{"p":[1068,1299],"f":2,"a":165},{"p":[1060,1363],"f":2,"a":255},{"p":[1297,1162],"f":2,"a":180},{"p":[1304,1058],"f":2,"a":210},{"p":[1350,978],"f":2,"a":225},{"p":[1438,949],"f":2,"a":255},{"p":[1537,951],"f":2,"a":270},{"p":[1629,861],"f":1,"a":270},{"p":[1899,862],"f":1,"a":270},{"p":[2151,919],"f":2,"a":240},{"p":[2210,859],"f":2,"a":180},{"p":[2154,761],"f":2,"a":135},{"p":[1908,663],"f":1,"a":270},{"p":[1807,734],"f":2,"a":105},{"p":[1722,680],"f":2,"a":135},{"p":[1687,611],"f":2,"a":165},{"p":[1714,585],"f":3,"a":60},{"p":[1714,552],"f":3,"a":60},{"p":[1631,512],"f":2,"a":90},{"p":[1540,512],"f":2,"a":90},{"p":[1500,537],"f":3,"a":60},{"p":[1405,473],"f":2,"a":135},{"p":[1160,380],"f":1,"a":270},{"p":[890,381],"f":1,"a":270},{"p":[786,472],"f":2,"a":60},{"p":[465,520],"f":2,"a":90},{"p":[557,519],"f":2,"a":90},{"p":[649,519],"f":2,"a":90},{"p":[734,541],"f":3,"a":60},{"p":[768,538],"f":3,"a":60},{"p":[638,548],"f":2,"a":120},{"p":[703,613],"f":2,"a":150},{"p":[749,701],"f":2,"a":165},{"p":[771,800],"f":2,"a":180},{"p":[770,893],"f":2,"a":180},{"p":[792,952],"f":2,"a":135},{"p":[451,1185],"f":2,"a":90},{"p":[543,1185],"f":2,"a":90},{"p":[354,1200],"f":2,"a":45},{"p":[335,1289],"f":2,"a":345},{"p":[380,1356],"f":2,"a":300},{"p":[484,1391],"f":2,"a":270},{"p":[882,967],"f":2,"a":75},{"p":[980,961],"f":2,"a":90},{"p":[1070,960],"f":2,"a":90},{"p":[1150,956],"f":2,"a":105},{"p":[1218,995],"f":2,"a":135},{"p":[1302,1092],"f":3,"a":60},{"p":[1299,1975],"f":2,"a":180},{"p":[1294,2057],"f":2,"a":165},{"p":[1341,2122],"f":2,"a":120},{"p":[1424,2124],"f":2,"a":60},{"p":[1484,2061],"f":2,"a":15},{"p":[1453,1973],"f":2,"a":315},{"p":[1381,1945],"f":2,"a":285},{"p":[1356,1970],"f":3,"a":60},{"p":[900,1729],"f":2,"a":270},{"p":[992,1729],"f":2,"a":270},{"p":[1083,1729],"f":2,"a":270},{"p":[1062,1613],"f":2,"a":105},{"p":[982,1615],"f":2,"a":90},{"p":[772,1666],"f":2,"a":0},{"p":[802,1604],"f":2,"a":270},{"p":[946,1632],"f":3,"a":60},{"p":[915,1628],"f":3,"a":60},{"p":[887,1628],"f":3,"a":60},{"p":[432,2062],"f":2,"a":345},{"p":[445,1971],"f":2,"a":45},{"p":[546,1956],"f":2,"a":90},{"p":[605,1977],"f":2,"a":150},{"p":[551,2132],"f":2,"a":255},{"p":[495,2149],"f":3,"a":60},{"p":[527,2168],"f":3,"a":60},{"p":[615,2069],"f":2,"a":195},{"p":[797,1750],"f":3,"a":60},{"p":[793,1782],"f":3,"a":60},{"p":[825,1770],"f":3,"a":60},{"p":[862,1757],"f":3,"a":60},{"p":[1164,1768],"f":3,"a":60},{"p":[1191,1786],"f":3,"a":60},{"p":[1195,1752],"f":3,"a":60},{"p":[1187,1720],"f":3,"a":60},{"p":[1174,1691],"f":3,"a":60},{"p":[1152,1668],"f":3,"a":60},{"p":[563,1390],"f":2,"a":105},{"p":[640,1418],"f":2,"a":120},{"p":[737,1467],"f":3,"a":60},{"p":[737,1395],"f":2,"a":0},{"p":[735,1304],"f":2,"a":0},{"p":[738,1212],"f":2,"a":0},{"p":[615,1141],"f":2,"a":60},{"p":[708,1182],"f":3,"a":60},{"p":[732,1197],"f":3,"a":60}],"decals":[{"p":[270,2100],"f":4,"a":270},{"p":[582,2100],"f":4,"a":180},{"p":[702,1788],"f":4,"a":0},{"p":[1014,1788],"f":4,"a":90},{"p":[1134,2100],"f":4,"a":270},{"p":[1446,2100],"f":4,"a":180},{"p":[1446,1788],"f":4,"a":90},{"p":[1230,1764],"f":5,"a":270},{"p":[270,1788],"f":4,"a":0},{"p":[582,1764],"f":5,"a":180},{"p":[486,1452],"f":4,"a":90},{"p":[174,1332],"f":4,"a":270},{"p":[174,1020],"f":4,"a":0},{"p":[486,900],"f":4,"a":180},{"p":[486,588],"f":4,"a":90},{"p":[270,564],"f":5,"a":270},{"p":[270,348],"f":5,"a":0},{"p":[480,300],"f":6,"a":0},{"p":[768,348],"f":7,"a":180},{"p":[960,348],"f":8,"a":0},{"p":[1152,348],"f":8,"a":0},{"p":[1110,1452],"f":4,"a":90},{"p":[798,1332],"f":4,"a":270},{"p":[798,1020],"f":4,"a":0},{"p":[1104,1020],"f":5,"a":90},{"p":[1128,1236],"f":5,"a":270},{"p":[1344,1236],"f":5,"a":180},{"p":[1368,1020],"f":5,"a":0},{"p":[1584,972],"f":6,"a":0},{"p":[1872,972],"f":6,"a":0},{"p":[2160,900],"f":4,"a":180},{"p":[1344,348],"f":7,"a":0},{"p":[1536,348],"f":9,"a":90},{"p":[1728,348],"f":5,"a":90},{"p":[1752,564],"f":5,"a":270},{"p":[2160,588],"f":4,"a":90},{"p":[1968,588],"f":9,"a":90},{"p":[2076,1026],"f":10,"a":90},{"p":[2076,1104],"f":10,"a":90},{"p":[2058,1044],"f":11,"a":90},{"p":[1980,1140],"f":11,"a":90},{"p":[1896,1044],"f":11,"a":90},{"p":[1806,1140],"f":11,"a":90},{"p":[1704,1044],"f":11,"a":90},{"p":[1608,1140],"f":11,"a":90}],"laps":3,"ai_waypoints":[{"p":[2241,1050],"n":1},{"p":[2345,870],"n":2},{"p":[2193,710],"n":3},{"p":[1916,627],"n":4},{"p":[1761,498],"n":5},{"p":[1486,426],"n":6},{"p":[796,423],"n":7},{"p":[417,485],"n":8},{"p":[433,618],"n":9},{"p":[629,786],"n":10},{"p":[383,1143],"n":12},{"p":[254,1329],"n":13},{"p":[590,1600],"n":14},{"p":[621,1803],"n":15},{"p":[386,1986],"n":16},{"p":[458,2252],"n":17},{"p":[718,2196],"n":18},{"p":[875,1945],"n":19},{"p":[1096,1928],"n":20},{"p":[1296,2233],"n":21},{"p":[1582,2206],"n":22},{"p":[1564,1967],"n":23},{"p":[1358,1783],"n":24},{"p":[1140,1558],"n":25},{"p":[904,1348],"n":26},{"p":[1005,1135],"n":27},{"p":[1194,1214],"n":28},{"p":[1345,1304],"n":29},{"p":[1508,1142],"n":30},{"p":[609,1012],"n":11}],"checkpoints":[{"p":[2121,979],"n":1},{"p":[2165,600],"n":2},{"p":[1716,467],"n":3},{"p":[282,285],"n":4},{"p":[444,581],"n":5},{"p":[410,959],"n":6},{"p":[176,1358],"n":7},{"p":[516,1690],"n":8},{"p":[337,2139],"n":9},{"p":[871,1757],"n":10},{"p":[1227,2180],"n":11},{"p":[1448,1783],"n":12},{"p":[1047,1454],"n":13},{"p":[772,1077],"n":14},{"p":[1186,1175],"n":15}],"start_positions":[{"p":[2010,1038],"n":1,"a":90},{"p":[1932,1134],"n":2,"a":90},{"p":[1848,1038],"n":3,"a":90},{"p":[1758,1134],"n":4,"a":90},{"p":[1656,1038],"n":5,"a":90},{"p":[1560,1134],"n":6,"a":90}],"dict":{"1":"9tires.png","2":"3tires.png","3":"tire.png","4":"dideliskampas.png","5":"lenktas.png","6":"ilgas.png","7":"siaurasiplatu.png","8":"siauras.png","9":"paprastas.png","10":"startbar.png","11":"white_bar.png"}},"3_peril_flats":{"size":[2900,2700],"title":"Peril Flats","bgtile":"snow.png","props":[{"p":[1141,1534],"f":1,"a":0},{"p":[1111,1534],"f":1,"a":0},{"p":[546,1504],"f":2,"a":270},{"p":[448,1448],"f":2,"a":315},{"p":[447,1516],"f":2,"a":255},{"p":[365,1555],"f":2,"a":225},{"p":[312,1629],"f":2,"a":210},{"p":[208,1730],"f":3,"a":0},{"p":[303,1990],"f":2,"a":165},{"p":[338,2061],"f":2,"a":135},{"p":[412,2119],"f":2,"a":120},{"p":[504,2156],"f":2,"a":105},{"p":[604,2083],"f":3,"a":270},{"p":[876,2083],"f":3,"a":270},{"p":[1138,2152],"f":2,"a":75},{"p":[1213,2106],"f":2,"a":60},{"p":[1277,2042],"f":2,"a":45},{"p":[1341,1985],"f":2,"a":0},{"p":[1352,2078],"f":2,"a":0},{"p":[1353,2169],"f":2,"a":0},{"p":[1349,2250],"f":2,"a":345},{"p":[1379,2326],"f":2,"a":330},{"p":[1440,2391],"f":2,"a":300},{"p":[1530,2437],"f":2,"a":285},{"p":[1631,2458],"f":2,"a":270},{"p":[1723,2488],"f":1,"a":0},{"p":[1754,2484],"f":1,"a":0},{"p":[1780,2466],"f":1,"a":0},{"p":[1806,2445],"f":1,"a":0},{"p":[1839,2324],"f":3,"a":270},{"p":[2111,2415],"f":2,"a":270},{"p":[2174,2421],"f":2,"a":315},{"p":[2277,2370],"f":3,"a":270},{"p":[2537,2442],"f":2,"a":255},{"p":[2605,2390],"f":2,"a":225},{"p":[2666,2325],"f":2,"a":195},{"p":[2685,2245],"f":2,"a":180},{"p":[2684,2154],"f":2,"a":180},{"p":[2640,2053],"f":2,"a":150},{"p":[2573,1994],"f":2,"a":120},{"p":[2321,1899],"f":3,"a":270},{"p":[2228,1988],"f":2,"a":90},{"p":[2125,1970],"f":2,"a":105},{"p":[2112,1980],"f":1,"a":0},{"p":[2094,1948],"f":1,"a":0},{"p":[2061,1856],"f":2,"a":180},{"p":[2062,1764],"f":2,"a":180},{"p":[2035,1666],"f":2,"a":165},{"p":[1981,1579],"f":2,"a":135},{"p":[1910,1522],"f":2,"a":120},{"p":[1839,1513],"f":2,"a":90},{"p":[1739,1493],"f":2,"a":105},{"p":[1773,1446],"f":2,"a":60},{"p":[1842,1386],"f":2,"a":45},{"p":[1895,1314],"f":2,"a":15},{"p":[1916,1231],"f":2,"a":0},{"p":[1915,1130],"f":2,"a":15},{"p":[1968,1061],"f":2,"a":60},{"p":[2070,1064],"f":2,"a":90},{"p":[2150,1045],"f":2,"a":75},{"p":[2226,1001],"f":2,"a":60},{"p":[2289,938],"f":2,"a":30},{"p":[2331,861],"f":2,"a":15},{"p":[2351,778],"f":2,"a":0},{"p":[2349,685],"f":2,"a":0},{"p":[2329,585],"f":2,"a":345},{"p":[2286,492],"f":2,"a":330},{"p":[2220,429],"f":2,"a":300},{"p":[2142,404],"f":2,"a":285},{"p":[2061,403],"f":2,"a":270},{"p":[1970,402],"f":2,"a":270},{"p":[1869,404],"f":2,"a":255},{"p":[1778,433],"f":2,"a":240},{"p":[1712,495],"f":2,"a":210},{"p":[1686,586],"f":2,"a":195},{"p":[1690,686],"f":2,"a":180},{"p":[1656,743],"f":2,"a":90},{"p":[1556,739],"f":2,"a":75},{"p":[1466,762],"f":2,"a":60},{"p":[1398,820],"f":2,"a":30},{"p":[1366,902],"f":2,"a":15},{"p":[1336,905],"f":2,"a":0},{"p":[1347,994],"f":2,"a":0},{"p":[1248,633],"f":3,"a":0},{"p":[1319,531],"f":2,"a":345},{"p":[1271,440],"f":2,"a":315},{"p":[1202,382],"f":2,"a":300},{"p":[1123,354],"f":2,"a":285},{"p":[862,264],"f":3,"a":270},{"p":[768,357],"f":2,"a":270},{"p":[676,356],"f":2,"a":270},{"p":[574,355],"f":2,"a":255},{"p":[485,387],"f":2,"a":240},{"p":[420,448],"f":2,"a":210},{"p":[391,539],"f":2,"a":195},{"p":[389,639],"f":2,"a":180},{"p":[421,730],"f":1,"a":0},{"p":[394,743],"f":2,"a":150},{"p":[344,847],"f":3,"a":180},{"p":[434,1119],"f":2,"a":180},{"p":[396,1182],"f":2,"a":225},{"p":[392,1283],"f":2,"a":180},{"p":[395,1360],"f":2,"a":165},{"p":[458,1452],"f":1,"a":0},{"p":[580,1139],"f":2,"a":180},{"p":[630,1222],"f":1,"a":0},{"p":[623,1240],"f":2,"a":180},{"p":[683,1272],"f":2,"a":90},{"p":[1085,1275],"f":2,"a":90},{"p":[1116,1215],"f":2,"a":0},{"p":[1053,1306],"f":1,"a":0},{"p":[578,808],"f":2,"a":0},{"p":[631,783],"f":1,"a":0},{"p":[621,694],"f":2,"a":0},{"p":[636,595],"f":2,"a":45},{"p":[738,617],"f":1,"a":0},{"p":[769,617],"f":1,"a":0},{"p":[990,583],"f":2,"a":90},{"p":[1054,595],"f":2,"a":135},{"p":[1114,694],"f":2,"a":180},{"p":[579,1046],"f":2,"a":180},{"p":[578,952],"f":2,"a":180},{"p":[608,922],"f":1,"a":0},{"p":[608,894],"f":1,"a":0},{"p":[1377,1303],"f":1,"a":0},{"p":[1374,1274],"f":1,"a":0},{"p":[1579,1242],"f":2,"a":180},{"p":[1639,1300],"f":1,"a":0},{"p":[1665,1284],"f":1,"a":0},{"p":[1760,995],"f":1,"a":0},{"p":[1729,995],"f":1,"a":0},{"p":[1762,1025],"f":1,"a":0},{"p":[1699,996],"f":1,"a":0},{"p":[1753,1056],"f":1,"a":0},{"p":[1790,986],"f":1,"a":0},{"p":[1931,873],"f":1,"a":0},{"p":[1936,842],"f":1,"a":0},{"p":[1960,870],"f":1,"a":0},{"p":[1915,750],"f":2,"a":180},{"p":[1993,840],"f":2,"a":90},{"p":[1927,650],"f":2,"a":45},{"p":[2024,638],"f":2,"a":90},{"p":[2079,662],"f":2,"a":150},{"p":[2103,753],"f":2,"a":195},{"p":[2083,861],"f":1,"a":0},{"p":[2110,844],"f":1,"a":0},{"p":[1378,1536],"f":1,"a":0},{"p":[1609,1534],"f":1,"a":0},{"p":[1375,1771],"f":1,"a":0},{"p":[1579,1766],"f":2,"a":0},{"p":[1641,1765],"f":1,"a":0},{"p":[1670,1736],"f":2,"a":270},{"p":[1750,1738],"f":2,"a":285},{"p":[1810,1798],"f":2,"a":345},{"p":[1832,1896],"f":2,"a":0},{"p":[1834,1990],"f":2,"a":0},{"p":[1846,2059],"f":2,"a":330},{"p":[1898,2132],"f":2,"a":315},{"p":[1985,2188],"f":2,"a":285},{"p":[2084,2214],"f":2,"a":270},{"p":[2487,2254],"f":1,"a":0},{"p":[2459,2253],"f":1,"a":0},{"p":[2169,2262],"f":1,"a":0},{"p":[2187,2289],"f":1,"a":0},{"p":[2155,2302],"f":1,"a":0},{"p":[1883,2182],"f":3,"a":90},{"p":[1794,2273],"f":2,"a":270},{"p":[1777,2277],"f":1,"a":0},{"p":[1744,2260],"f":1,"a":0},{"p":[1645,2211],"f":2,"a":285},{"p":[1576,2147],"f":2,"a":330},{"p":[1581,2076],"f":2,"a":0},{"p":[1579,1984],"f":2,"a":0},{"p":[1580,1893],"f":2,"a":0},{"p":[1609,1859],"f":1,"a":0},{"p":[591,1924],"f":2,"a":285},{"p":[520,1860],"f":2,"a":330},{"p":[524,1776],"f":2,"a":30},{"p":[605,1737],"f":2,"a":75},{"p":[1082,1734],"f":2,"a":90},{"p":[1113,1796],"f":2,"a":0},{"p":[1080,1868],"f":2,"a":30},{"p":[1017,1930],"f":2,"a":75}],"decals":[{"p":[1152,1308],"f":4,"a":270},{"p":[1152,1548],"f":4,"a":270},{"p":[1392,1548],"f":4,"a":270},{"p":[1392,1308],"f":4,"a":270},{"p":[1128,1020],"f":5,"a":90},{"p":[1128,732],"f":5,"a":90},{"p":[1056,420],"f":6,"a":90},{"p":[768,372],"f":5,"a":0},{"p":[456,420],"f":6,"a":0},{"p":[456,732],"f":7,"a":270},{"p":[456,924],"f":8,"a":90},{"p":[864,1284],"f":5,"a":0},{"p":[456,1116],"f":7,"a":90},{"p":[456,1308],"f":9,"a":270},{"p":[624,1332],"f":10,"a":90},{"p":[720,1332],"f":10,"a":90},{"p":[864,1524],"f":5,"a":0},{"p":[720,1572],"f":10,"a":90},{"p":[624,1572],"f":10,"a":90},{"p":[360,1572],"f":6,"a":0},{"p":[360,1884],"f":6,"a":270},{"p":[672,1956],"f":5,"a":0},{"p":[1176,1740],"f":10,"a":180},{"p":[1056,1884],"f":6,"a":180},{"p":[912,2004],"f":10,"a":270},{"p":[1632,1212],"f":6,"a":180},{"p":[1752,900],"f":6,"a":0},{"p":[2064,780],"f":6,"a":180},{"p":[2064,468],"f":6,"a":90},{"p":[1752,468],"f":6,"a":0},{"p":[1728,780],"f":9,"a":180},{"p":[1416,804],"f":6,"a":0},{"p":[1416,1116],"f":11,"a":0},{"p":[1368,1788],"f":5,"a":90},{"p":[1416,2028],"f":10,"a":0},{"p":[1416,2172],"f":6,"a":270},{"p":[1728,2292],"f":7,"a":180},{"p":[1920,2292],"f":8,"a":180},{"p":[2112,2292],"f":7,"a":0},{"p":[2304,2292],"f":11,"a":90},{"p":[2496,2268],"f":9,"a":180},{"p":[2496,2052],"f":9,"a":90},{"p":[2208,2004],"f":5,"a":180},{"p":[1896,1932],"f":6,"a":270},{"p":[1632,1572],"f":11,"a":90},{"p":[1896,1788],"f":10,"a":0},{"p":[1776,1572],"f":6,"a":90},{"p":[1440,1770],"f":12,"a":270},{"p":[1542,1770],"f":12,"a":270},{"p":[1434,1524],"f":12,"a":270},{"p":[1536,1524],"f":12,"a":270},{"p":[1614,1362],"f":12,"a":180},{"p":[1620,1446],"f":12,"a":180},{"p":[1368,1356],"f":12,"a":180},{"p":[1368,1458],"f":12,"a":180},{"p":[1206,1290],"f":12,"a":90},{"p":[1290,1290],"f":12,"a":90},{"p":[1206,1524],"f":12,"a":90},{"p":[1296,1524],"f":12,"a":90},{"p":[1134,1602],"f":12,"a":0},{"p":[1134,1680],"f":12,"a":0},{"p":[1368,1596],"f":12,"a":0},{"p":[1368,1680],"f":12,"a":0},{"p":[1056,1578],"f":13,"a":270},{"p":[1056,1656],"f":13,"a":270},{"p":[1044,1590],"f":14,"a":270},{"p":[972,1698],"f":14,"a":270},{"p":[894,1590],"f":14,"a":270},{"p":[804,1698],"f":14,"a":270},{"p":[702,1590],"f":14,"a":270},{"p":[630,1698],"f":14,"a":270}],"laps":4,"ai_waypoints":[{"p":[1769,1617],"n":1},{"p":[1931,1817],"n":2},{"p":[2093,2072],"n":3},{"p":[2536,2189],"n":5},{"p":[2490,2323],"n":6},{"p":[2203,2378],"n":7},{"p":[1669,2348],"n":8},{"p":[1530,2234],"n":9},{"p":[1492,1856],"n":10},{"p":[1472,1266],"n":11},{"p":[1557,987],"n":12},{"p":[1752,841],"n":13},{"p":[1918,623],"n":14},{"p":[2122,577],"n":15},{"p":[2237,781],"n":16},{"p":[2069,961],"n":17},{"p":[1864,1113],"n":18},{"p":[1713,1350],"n":19},{"p":[853,1460],"n":21},{"p":[589,1336],"n":22},{"p":[535,1226],"n":23},{"p":[531,749],"n":24},{"p":[615,561],"n":25},{"p":[875,476],"n":26},{"p":[1170,575],"n":27},{"p":[1253,759],"n":28},{"p":[1249,1155],"n":29},{"p":[1250,1656],"n":30},{"p":[1196,1974],"n":31},{"p":[900,2101],"n":32},{"p":[539,2019],"n":33},{"p":[456,1867],"n":34},{"p":[538,1680],"n":35},{"p":[877,1645],"n":36},{"p":[2338,2069],"n":4},{"p":[1256,1422],"n":20}],"checkpoints":[{"p":[1101,1532],"n":1},{"p":[1772,1538],"n":2},{"p":[1879,1932],"n":3},{"p":[2463,2108],"n":4},{"p":[1438,2203],"n":5},{"p":[1387,855],"n":6},{"p":[1890,440],"n":7},{"p":[1993,845],"n":8},{"p":[1624,1265],"n":9},{"p":[428,1254],"n":10},{"p":[442,428],"n":11},{"p":[1071,429],"n":12},{"p":[1108,1878],"n":13},{"p":[359,1903],"n":14},{"p":[367,1562],"n":15}],"start_positions":[{"p":[1002,1584],"n":1,"a":90},{"p":[930,1692],"n":2,"a":90},{"p":[852,1584],"n":3,"a":90},{"p":[762,1692],"n":4,"a":90},{"p":[660,1584],"n":5,"a":90},{"p":[588,1692],"n":6,"a":90}],"dict":{"1":"tire.png","2":"3tires.png","3":"9tires.png","4":"kryzius.png","5":"ilgas.png","6":"dideliskampas.png","7":"siaurasiplatu.png","8":"siauras.png","9":"lenktas.png","10":"trumpas.png","11":"paprastas.png","12":"arrow.png","13":"startbar.png","14":"white_bar.png"}},"3_radiator":{"size":[2500,2500],"title":"The Radiator","bgtile":"sand.png","props":[{"p":[530,1036],"f":1,"a":90},{"p":[430,1040],"f":1,"a":75},{"p":[345,1080],"f":1,"a":45},{"p":[311,1166],"f":1,"a":15},{"p":[224,1264],"f":2,"a":0},{"p":[314,1534],"f":1,"a":0},{"p":[310,1614],"f":1,"a":345},{"p":[336,1692],"f":1,"a":330},{"p":[402,1749],"f":1,"a":300},{"p":[507,1788],"f":1,"a":270},{"p":[601,1789],"f":1,"a":270},{"p":[671,1754],"f":1,"a":240},{"p":[740,1694],"f":1,"a":210},{"p":[791,1624],"f":1,"a":180},{"p":[813,1689],"f":1,"a":150},{"p":[877,1749],"f":1,"a":120},{"p":[983,1791],"f":1,"a":90},{"p":[1074,1789],"f":1,"a":90},{"p":[1151,1762],"f":1,"a":75},{"p":[1212,1701],"f":1,"a":30},{"p":[1273,1636],"f":1,"a":0},{"p":[1295,1701],"f":1,"a":330},{"p":[1364,1762],"f":1,"a":300},{"p":[1467,1794],"f":1,"a":270},{"p":[1559,1796],"f":1,"a":270},{"p":[1630,1759],"f":1,"a":240},{"p":[1697,1703],"f":1,"a":210},{"p":[1755,1638],"f":1,"a":180},{"p":[1777,1701],"f":1,"a":150},{"p":[1843,1760],"f":1,"a":120},{"p":[1948,1798],"f":1,"a":90},{"p":[2040,1796],"f":1,"a":90},{"p":[2112,1760],"f":1,"a":60},{"p":[2180,1701],"f":1,"a":30},{"p":[2229,1633],"f":1,"a":0},{"p":[2141,1363],"f":2,"a":0},{"p":[2233,1271],"f":1,"a":0},{"p":[2213,1169],"f":1,"a":345},{"p":[2164,1082],"f":1,"a":315},{"p":[2100,1038],"f":1,"a":285},{"p":[2019,1037],"f":1,"a":270},{"p":[1898,797],"f":2,"a":0},{"p":[1988,706],"f":1,"a":0},{"p":[1974,605],"f":1,"a":345},{"p":[1932,515],"f":1,"a":330},{"p":[1864,472],"f":1,"a":285},{"p":[1784,467],"f":1,"a":270},{"p":[1690,466],"f":1,"a":270},{"p":[1590,479],"f":1,"a":240},{"p":[1526,547],"f":1,"a":210},{"p":[1515,647],"f":1,"a":180},{"p":[1466,536],"f":1,"a":150},{"p":[1404,472],"f":1,"a":120},{"p":[1334,468],"f":1,"a":90},{"p":[1243,469],"f":1,"a":90},{"p":[1145,470],"f":1,"a":75},{"p":[1066,514],"f":1,"a":45},{"p":[1038,607],"f":1,"a":0},{"p":[982,515],"f":1,"a":330},{"p":[911,460],"f":1,"a":300},{"p":[841,460],"f":1,"a":270},{"p":[749,460],"f":1,"a":270},{"p":[646,465],"f":1,"a":240},{"p":[579,523],"f":1,"a":210},{"p":[564,622],"f":1,"a":180},{"p":[472,713],"f":2,"a":0},{"p":[563,979],"f":1,"a":180},{"p":[797,716],"f":1,"a":180},{"p":[1276,722],"f":1,"a":180},{"p":[1757,723],"f":1,"a":180},{"p":[1996,1541],"f":1,"a":180},{"p":[1994,1292],"f":1,"a":180},{"p":[1752,1292],"f":1,"a":180},{"p":[1514,1290],"f":1,"a":180},{"p":[1275,1292],"f":1,"a":180},{"p":[1516,1541],"f":1,"a":180},{"p":[1035,1534],"f":1,"a":180},{"p":[556,1533],"f":1,"a":180},{"p":[558,1291],"f":1,"a":180},{"p":[1753,1004],"f":1,"a":180},{"p":[1517,1004],"f":1,"a":180},{"p":[1275,1006],"f":1,"a":180},{"p":[1031,1007],"f":1,"a":180},{"p":[790,1008],"f":1,"a":180},{"p":[796,1296],"f":1,"a":180},{"p":[1037,1297],"f":1,"a":180}],"decals":[{"p":[1056,1320],"f":3,"a":270},{"p":[1056,1032],"f":3,"a":270},{"p":[1056,744],"f":3,"a":270},{"p":[1104,528],"f":4,"a":0},{"p":[1320,528],"f":4,"a":90},{"p":[1296,744],"f":3,"a":270},{"p":[1296,1032],"f":3,"a":270},{"p":[1296,1320],"f":3,"a":270},{"p":[1344,1608],"f":4,"a":270},{"p":[1560,1608],"f":4,"a":180},{"p":[1080,1602],"f":4,"a":180},{"p":[864,1602],"f":4,"a":270},{"p":[816,1314],"f":3,"a":270},{"p":[816,1026],"f":3,"a":270},{"p":[816,738],"f":3,"a":270},{"p":[840,522],"f":4,"a":90},{"p":[624,522],"f":4,"a":0},{"p":[576,738],"f":3,"a":270},{"p":[576,1026],"f":3,"a":270},{"p":[576,1314],"f":3,"a":270},{"p":[600,1602],"f":4,"a":180},{"p":[384,1602],"f":4,"a":270},{"p":[336,1314],"f":3,"a":270},{"p":[384,1098],"f":4,"a":0},{"p":[600,1074],"f":5,"a":0},{"p":[840,1074],"f":5,"a":0},{"p":[1080,1074],"f":5,"a":0},{"p":[1320,1074],"f":5,"a":0},{"p":[1560,1074],"f":5,"a":0},{"p":[1536,1320],"f":3,"a":270},{"p":[1584,1266],"f":6,"a":0},{"p":[1536,786],"f":3,"a":270},{"p":[1584,696],"f":6,"a":0},{"p":[1584,528],"f":4,"a":0},{"p":[1800,528],"f":4,"a":90},{"p":[1776,744],"f":3,"a":270},{"p":[1776,1032],"f":3,"a":270},{"p":[1776,1320],"f":3,"a":270},{"p":[1824,1608],"f":4,"a":270},{"p":[2040,1608],"f":4,"a":180},{"p":[1800,1074],"f":5,"a":0},{"p":[2040,1098],"f":4,"a":90},{"p":[2016,1314],"f":3,"a":270},{"p":[2064,1470],"f":6,"a":0},{"p":[1518,1104],"f":7,"a":270},{"p":[1518,1182],"f":7,"a":270},{"p":[1500,1128],"f":8,"a":270},{"p":[1410,1212],"f":8,"a":270},{"p":[1308,1128],"f":8,"a":270},{"p":[1200,1212],"f":8,"a":270},{"p":[1074,1134],"f":8,"a":270},{"p":[948,1212],"f":8,"a":270}],"laps":3,"ai_waypoints":[{"p":[1890,1142],"n":1},{"p":[2093,1284],"n":2},{"p":[2187,1497],"n":3},{"p":[2034,1658],"n":4},{"p":[1848,1512],"n":5},{"p":[1901,1199],"n":6},{"p":[1958,779],"n":7},{"p":[1801,653],"n":8},{"p":[1620,805],"n":9},{"p":[1662,1189],"n":10},{"p":[1715,1517],"n":11},{"p":[1554,1653],"n":12},{"p":[1361,1505],"n":13},{"p":[1413,1173],"n":14},{"p":[1480,783],"n":15},{"p":[1320,657],"n":16},{"p":[1128,798],"n":17},{"p":[1179,1173],"n":18},{"p":[1234,1521],"n":19},{"p":[1073,1642],"n":20},{"p":[886,1516],"n":21},{"p":[931,1171],"n":22},{"p":[994,798],"n":23},{"p":[829,644],"n":24},{"p":[640,802],"n":25},{"p":[700,1186],"n":26},{"p":[743,1504],"n":27},{"p":[590,1650],"n":28},{"p":[400,1506],"n":29},{"p":[529,1233],"n":30},{"p":[985,1166],"n":31}],"checkpoints":[{"p":[1560,1063],"n":1},{"p":[2019,1073],"n":2},{"p":[1893,1588],"n":3},{"p":[1645,490],"n":4},{"p":[1429,1573],"n":5},{"p":[1175,485],"n":6},{"p":[926,1575],"n":7},{"p":[698,497],"n":8},{"p":[445,1570],"n":9},{"p":[335,1068],"n":10}],"start_positions":[{"p":[1452,1122],"n":1,"a":90},{"p":[1362,1206],"n":2,"a":90},{"p":[1260,1122],"n":3,"a":90},{"p":[1152,1206],"n":4,"a":90},{"p":[1032,1128],"n":5,"a":90},{"p":[894,1206],"n":6,"a":90}],"dict":{"1":"3tires.png","2":"9tires.png","3":"ilgas.png","4":"lenktas.png","5":"kryzius.png","6":"trumpas.png","7":"startbar.png","8":"white_bar.png"}}};
},{}],24:[function(require,module,exports){
var gamejs = require('gamejs');
var combatracer=require('./combatracer');
var settings=require('./settings');
var skin=require('./skin');
var levels=require('./levels');
var engine=require('./engine');

gamejs.display.setCaption("Bandit Racer");
var img;

function main(){
   var canvas = document.createElement('canvas');
   canvas.width = img.naturalWidth || img.width;
   canvas.height = img.naturalHeight || img.height;
   var context = canvas.getContext('2d');
   context.drawImage(img, 0, 0);
   img.getSize = function() { return [img.naturalWidth, img.naturalHeight]; };
   var loading_img = new gamejs.Surface(img.getSize());
   loading_img._canvas = canvas;
   
   var progfn;
   var canvas=null;
   var display=null;
   //var font=new gamejs.font.Font(skin.fonts.loading[0]);
   var loading_img_size=loading_img.getSize();
   
   function loadTick(){
      var display_size=display.getSize()
      gamejs.draw.rect(display, '#FFF', new gamejs.Rect([0, 0], display_size));
      var loading_pt=[display_size[0]/2-loading_img_size[0]/2, display_size[1]/2-loading_img_size[1]/2-100];
      display.blit(loading_img, loading_pt);
      if(progfn){
         var progress=progfn();
         progress=Math.min(Math.max(progress-0.5, 0)*2, 1);
         gamejs.draw.rect(display, 'black', new gamejs.Rect([loading_pt[0]-100, loading_pt[1]+260], [loading_img_size[0]+200, 40]), 2);
         gamejs.draw.rect(display, 'black', new gamejs.Rect([loading_pt[0]-100, loading_pt[1]+260], [(loading_img_size[0]+200)*progress, 40]), 0);
      }
   };
   
   settings.init();
   display=gamejs.display.setMode([settings.get('SCREEN_WIDTH'), settings.get('SCREEN_HEIGHT')]);
   gamejs.onTick(loadTick, this);
   gamejs.preload(combatracer.get_preload_list());
   levels.init();
   progfn = gamejs.ready(function(){   
      var game=new combatracer.init();
      game.start(display);
   });
};

//load logo first
var loadlogo=exports.loadlogo=function(){
   img = new Image();
   img.addEventListener('load', main, true);
   img.src =(window.$g && $g.resourceBaseHref || '.')+'/images/ui/logo.png';
}
//load logo
loadlogo();
},{"./combatracer":6,"./engine":9,"./levels":22,"./settings":28,"./skin":29,"gamejs":37}],25:[function(require,module,exports){
var gamejs=require('gamejs');
var utils=require('./utils');
var vec=utils.vec;
var arr=utils.arr;
var vectors = gamejs.utils.vectors;
var math = gamejs.utils.math;
var engine = require('./engine');

exports.rotarrays={};

var BoxProp = exports.BoxProp = function(parameters){
    /*
     pars:
     filename
     size
     world
     position
     angle
    */
    
    var par_list = ['filename'];
    
    engine.utils.process_parameters(parameters, par_list);
    
    this.filename = parameters.filename;
    
    parameters.fixed_rotation = true;
    parameters.body_type = engine.box2d.b2Body.b2_staticBody;
    BoxProp.superConstructor.apply(this, [parameters]);
    this.add_tag('prop');
};

gamejs.utils.objects.extend(BoxProp, engine.Entity);

engine.register_class(BoxProp);

},{"./engine":9,"./utils":33,"gamejs":37}],26:[function(require,module,exports){
var gamejs = require('gamejs');
var utils=require('./utils');
var vec=utils.vec;
var arr=utils.arr;

var vectors = gamejs.utils.vectors;
var math = gamejs.utils.math;
radians=math.radians;
degrees=math.degrees;

var resources=require('./resources');
var skin=require('./skin');
var settings=require('./settings');
var weapon_descriptions=require('./weapon_descriptions');

//hax gamejs to render font properly with a very hax fix
gamejs.font.Font.prototype.size=function(text){
    var metrics = this.sampleSurface.context.measureText(text);
    return [metrics.width*4, this.fontHeight];    
};

gamejs.font.Font.prototype.render = function(text, color) {
    var dims = this.size(text);
    var surface = new gamejs.Surface(dims);
    var ctx = surface.context;
    ctx.save();
    ctx.font = this.sampleSurface.context.font;
    ctx.textBaseline = this.sampleSurface.context.textBaseline;
    ctx.textAlign = this.sampleSurface.context.textAlign;
    ctx.fillStyle = ctx.strokeStyle = color || "#000000";
    ctx.fillText(text, dims[0]/2, surface.rect.height, surface.rect.width);
    ctx.restore();
    
    //scans the surface left to right and right to left to find where hte letter begins and then trims it.

    
    var s=0, e=dims[0], i;
    var arr=new gamejs.surfacearray.SurfaceArray(surface);
    
    //left to right
    var found=false;
    for(s=0;s<arr.getSize()[0];s++){
        for(i=0;i<arr.getSize()[1];i++){
            if(arr.get(s, i)[3]!=0){
                found=true;
                break;
            }
        }
        if(found)break;
    }
    
    //right to left
    found=false;
    for(e=arr.getSize()[0]-1;e>=0;e--){
        for(i=0;i<arr.getSize()[1];i++){
            if(arr.get(e, i)[3]!=0){
                found=true;
                break;
            }
        }
        if(found) break;
    }
    var h=Math.floor(dims[1]);
    var newsurface=new gamejs.Surface([e-s, h]);
    newsurface.blit(surface, new gamejs.Rect([0, 0], newsurface.getSize()),
                             new gamejs.Rect([s, 0], [e-s, h]));
    return newsurface;
    
    
};

var sprite2rotarray=exports.sprite2rotarray=function(surface, step){
    var retv={'orig':surface,
              0:surface,
              'step':step};
    var orig_size=surface.getSize();
    var timg;
    if(orig_size[0]!=orig_size[1]){
        var s=Math.max(orig_size[0], orig_size[1]);
        timg=new gamejs.Surface(s, s)
        timg.blit(surface, [(s-orig_size[0])/2, (s-orig_size[1])/2]);
        retv[0]=timg;
    }else{
        timg=surface;
        retv[0]=surface;
    }
    for(var angle=step;angle<360;angle+=step){
        retv[angle]=gamejs.transform.rotate(timg, angle);
    }
    return retv;
};


var ImageCache = exports.ImageCache = function() {
    this.cars = {};
    this.props = {};
    this.decals = {};
    this.tiles = {};
    this.animations = {};
    this.fonts = {};
    this.ui = {};
    this.alphabet = 'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ1234567890.,:\/!?"|()';
    this['static'] = {};

    //load tiles
    resources.tiles.forEach(function(f) {
        this.tiles[f] = gamejs.image.load('images/tiles/' + f);
    }, this);
    //load cars
    //resources.cars.forEach(function(f){
    //    this.cars[f]=sprite2rotarray(gamejs.image.load('images/cars/'+f), 2);
    //}, this);

    //cache props
    resources.props.forEach(function(f) {
        this.props[f] = sprite2rotarray(gamejs.image.load('images/props/' + f), 5);
    }, this);
    //cache decals
    resources.decals.forEach(function(f) {
        this.decals[f] = sprite2rotarray(gamejs.image.load('images/decals/' + f), 90);
    }, this);
    //cache animations
    resources.animations.forEach(function(f) {
        this.animations[f] = gamejs.image.load('images/animations/' + f);
    }, this);
    //cache ui
    resources.ui.forEach(function(f) {
        this.ui[f] = gamejs.image.load('images/ui/' + f);
    }, this);
    //cache static
    resources['statics'].forEach(function(f) {
        this['static'][f] = gamejs.image.load('images/static/' + f);
    }, this);
    /*    //cache fonts
     var font='hud', letter;

     this.fonts[font]={};
     resources.fonts[font].forEach(function(f){
     letter=f.split('.')[0];
     this.fonts[font][letter]=gamejs.image.load('images/fonts/'+font+'/'+f);
     }, this);      */

    this.initFont = function(name, fontSettings, color) {
        this.fonts[name] = {};
        var font = new gamejs.font.Font(fontSettings);

        var c;
        for(var i = 0; i < this.alphabet.length; i++) {
            c = this.alphabet[i];
            this.fonts[name][c] = font.render(c, color);
        }
    };

    this.getDecalSprite = function(filename, angle) {
        return this.getSpriteFromRotarray(this.decals[filename], angle);
    };

    this.getPropSprite = function(filename, angle) {
        return this.getSpriteFromRotarray(this.props[filename], angle);
    };

    this.cacheCarSprite = function(filename) {
        if(!this.cars[filename]) {
            this.cars[filename] = sprite2rotarray(gamejs.image.load('images/cars/' + filename), 2);
        }
    };

    this.getCarSprite = function(filename, angle) {
        if(!this.cars[filename]) {
            this.cacheCarSprite(filename);
        }
        return this.getSpriteFromRotarray(this.cars[filename], angle);
    };

    this.getTile = function(filename) {
        return this.tiles[filename];
    };

    this.getLetter = function(font, letter) {
        return this.fonts[font][letter];
    };

    this.getTextSize = function(text, font) {
        var w = 0, h = 0, c, l, sz;
        if(text) {
            for(var i = 0; i < text.length; i++) {
                c = text[i];
                if(c == ' ')
                    w += 8;
                else {
                    l = this.getLetter(font, c);
                    if(l) {
                        sz = l.getSize();
                        w += sz[0];
                        h = sz[1];
                    }
                }
            }
            return [w, h];
        } else
            return [0, 0];
    };

    this.getAnimationFrameCount = function(filename) {
        var sz = this.animations[filename].getSize();
        return sz[0] / sz[1];
    };

    this.getAnimationSheet = function(filename) {
        return this.animations[filename];
    };

    this.getUIImage = function(filename) {
        return this.ui[filename];
    };
    this.getStaticSprite = function(filename) {
        return this['static'][filename];
    };

    this.getSpriteFromRotarray = function(rotarray, angle) {
        angle = math.normaliseDegrees(angle);
        if((angle % rotarray['step']) != 0)
            angle = parseInt(angle / rotarray['step']) * rotarray['step'];
        return rotarray[angle];
    };
    //init fonts
    this.initFont('hud', skin.fonts['hud'][0], skin.fonts['hud'][1]);

    return this;
};



exports.cache=null;

exports.init=function(){
    exports.cache=new ImageCache();
    return exports.cache;
};


var Renderer=exports.Renderer=function(width, height, cache){ 
    this.width=width;
    this.height=height;
    this.cache=cache;
    this.surface=null;
    
    this.textLength=function(text, font){
        var c;
        var len=0;
        for(var i=0;i<text.length;i++){
            c=text[i];
            if(c==' '){
                len+=8;
            }else{
                s=this.cache.getLetter(font, c);
                len+=s.getSize()[0];
            }
        }
        return len;
    };
    
    this.fillBackground=function(color){
        gamejs.draw.rect(this.surface, color, new gamejs.Rect([0, 0], this.surface.getSize()));
    };
    
    this.drawRect=function(color, pos, size, w){
        w = (w || w===0) ? w : 1;
        gamejs.draw.rect(this.surface, color, new gamejs.Rect(pos, size), w);
    };
    
    this.drawLine=function(color, pos1, pos2, w){
        w = (w || w===0) ? w : 1;
        gamejs.draw.line(this.surface, color, pos1, pos2, w);
    }
    
    this.drawText=function(text, font, position, zoom, draw_on){
        /*
        font - font name
        position - position in SCREEN COORDINATES !!
        */
        ofst=position[0];
        zoom = zoom  ? zoom: 1;
        var i, c, s;
        for(i=0;i<text.length;i++){
            c=text[i];
            if(c==' ')ofst+=8/zoom;
            else{
                s=this.cache.getLetter(font, c);
                if(zoom==1){
                    r1=[ofst, position[1]-10];
                }
                else{
                    size=s.getSize();
                    r1=new gamejs.Rect([ofst, position[1]], [parseInt(size[0]/zoom), parseInt(size[1]/zoom)]);
                
                }
                (draw_on ? draw_on: this.surface).blit(s, r1);
                ofst+=s.getSize()[0]/zoom;
            }
        }        
    };
    return this;  
};

var UIRenderer=exports.UIRenderer=function(width, height, cache){
    UIRenderer.superConstructor.apply(this, [width, height, cache]);
    this.cache=cache;
    this.surface=null;
    
    this.setSurface=function(surface){
        this.surface=surface;
    };
    
    this.drawUIImage=function(filename, pos){
        this.surface.blit(this.cache.getUIImage(filename), pos);
    };
    
};

gamejs.utils.objects.extend(UIRenderer, Renderer);

var RaceRenderer = exports.RaceRenderer = function(width, height, world, background, cache, follow_object){
    RaceRenderer.superConstructor.apply(this, [width, height, cache]);
    this.display_width=width;
    this.display_height=height;
    this.world = world;
    this.size=[this.width, this.height];
    this.follow_object=follow_object;
    this.offset_x = 0;
    this.offset_y = 0;
    this.background=background;
    this.surface=null;
    this.st=new gamejs.Surface(this.display_width*2, this.display_height*2);
    this.display=null;
    this.zoom=1;
    this.r1=new gamejs.Rect([0, 0], [this.display_width, this.display_height]);
    this.r2=new gamejs.Rect([0, 0], [this.width, this.height]);
    this.phys_scale = settings.get('PHYS_SCALE');
    
    this.follow=function(obj){
        this.follow_object=obj;
    };
    
    //update camera offset
    this.updateOffset=function(){
        if(this.follow_object){
            var pos = this.follow_object.alive ? this.follow_object.get_position() : this.follow_object.respawn_location;
            this.offset_x=Math.min(Math.max(0, pos[0] * this.phys_scale-parseInt(this.width/2)), world.width * this.phys_scale - this.width);
            this.offset_y=Math.min(Math.max(0, pos[1] * this.phys_scale-parseInt(this.height/2)), world.height * this.phys_scale - this.height);
        }
        return false;
    };
       
    //world point 2 screen point
    this.getScreenPoint=function(world_point){
        return [world_point[0] * this.phys_scale - this.offset_x,
                world_point[1] * this.phys_scale - this.offset_y];
    };
    
    this.drawBackground=function(){
      //  this.blit(this.background, [0, 0], new gamejs.Rect(-this.offset_x, -this.offset_y, this.width, this.height));
      this.surface.blit(this.background, new gamejs.Rect([0, 0], [this.width, this.height]), new gamejs.Rect([this.offset_x, this.offset_y], [this.width, this.height]));
    };
    
    //zoom
    this.setZoom=function(zoom){
        var new_width=parseInt(this.display_width/zoom);
        var new_height=parseInt(this.display_height/zoom);
        if((new_width<=this.world.width_px) && (new_height<=this.world.height_px)){
            this.zoom=zoom;
            this.width=parseInt(this.display_width/zoom);
            this.height=parseInt(this.display_height/zoom);
            this.r2=new gamejs.Rect([0, 0], [this.width, this.height]);
            this.st=new gamejs.Surface(this.width, this.height);
        }
        
    };
    
    this.increaseZoom=function(){
        if(this.zoom<1)this.setZoom(this.zoom+0.01);
    };
    
    this.decreaseZoom=function(){
        if(this.zoom>0.5)this.setZoom(this.zoom-0.01);
    };
    
    //render
    this.render=function(display){
        if(this.zoom==1)this.surface=display;
        else this.surface=this.st;
        this.updateOffset();
        this.drawBackground();
        this.world.draw(this);
        if(this.zoom!=1){
            display.blit(this.surface, this.r1, this.r2);
        }
    };
    
    //DRAW FUNCTIONS
    
    this.drawLine=function(color, pt1, pt2, width){
        /*
         pt1, pt2 - points in world coordinates
         width - width in pixels
        */
        gamejs.draw.line(this.surface, color, this.getScreenPoint(pt1),
                                               this.getScreenPoint(pt2), 2);
    };
    
    this.drawProp=function(filename, pos, angle){
        /*
        pos - position in world coordinates
        angle - angle, degrees
        */
        var sprite=this.cache.getPropSprite(filename, angle ? angle : 0);
        var ofst=sprite.getSize()[0]/2;
        pos=this.getScreenPoint(pos);
        this.surface.blit(sprite, [pos[0]-ofst, pos[1]-ofst]);  
    };
    
    this.drawDecal=function(filename, pos, angle){
        /*
        pos - position in world coordinates
        angle - angle, degrees
        */
        var sprite=this.cache.getDecalSprite(filename, angle ? angle : 0)
        var ofst=sprite.getSize()[0]/2;
        pos=this.getScreenPoint(pos);
        this.surface.blit(sprite, [pos[0]-ofst, pos[1]-ofst]);  
    };
    
    this.drawCar=function(filename, pos, angle){
        /*
        pos - position in world coordinates
        angle - angle, degrees
        */
        var sprite=this.cache.getCarSprite(filename, angle ? angle : 0);
        var ofst=sprite.getSize()[0]/2;
        pos=this.getScreenPoint(pos);
        this.surface.blit(sprite, [pos[0]-ofst, pos[1]-ofst]);

    };
    
    this.drawStatic=function(filename, pos){
        var sprite=this.cache.getStaticSprite(filename);
        var sz=sprite.getSize();
        pos=this.getScreenPoint(pos);
        this.surface.blit(sprite, [pos[0]-sz[0]/2, pos[1]-sz[1]/2]);
    };
    
    this.drawAnimation=function(filename, pos, frame, sz){
        /*
        pos - position in world coordinates
        frame - frame number (starts with 0 ) 
        */
        var sheet=this.cache.getAnimationSheet(filename);
        var h=sheet.getSize()[1];
        sz=sz ? sz : h;
        pos=this.getScreenPoint(pos);
        this.surface.blit(sheet, new gamejs.Rect([pos[0]-sz/2, pos[1]-sz/2], [sz, sz]), new gamejs.Rect([frame*h, 0], [h, h]));
    };
    
    this.renderHUD=function(display,  pars){
        /*
         pars:
         car - car to render hud for
         max_laps - max laps of the track
         time_to_start - time till game start
         paused - is game paused?
         delta - perceived difference between server and client time
         bfs - bad frames. number of frames where nearest further state was unknown and had to simulate world to make up for it
         message - a message to display onscreen
        */

        this.surface=display;
        this.drawText('FPS: ' + parseInt(1000/pars.msDuration), 'hud', [10, 10]);
        var size = display.getSize();
        
        var car = pars.car;

        if(car) {
            this.drawText('POS: ' + car.get_race_position() + '/' + this.world.get_objects_by_tag('car').length, 'hud', [size[0] / 2 - 140, 10]);
            //lap
            this.drawText('LAP: ' + car.lap + '/' + pars.max_laps, 'hud', [size[0] / 2 + 20, 10]);
            //speed
            this.drawText('SPEED: ' + parseInt(car.get_speed_KMH()), 'hud', [10, display.getSize()[1] - 40]);
            //ammo

            var x = 250;
            var y = display.getSize()[1] - 40;
            (['front_weapon', 'util', 'rear_weapon']).forEach(function(weapon_type) {
                if(car[weapon_type]) {
                    var descr = weapon_descriptions[car[weapon_type].type];
                    var icon = this.cache.getStaticSprite(descr.icon);
                    this.surface.blit(icon, [x, y - 15]);
                    x += 50;
                    this.drawText(String(parseInt(car[weapon_type].ammo)), 'hud', [x, y]);
                    x += 60;
                }
            }, this);
        }

        
        if(settings.get('DEBUG')){
            if(pars.delta){
                 this.drawText('D: ' + Math.abs(pars.delta), 'hud', [10, 80]);          
            }
            if(pars.bfs){
                this.drawText('BFS: ' +pars.bfs, 'hud', [10, 140]);
            }
        }
        if(pars.paused){
            this.drawText('PAUSED', 'hud', [size[0]/2-100, size[1]/2], 0.75);
        }else if(pars.message){
            this.drawText(pars.message, 'hud', [size[0]/2-100, size[1]/2], 0.75);
        }else{
            var tts=pars.time_to_start;
            if(tts){
                if(tts>3000){
                    this.drawText('WAITING FOR OTHERS', 'hud', [size[0]/2-150, size[1]/2]);
                }
                else if(tts>2000){
                  this.drawText('GET READY 3...', 'hud', [size[0]/2-150, size[1]/2], 0.75);
                }else if(tts>1000){
                  this.drawText('GET READY 2...', 'hud', [size[0]/2-150, size[1]/2], 0.75);
                }else if(tts>0){
                  this.drawText('GET READY 1...', 'hud', [size[0]/2-150, size[1]/2], 0.75);
                }else if(tts> -1000){
                  this.drawText('GO!!!', 'hud', [size[0]/2-150, size[1]/2], 0.75);
                }
            }
        }   
    };  
    
    return this;
};
gamejs.utils.objects.extend(RaceRenderer, Renderer);

},{"./resources":27,"./settings":28,"./skin":29,"./utils":33,"./weapon_descriptions":34,"gamejs":37}],27:[function(require,module,exports){
exports.props=['9tires.png','3tires.png', 'tire.png'];
exports.cars=['bandit_blue.png','bandit_green.png','bandit_red.png','bandit_yellow.png',
              'big_wheel.png', 'cannon_shell.png',
              'brawler_blue.png','brawler_green.png','brawler_red.png','brawler_yellow.png','bullet.png','missile.png',
              'racer_blue.png','racer_green.png','racer_red.png','racer_yellow.png','wheel.png',
              'sandbug_blue.png','sandbug_green.png','sandbug_red.png','sandbug_yellow.png', 'missile_homing.png',
              'samaritan_blue.png','samaritan_green.png','samaritan_red.png','samaritan_yellow.png', 
              'plasma_projectile.png',
              'thunderbolt_blue.png', 'thunderbolt_green.png', 'thunderbolt_yellow.png', 'thunderbolt_red.png'];
exports.tiles=['sand.png','grass.png', 'snow.png'];
exports.animations=['explosion.png','explosion_small.png', 'sw.png', 'smoke.png', 'heal.png', 'fire64.png',
					'forcefield.png', 'explosion2.png'];
exports.ui=['controls.png','garage.png','guncar.png','logo.png','key_bg.png'];
exports.statics=['mine.png', 'samaritan_big.png', 'brawler_big.png', 'racer_big.png', 'bandit_big.png', 'icon_machinegun.png', 'icon_mine.png', 'icon_missiles.png', 'ico_damage.png', 'ico_ammo.png',
                 '0stars.png', '1stars.png', '2stars.png', '3stars.png', '4stars.png', '5stars.png', 'sandbug_big.png', 'icon_fix.png', 'icon_sw.png', 'icon_missiles_homing.png',
                 'ico_nos.png', 'ico_oil.png', 'oil_spill.png', 'icon_plasma.png', 'icon_flame.png',
                 'icon_shield.png', 'icon_cannon.png', 'thunderbolt_big.png'];
exports.levels=['snowpeakcircuit', 'drycircuit', 'deathvalley', 'spiralraceway', 'greenring', 
			   'frogfoot', '2_icemanloops', '2_vultureplains', '2_queersands', '1_bloodbathlane',
			   '3_bullpen', '3_hunter_end', '3_lullabycircuit', '3_peril_flats', '3_radiator'];
exports.decals=[,'dideliskampas.png','ilgas.png','trumpas.png','issisakojimas.png','kryzius.png','lenktas.png',
                'paprastas.png','siauras.png','siaurasiplatu.png','siaurejantis1.png','siaurejantis2.png','sonaslenktas1.png',
                'sonaslenktas2.png','startbar.png','susikerta.png','uglyduckling.png', 'white_bar.png',
                'arrow2.png', 'arrow3.png', 'arrow4.png', 'arrow5.png', 'arrow.png'];
exports.sound_fx=['bullet_impact_metal.wav','bullet_impact_soft.wav','button_click.wav','explosion.wav','machinegun_shot.wav','missile_launch.wav','thud.wav', 'shockwave.wav', 'repair.wav',
                    'plasma_cannon.wav', 'fire_cannon.wav'];
//exports.sound_engine=['loop_0.wav', 'loop_1.wav', 'loop_2.wav','loop_3.wav','loop_4.wav','loop_5.wav' ];
},{}],28:[function(require,module,exports){
var settings=exports.settings={SCREEN_WIDTH:800,  //screen width in pixels
                                SCREEN_HEIGHT:600, //screen height in pixels
                                FPS:60,        //logic updates per second
                                PHYS_SCALE:10,    //pixels in a meter
                                STARTING_BALANCE:3000, //default 3000
                                STARTING_LEAGUE:0,
                                SERVER:'ws://localhost:8001',
                                DEBUG:false,
                                SOUND:false,
                                ENGINE_SOUND:false};     //game server

exports.get=function(name){
    return settings[name];
};

exports.init=function(){
    for(var key in settings){
        if(window.hasOwnProperty(key)){
            settings[key]=window[key];
        }
    }
};

exports.set=function(name, value){
    settings[name]=value;
};

},{}],29:[function(require,module,exports){
exports.ui_header_background='#FFF';
exports.ui_background='#E6E6E6';

exports.alias_background='#333333';

exports.alert_box_border='black';
exports.alert_box_background='#E6E6E6';

//fonts name:[css description, color]
/*
exports.fonts={'hud':['30px "Showcard Gothic"', 'red'],         //in game hud
               'header':['40px Aharoni', '#351A15'],            //ui scene headers
               'default':['20px Aharoni', '#351A15'],           //labels, default if not specified
               'small_header':['bold 16px Arial', 'black'],     //table headers
               'small':['bold 14px Arial', 'black'],             //table cells
               'alias':['bold 14px Arial', '#4CFF00'],  //ingame multiplayer player alias
               'button':['20px Aharoni', '#351A15'],
               'loading':['40px Stencil', '#351A15']
               };
*/

exports.fonts={'hud':['30px maass', 'red'],         //in game hud
               'header':['40px maass', '#351A15'],            //ui scene headers
               'default':['20px maass', '#351A15'],           //labels, default if not specified
               'small_header':['16px maass', 'white'],     //table headers
               'small':['14px maass', 'black'],             //table cells
               'alias':['23px maass', '#333333'],  //ingame multiplayer player alias
               '16_33':['16px maass', '#333333'],
               '13_1a':['13px maass', '#1A1A1A'],
               '13_green':['13px maass', '#00BC12'],
               'alias_label':['40px maass', '#FFFFFF'],
               'button':['25px maass', '#000'],
               'button2':['30px maass', '#333333'],
               'button2_hover':['30px maass', '#F2F2F2'],
               'loading':['40px maass', '#351A15'],
               '40_black':['40px maass', '#000'],
               '13_grayish':['13px maass', '#383736'],
               '25_66':['25px maass', '#666666'],
               'sp_btn':['30px maass', '#FFF'],
               'header_black':['56px maass', '#333333'],
               'header_brown':['56px maass', '#A67C52'],
               'editor_ai_wp':['19px maass', '#0094FF'],
               'editor_checkpoint':['19px maass', '#FF5656'],
               'editor_start_pos':['19px maass', '#3AFF51'],
               'g_white_title':['16px maass', '#F2F2F2']
               };


exports.single_player_scene={'background_color':'#C7B299'};

exports.dialog={'font':'default'};

exports.sp_car_display={'bg_color':'#998675',
                        'font1':'13_grayish',
                        'font2':'sp_btn'};

exports.garage_btn={'bg_color':'#CCCCCC',
                    'bg_color_hover':'#B3B3B3',
                    'label_bg':'#E6E6E6',
                    'font':'alias'};
                    
exports.track_selector={'back_color':'#E6E6E6',
                        'front_color':'#CCCCCC',
                        'item_hover_color':'#D8D8D8',
                        'item_font':'16_33'};

exports.title_button={'fill':'#CCCCCC',
                      'fill_hover':'#B3B3B3',
                      'font':'40_black'};

exports.sp_button={'fill':'#333333',
                    'fill_hover':'#000',
                    'font':'sp_btn'};
                      
exports.button={'border':'#282828',              //button border
                'font':'button',                 //default font
                'fill':'#CCCCCC',                 //default fill
                'hover_fill':'#B3B3B3',          //fill on hover
                'selected_fill':'#FF6A00'};       //fill when selected
                
exports.garage={'background_color':'#666666',
                'back_button':{'fill':'#E6E6E6',
                                'hover_fill':'#000',
                                'font':'button2',
                                'hover_font':'button2_hover'},
                'balance_background':'#E6E6E6',
                'car_title_background':'#333333',
                'car_background':'#CCCCCC',
                'car_title_font':'g_white_title',
                'balance_font':'alias',
                'weapon_info_title_background':'#F5F5F5',
                'weapon_info_background':'#B3B3B3',
                'weapon_label_font':'16_33',
                'weapon_info_text_font':'13_1a',
                'tuning_title_background':'#4D4D4D',
                'tuning_background':'#1A1A1A',
                'store_background':'#F2F2F2',
                'store_border':'#CCCCCC',
                'selected_shop_item_bg':'#B3B3B3',
                'slot_border':'rgba(204, 204, 204, 0.5)',
                'slot_bg':'rgba(204, 204, 204, 0.8)',
                'slot_bg_selected':'#777777',
                'slot_path':'#CCCCCC',
                'white_button':{'bg':'#F2F2F2',
                                'bg_hover':'#1A1A1A',
                                'font':'16_33',
                                'hover_font':'g_white_title'}};
                

exports.trackdisplay={'font':'16_33'};

//label
exports.label={'font':'default'};

//textbox
exports.textbox={'font':'default',
                 'border':'#282828',
                 'background':'#FFEFAA'};


//table
exports.table={'header_font':'small_header',
                'data_font':'small',
                'border':'#C6A500',
                'header_fill':'#333333',         //header row background
                'hover_fill':'#FFBE00',          //fill on row hover
                'body_fill':'#CCCCCC',
                'selected_fill':'#FF6A00'};           //my english fails me. its the line between rows

//track info display
exports.trackinfodisplay={'header_font':'default',
                          'outline_color':'#808080'};

},{}],30:[function(require,module,exports){
var gamejs = require('gamejs');
var resources = require('./resources');
var settings = require('./settings');
var engine = require('./engine');
var _sounds = {};
var _playing = 0;

function Engine() {
    this.audios={}
    this.playing=null;
    var s;

    this.play=function(pitch){
        if(this.playing!=pitch){
            for(var p=0;p<=5;p++){
                if(p!=pitch){
                    this.audios[p].stop();
                }else{       
                    this.audios[p].play();
                    this.playing=this.audios[p];
                }
            }    
        }
    };
    
    this.play_by_speed=function(speed, max_speed){
        if(speed < 5){
            this.play(0) //idle
        }
        else{
            this.play(Math.min(parseInt(Math.ceil((speed*10)/(max_speed*2))), 5));   
        }
    };
    
    this.stop=function(){
        return;
        for(var p in this.audios){
            this.audios[p].stop();
        }
        this.playing=null;
    };
    
    for(var i = 0; i <= 5; i++){
        this.audios[i] = new engine.Sound('sounds/engine/loop_'+i+'.wav', true);
    }
}
exports.play = function(pars){
    if(settings.get('sound'))engine.play_sound('sounds/fx/'+pars.filename); 
};
exports.engine = null;

exports.init = function(){
    //exports.engine = new Engine();
};


},{"./engine":9,"./resources":27,"./settings":28,"gamejs":37}],31:[function(require,module,exports){
var gamejs=require('gamejs');
var GUI=require('./gamejs-gui');
var skin=require('./skin');
var renderer=require('./renderer');
var settings=require('./settings');
var combatracer=require('./combatracer');
var car_descriptions=require('./car_descriptions');
var weapon_descriptions=require('./weapon_descriptions');
var levels=require('./levels');
var utils=require('./utils');
var sounds=require('./sounds');
var leagues=require('./leagues');

exports.fonts={};

exports.init=function(){
    for(var font in skin.fonts){
        exports.fonts[font]=new GUI.CachedFont(skin.fonts[font][0], skin.fonts[font][1]);   
    }
};

var getFont=exports.getFont=function(font){
    return exports.fonts[font];
};

//SCENE CONTAINER
var SceneContainer=function(pars){
    this.background_color=pars.background_color || skin.ui_background;
    this.header_height=pars.header_height || 110;
    SceneContainer.superConstructor.apply(this, [pars]);
};

gamejs.utils.objects.extend(SceneContainer, GUI.View);

SceneContainer.prototype.paint=function(){
    this.surface.clear();
    gamejs.draw.rect(this.surface, skin.ui_header_background, new gamejs.Rect([0, 0], [this.surface.getSize()[0], this.header_height]));
    gamejs.draw.rect(this.surface, this.background_color, new gamejs.Rect([0, this.header_height], [this.surface.getSize()[0], this.surface.getSize()[1]-this.header_height]));
};



var UIScene=exports.UIScene=function(){
    var cache=this.cache=cache=renderer.cache;
    var game=this.game=combatracer.game;
   // game.display.fill('#FFF');
    this.gui=new GUI.GUI(game.display);
    this.gui.on(GUI.EVT_PAINT,
                function(){
                    this.surface.clear();
                }, this.gui);
    this.container=new SceneContainer({'position':[0, 0],
                                        'size':[800, 600],
                                        'parent':this.gui});
    
    this.gui.center(this.container);

    //bandit racer label at the top
    this.br_title=new BRTitle({'position':[60, 11],
                              'parent':this.container});
    
    this.guncar=new GUI.Image({'position':[32, 110-44],
                              'parent':this.container,
                              'image':cache.getUIImage('guncar.png')});

    //if ping is set to true, this scene will ping the server every ms_to_ping miliseconds so as not to time out.
    this.ping=false;
    this.ms_to_ping=10000;

    this.dialog=new Dialog({'parent':this.gui,
                           'size':[600, 150]});

    this.alert=function(text, button){
        this.dialog.show(text, button);
    };
    
    this.clearAlert=function(){
        this.dialog.close();
    };
    
    this.handleEvent=function(event){
        this.gui.despatchEvent(event);  
    };

    this.returnToTitle=function(){
        this.game.showTitle();
    };
    this.handleMessageDefault=function(cmd, payload){
        if(cmd==='ERR'){
            this.alert(payload.text);
        }else if(cmd==='CRITICAL_ERR'){
            this.returnToTitle();
            this.game.title_scene.alert(payload.text);
        }else if(cmd==='HELLO' || cmd==='PONG'){

        }else{
            this.alert('Unknown server message:'+cmd);
        }

    };
    this.renderer=new renderer.UIRenderer(settings.get('SCREEN_WIDTH'), settings.get('SCREEN_HEIGHT'), this.cache);

  
    this.update=function(msDuration){
        if(this.ping){
            this.ms_to_ping-=msDuration;
            if(this.ms_to_ping<=0){
                this.game.getCommunicator().queueMessage('PING');
                this.ms_to_ping=10000;
            }
        }
        this.gui.update(msDuration);
    };
  
    this.draw=function(display){  
        this.gui.draw();
    };

  return this;
};

UIScene.prototype.handleMessage=function(cmd, payload){
    console.log('uiscene',cmd, payload);
    this.handleMessageDefault(cmd, payload);
};

var BRTitle=exports.BRTitle=function(pars){
    pars.text='Bandit Racer';
    pars.font=getFont('header_black');
    BRTitle.superConstructor.apply(this, [pars]);
};

gamejs.utils.objects.extend(BRTitle, GUI.Label);

BRTitle.prototype.paint=function(){
    var font1=getFont('header_brown');
    var font2=getFont('header_black');
    var ofst=0;
    font2.render(this.surface, 'B', [0, 0], null, -3);
    ofst+=font2.getTextSize('B')[0]-3;
    
    font1.render(this.surface, 'andit ', [ofst, 0], null, -3);
    ofst+=font1.getTextSize('andit ')[0]-3;
    
    font2.render(this.surface, 'R', [ofst, 0], null, -3);
    ofst+=font2.getTextSize('R')[0]-3;
    
    font1.render(this.surface, 'acer', [ofst, 0], null, -3);
};

var NameInput=exports.NameInput=function(pars){
    pars.size=[200, 40];
    pars.font=getFont('alias');
    pars.scw_size=[190, 40];
    NameInput.superConstructor.apply(this, [pars]);
};

gamejs.utils.objects.extend(NameInput, GUI.TextInput)

NameInput.prototype.paint=function(){
    this.surface.clear();
    gamejs.draw.polygon(this.surface, '#FFF', [[10, 0], [this.size[0], 0], [this.size[0]-10, this.size[1]], [0, this.size[1]]]);
};

var TitleButton=exports.TitleButton=function(pars){
    pars.font=pars.font || getFont(skin.title_button.font);
    TitleButton.superConstructor.apply(this, [pars]);
    this.onClick(function(){
        sounds.play({'filename':'button_click.wav'});
    });
};

gamejs.utils.objects.extend(TitleButton, GUI.Button);

TitleButton.prototype.paint=function(){
    var color = this.isHovered() ? skin.title_button.fill_hover : skin.title_button.fill;
    this.surface.clear();
    gamejs.draw.polygon(this.surface, color, [[40, 0], [this.size[0], 0], [this.size[0], this.size[1]], [0, this.size[1]]]);
};

var Button=exports.Button=function(pars){
    this.font=pars.font=pars.font || getFont(skin.button.font);
    this.hover_font=pars.hover_font;
    this.fill=pars.fill || skin.button.fill;
    this.hover_fill = pars.hover_fill || skin.button.hover_fill;
    this.lean = pars.lean || 'right';
    Button.superConstructor.apply(this, [pars]);
    this.onClick(function(){
        sounds.play({'filename':'button_click.wav'});
    });
};

gamejs.utils.objects.extend(Button, GUI.Button);

Button.prototype.paint=function(){
    if(this.label && this.isHovered() && this.hover_font){
        this.label.font=this.hover_font;
    }else{
        this.label.font=this.font;
    }
    this.label.refresh();
    var color = this.isHovered() ? this.hover_fill : this.fill;
    this.surface.clear();
    if(this.lean=='right') gamejs.draw.polygon(this.surface, color, [[10, 0], [this.size[0], 0], [this.size[0], this.size[1]], [0, this.size[1]]]);
    else if(this.lean=='both') gamejs.draw.polygon(this.surface, color, [[10, 0], [this.size[0], 0], [this.size[0]-10, this.size[1]], [0, this.size[1]]]);
    else if(this.lean=='none') gamejs.draw.rect(this.surface, color, new gamejs.Rect([0,0], this.getSize()));
    else gamejs.draw.polygon(this.surface, color, [[0, 0], [this.size[0]-10, 0], [this.size[0], this.size[1]], [0, this.size[1]]]);
};

var YesNoDialog=exports.YesNoDialog=function(pars){
    YesNoDialog.superConstructor.apply(this, [pars]);
    this.label=new GUI.Label({'position':[0, 0],
                             'parent':this,
                             'font':getFont(skin.dialog.font),
                             'text':pars.text || 'b'});
    
    this.yes= new Button({'position':[0, 0],
                         'size':[150, 50],
                         'parent':this,
                         'lean':'both',
                         'text':'Yes'});
    this.no=new Button({'position':[0, 0],
                         'size':[150, 50],
                         'parent':this,
                         'lean':'both',
                         'text':'No'});
    
    this.center(this.yes);
    this.center(this.no);
    this.center(this.label);
    this.label.move([this.label.getPosition()[0], this.label.getPosition()[1]-30]);
    this.yes.move([this.yes.position[0]-80, this.yes.position[1]+30]);
    this.no.move([this.no.position[0]+80, this.no.position[1]+30]);
    this.yes.onClick(function(){
        this.close();
    }, this);
    this.no.onClick(function(){
        this.close();
    }, this);
}
gamejs.utils.objects.extend(YesNoDialog, GUI.Dialog);

var Dialog=exports.Dialog = function(pars){
    Dialog.superConstructor.apply(this, [pars]);
    this.label=new GUI.Label({'position':[0, 0],
                             'parent':this,
                             'font':getFont(skin.dialog.font),
                             'text':'b'});
    
    this.btn= new Button({'position':[0, 0],
                         'size':[150, 50],
                         'parent':this,
                         'lean':'both',
                         'text':'Ok'});
    this.center(this.btn);
    this.btn.move([this.btn.position[0], this.btn.position[1]+30]);
    this.btn.onClick(function(){
        this.close();
    }, this);
};

gamejs.utils.objects.extend(Dialog, GUI.Dialog);

Dialog.prototype.show=function(text, button){
    if(button==undefined) button=true;
    this.label.setText(text);
    this.center(this.label);
    this.label.move([this.label.position[0], this.label.position[1]-30]);
    if(button){
        this.btn.show();
    }else this.btn.hide();
    GUI.Dialog.prototype.show.apply(this, []);
};

var GoToGarage=exports.GoToGarage=function(pars){
    pars.size=[210, 180];
    GoToGarage.superConstructor.apply(this, [pars]);

    this.img= new GUI.Image({'position':[0, 0],
                            'parent':this,
                            'image':renderer.cache.getUIImage('garage.png')});
    this.center(this.img);
    this.img.move([this.img.position[0], 7]);
    
    this.lbl=new GUI.Label({'position':[0, 0],
                          'parent':this,
                          'font':getFont(skin.garage_btn.font),
                          'text':'Garage'});
    this.center(this.lbl);
    this.lbl.move([this.lbl.position[0], this.size[1]-this.lbl.size[1]-17]);    
};

gamejs.utils.objects.extend(GoToGarage, GUI.View);

GoToGarage.prototype.paint=function(){
    this.surface.fill(skin.garage_btn.label_bg);
    gamejs.draw.rect(this.surface, this.isHovered() ? skin.garage_btn.bg_color_hover : skin.garage_btn.bg_color, new gamejs.Rect([0, 0], [this.size[0], 126]));
};

var DifficultySelect=exports.DifficultySelect=function(pars){
    DifficultySelect.superConstructor.apply(this, [pars]);
    
    this.difficulties=['Easy', 'Medium', 'Hard'];
    
    if (combatracer.game.player.singleplayer.completed) 
    	this.difficulties.push('Hell');
    
    new GUI.Label({'parent':this,
                  'position':[10, 6],
                  'font':getFont(skin.sp_car_display.font1),
                  'text':'Difficulty:'});
    
    this.difflbl=new GUI.Label({'parent':this,
                                'position':[27, 17],
                                'font':getFont(skin.sp_car_display.font2),
                                 'text':this.difficulties[combatracer.game.player.singleplayer.difficulty-1]});
    
    this.left=new IncrementButton({'parent':this,
                                   'position':[5, 28],
                                   'size':[16, 25],
                                   'direction':'left'});
    
    this.left.onClick(function(){
        combatracer.game.player.singleplayer.difficulty--;
        if(combatracer.game.player.singleplayer.difficulty==0) combatracer.game.player.singleplayer.difficulty = this.difficulties.length;
        this.difflbl.setText(this.difficulties[combatracer.game.player.singleplayer.difficulty-1]);
    }, this);
    
    this.right=new IncrementButton({'parent':this,
                                   'position':[210-20-5, 28],
                                   'size':[16, 25],
                                   'direction':'right'});
    
    this.right.onClick(function(){
        combatracer.game.player.singleplayer.difficulty++;
        if(combatracer.game.player.singleplayer.difficulty == this.difficulties.length+1) combatracer.game.player.singleplayer.difficulty=1;
        this.difflbl.setText(this.difficulties[combatracer.game.player.singleplayer.difficulty-1]);
    }, this);
    
};
gamejs.utils.objects.extend(DifficultySelect, GUI.View);

DifficultySelect.prototype.paint=function(){
    gamejs.draw.polygon(this.surface, skin.sp_car_display.bg_color,
                        [[0, 0], [this.size[0]-20, 0], [this.size[0], 20],
                         [this.size[0], this.size[1]], [0, this.size[1]]]);
};


var CarDisplay=exports.CarDisplay=function(pars){
    pars.size=[210, 65];
    CarDisplay.superConstructor.apply(this, [pars]);
    this.gameinfo=pars.gameinfo;
    
    new GUI.Label({'parent':this,
                  'position':[10, 6],
                  'font':getFont(skin.sp_car_display.font1),
                  'text':'Current Car:'});
    
    this.carlbl=new GUI.Label({'parent':this,
                              'position':[16, 17],
                              'font':getFont(skin.sp_car_display.font2),
                              'text':car_descriptions[this.gameinfo.car.type].name});
    
};
gamejs.utils.objects.extend(CarDisplay, GUI.View);

CarDisplay.prototype.paint=function(){
    gamejs.draw.polygon(this.surface, skin.sp_car_display.bg_color,
                        [[0, 0], [this.size[0], 0], [this.size[0], this.size[1]-20],
                         [this.size[0]-20, this.size[1]], [0, this.size[1]]]);
};

TrackSelectorItem=exports.TrackSelectorItem=function(pars){
    pars.size=[pars.parent.size[0], 22];
    this.track=pars.track;
    this.track_obj=levels[this.track];
    TrackSelectorItem.superConstructor.apply(this, [pars]);
    this.label=new GUI.Label({'position':[0, 0],
                             'parent':this,
                             'font':getFont(skin.track_selector.item_font),
                             'text':this.track_obj.title});
    this.center(this.label);
    this.label.move([this.size[0]-this.label.size[0]-16, this.label.position[1]]);
    this.selected=false;
    this.on(GUI.EVT_MOUSE_DOWN, this.select, this);
};

gamejs.utils.objects.extend(TrackSelectorItem, GUI.View);

TrackSelectorItem.prototype.select=function(){
    this.selected=true;
    this.refresh();
    sounds.play({'filename':'button_click.wav'});
    this.despatchEvent({'type':'track_select', 'track':this.track});
};

TrackSelectorItem.prototype.deselect=function(){
    this.selected=false;
    this.refresh();
};

TrackSelectorItem.prototype.paint=function(){
    this.surface.fill(this.selected ? skin.track_selector.front_color : this.isHovered() ? skin.track_selector.item_hover_color : skin.track_selector.back_color);
};

TrackSelector=exports.TrackSelector=function(pars){
    pars.size=[536, 320];
    TrackSelector.superConstructor.apply(this, [pars]);
    this.track=null;
    
    if(pars.tracks.length <= 7){
        this.tbg1=new GUI.View({'position':[0, 30],
                               'size':[226, 231],
                               'parent':this});
    } else {
        this.tbg1 = new GUI.ScrollableView({'position':[0, 30],
                                           'size':[206, 201],
                                           'parent':this});
        var scrollbar=new GUI.VerticalScrollbar({'parent':this,
                                                'position':[this.tbg1.getSize()[0], 35],
                                                'size':[20, this.tbg1.getSize()[1]-10]});
        this.tbg1.setVerticalScrollbar(scrollbar);
    }
                           
                           
                           
    this.tbg1.on(GUI.EVT_PAINT, function(){
        gamejs.draw.polygon(this.surface, skin.track_selector.back_color,
                        [[0, 0], [this.size[0], 0], [this.size[0], this.size[1]],
                         [20, this.size[1]], [0, this.size[1]-20]]);
    }, this.tbg1);
    
    this.tbg2=new GUI.View({'position':[226, 0],
                           'size':[310, 320],
                           'parent':this});
    this.tbg2.on(GUI.EVT_PAINT, function(){
        this.surface.fill(skin.track_selector.front_color);
    }, this.tbg2);
    
    this.trackdisplay=new TrackDisplay({'parent':this.tbg2,
                                       'position':[0, 0]});
    
    new GUI.Label({'parent':this,
                  'position':[10, 0],
                  'font':getFont('alias'),
                  'text':pars.label});
    
    pars.tracks.forEach(function(track){
        ti=new TrackSelectorItem({'parent':this.tbg1,
                                 'track':track.id,
                                 'position':[0, 0]});
        ti.on('track_select', this.select, this);
    }, this);
    
    GUI.layout.vertical(this.tbg1.children, 5);    
    
    if(this.tbg1.autoSetScrollableArea){
        this.tbg1.autoSetScrollableArea();
    }
    
};

gamejs.utils.objects.extend(TrackSelector, GUI.View);

TrackSelector.prototype.select=function(event){
    this.track=event.track;
    this.tbg1.children.forEach(function(item){
        if(item.deselect && (item.track!=this.track))item.deselect();
    }, this);
    this.trackdisplay.setTrack(this.track);
};

var TrackDisplay=exports.TrackDisplay=function(pars){
    this.track=null;
    this.img=null;
    this.lbl=null;
    pars.size=[316, 320];
    TrackDisplay.superConstructor.apply(this, [pars]);
    if(pars.track) this.setTrack(pars.track);
    this.lbl2=new GUI.Label({'parent':this,
                            'position':[0, 0],
                            'font':getFont(skin.trackdisplay.font),
                            'text':'Select a track!'});
    this.center(this.lbl2);
};

gamejs.utils.objects.extend(TrackDisplay, GUI.View);

TrackDisplay.prototype.setTrack=function(track){
    this.track=track;
    if(track){
        this.lbl2.hide();
        var st=utils.renderLevelBackground(levels[track], false);
        var sz=st.getSize();
        if(sz[0]>sz[1]){
            var q=sz[0]/280;
        }else{
            var q=sz[1]/280;
        }
        var new_sz=[parseInt(sz[0]/q), parseInt(sz[1]/q)];
        s=new gamejs.Surface(new_sz[0], new_sz[1]);
        s.blit(st, new gamejs.Rect([0, 0], new_sz), new gamejs.Rect([0, 0], st.getSize()));
        
        if(!this.img){
            this.img=new GUI.Image({'parent':this,
                                   'position':[15, 10],
                                   'image':s});
        }else{
            this.img.resize(s.getSize());
            this.img.setImage(s);
        }
        if(!this.lbl){
            this.lbl=new GUI.Label({'parent':this,
                                   'position':[0, 0],
                                   'text':levels[track].title,
                                   'font':getFont(skin.trackdisplay.font)});
        }else{
            this.lbl.setText(levels[track].title);
        }
        this.center(this.lbl);
        this.lbl.move([this.lbl.position[0], this.size[1]-this.lbl.size[1]-5]);
    }
};

/***
 *
 *pars:
     scene
     position
     columns  - list of column defs,
                column def is {'key':'item', 'label':'The Item', 'width':100}
     data - list of data: {id:row_id,
                           key:value,
                           key2:value,
                           ....}
    selectable - can rows be selected?*/

var Table=exports.Table=function(pars){
    Table.superConstructor.apply(this, [pars]);
    this.columns=pars.columns;
    this.data=pars.data;
    this.header=new GUI.View({'parent':this,
                             'size':[this.size[0], 30],
                             'position':[0, 0]});
    this.header.on(GUI.EVT_PAINT, function(){
        this.surface.fill(skin.table.header_fill);
    }, this.header);
    
    var ofst=0;
    this.columns.forEach(function(column){
        new GUI.Label({'parent':this.header,
                      'position':[ofst+20, 3],
                      'font':getFont(skin.table.header_font),
                      'text':column.label});
        ofst+=column.width;
    }, this);
    
    this.body=new GUI.View({'parent':this,
                             'size':[this.size[0], this.size[1]-30],
                             'position':[0, 30]});
    this.body.on(GUI.EVT_PAINT, function(){
        this.surface.fill(skin.table.body_fill);
    }, this.body);
    if(this.data) this.setData(this.data);
};

gamejs.utils.objects.extend(Table, GUI.View);

Table.prototype.setData=function(data, empty_label){
    this.body.children=[];
    var row_ofst=0, col_ofst;
    if (data.length){
        data.forEach(function(row){
            col_ofst=0;
            var view=new GUI.View({'parent':this.body,
                                  'size':[this.size[0], 30],
                                  'position':[0, row_ofst]});
            this.columns.forEach(function(column){
                new GUI.Label({'parent':view,
                            'position':[col_ofst+20, 3],
                            'font':getFont(skin.table.header_font),
                            'text':String(row[column.key]),
                            'font':getFont(skin.table.data_font)});
                col_ofst+=column.width;
            }, this);
            row_ofst+=30;
        }, this);
    } else if(empty_label){
        new GUI.Label({'parent':this.body,
                        'position':[20, 3],
                        'font':getFont(skin.table.header_font),
                        'text':String(empty_label),
                        'font':getFont(skin.table.data_font)});
    }
};


var IncrementButton=exports.IncrementButton=function(pars){
    var image=new gamejs.Surface(pars.size);
    var image_hover=new gamejs.Surface(pars.size);
    if(pars.direction=='up'){
        var ptlist=[[parseInt(pars.size[0]/2), 0], pars.size, [0, pars.size[1]]];    
    }
    else if(pars.direction=='down'){
        var ptlist=[[0, 0], [pars.size[0], 0],[parseInt(pars.size[0]/2), pars.size[1]]];
    }
    else if(pars.direction=='left'){
        var ptlist=[[0, parseInt(pars.size[1]/2)], [pars.size[0], 0], pars.size];
    }else{
        var ptlist=[[0, 0], [pars.size[0], parseInt(pars.size[1]/2)], [0, pars.size[1]]];
    }
    
    gamejs.draw.polygon(image, skin.title_button.fill, ptlist);
    gamejs.draw.polygon(image_hover, skin.title_button.fill_hover, ptlist);
    
    pars.image=image;
    pars.image_hover=image_hover;
    pars.image_down=false;
    IncrementButton.superConstructor.apply(this, [pars]);
    this.onClick(function(){
        sounds.play({'filename':'button_click.wav'});
    });
};
gamejs.utils.objects.extend(IncrementButton, GUI.Button);


var Stars=exports.Stars=function(pars){
    pars.image=renderer.cache['static'][pars.stars+'stars.png'];
    Stars.superConstructor.apply(this, [pars]);
};
gamejs.utils.objects.extend(Stars, GUI.Image);

Stars.prototype.setStars=function(stars){
    var img=renderer.cache['static'][stars+'stars.png'];
    this.resize(img.getSize())
    this.setImage(img);
};

var KeyExplanation=exports.KeyExplanation=function(pars){
    pars.size=[400, 52];
    KeyExplanation.superConstructor.apply(this, [pars]);
    var font=getFont('25_66');
    this.key=pars.key;
    this.text=pars.text;
    var bt_w= 60;
    if(this.key.length>1) bt_w=font.getTextSize(this.key)[0]+50;
    this.btn=new GUI.Button({'size':[bt_w, this.getSize()[1]],
                            'position':[0, 0],
                            'font':font,
                            'parent':this,
                            'image':renderer.cache.getUIImage('key_bg.png'),
                            'text':this.key});
    this.btn.label.move([this.btn.label.getPosition()[0], this.btn.label.getPosition()[1]-7]);
    
    this.lbl=new GUI.Label({'position':[0, 0],
                           'parent':this,
                           'font':font,
                           'text':this.text});
    
    this.center(this.lbl);
    this.lbl.move([bt_w+30, this.lbl.getPosition()[1]]);
};

gamejs.utils.objects.extend(KeyExplanation, GUI.View);
},{"./car_descriptions":4,"./combatracer":6,"./gamejs-gui":18,"./leagues":21,"./levels":22,"./renderer":26,"./settings":28,"./skin":29,"./sounds":30,"./utils":33,"./weapon_descriptions":34,"gamejs":37}],32:[function(require,module,exports){
var gamejs = require('gamejs');
var ui=require('./ui');
var utils=require('./utils');
var levels=require('./levels');
var car_descriptions=require('./car_descriptions');
var GUI=require('./gamejs-gui');
var skin=require('./skin');
var combatracer=require('./combatracer');
var renderer=require('./renderer');
var leagues=require('./leagues');
var sounds=require('./sounds');

var EURO_SYMBOL='\u20AC';
/*
var LobbyScene=exports.LobbyScene=function(game, cache, lobby_id){
    LobbyScene.superConstructor.apply(this, [game, cache]);
    this.lobby_id=lobby_id;
    this.ping=true;

    this.kick=function(){
        if(!this.playertable.selected_row_id){
            this.alert('Select a player first!');
            return;
        }
        this.game.getCommunicator().queueMessage('KICK', {'player_id':this.playertable.selected_row_id, 'lobby_id':this.lobby_id});
    };

    this.leave=function(){
        this.game.getCommunicator().queueMessage('LEAVE_LOBBY');
    };

    this.refresh_lobby=function(){
        this.game.getCommunicator().queueMessage('GET_LOBBY_INFO');
    };

    this.start=function(){
        this.game.getCommunicator().queueMessage('START_GAME');
    };

    this.selectCar=function(){
          this.game.getCommunicator().queueMessage('SELECT_CAR', {'car':this.car_selector.selected});
    };

    this.handleMessage=function(cmd, payload){
        if(cmd=='LOBBY_INFO'){
            this.playertable.setData(payload.players);
            if(payload.is_leader){
                this.kickbtn.enable();
                this.startbtn.enable();
                this.playertable.selectable=true;
            }else{
                this.kickbtn.disable();
                this.startbtn.disable();
                this.playertable.selectable=false;
            }
            this.trackdisplay.setTrack(payload.track);
        }
        else if(cmd=='LEFT_LOBBY'){
            this.game.showTitle();
            if(payload.text)this.game.title_scene.alert(payload.text);
        }else if(cmd=='START_GAME'){
            this.game.playMultiplayer(levels[payload.track]);
        }else{
            this.handleMessageDefault(cmd, payload);
        }
    };

    this.header=new ui.Label({'scene':this,
                                'position':[10, 10],
                                'text':'Lobby',
                                'font':'header'});

    var columns=[{'key':'player', 'label':'Player', 'width':200},
                 {'key':'car',    'label':'Car',     'width':120}];

    this.playertable=new ui.Table({'scene':this,
                                 'position':[10, 70],
                                 'rows':6,
                                 'columns':columns})

    this.kickbtn=new ui.Button({'scene':this,
                               'position':[10, 7*30+70+5],
                               'text':'Kick',
                               'enabled':false,
                               'onclick':this.kick});

    this.leavebtn=new ui.Button({'scene':this,
                                'position':[10, 400],
                                'text':'Leave',
                                'onclick':this.leave});

    this.startbtn=new ui.Button({'scene':this,
                                'position':[220, 400],
                                'text':'Start game',
                                'enabled':false,
                                'onclick':this.start});

    new ui.Label({'scene':this,
                 'position':[590, 30],
                 'text':'Select a car'});

    this.car_selector=new ui.CarSelector({'scene':this,
                                    'position':[590, 70],
                                    'onselect':this.selectCar,
                                    'scope':this});

    this.car_selector.select(null, 'Racer');



    this.trackdisplay=new ui.TrackInfoDisplay({'scene':this,
                                               'position':[340, 70]});

    this.refresh_lobby();
    return this;

};
gamejs.utils.objects.extend(LobbyScene, ui.UIScene);*/


var CongratulationsScene=exports.CongratulationsScene=function(){
    CongratulationsScene.superConstructor.apply(this, []);
    
    this.titlelbl=new GUI.Label({'parent':this.container,
                                'position':[210, 40],
                                'text':'Congratulations',
                                'font':ui.getFont('header_black')});
    
    this.label=new GUI.Label({'parent':this.container,
                                'position':[30, 120],
                                'text':'You won the game!',
                                'font':ui.getFont('header')});
    
    this.text=new GUI.Text({'parent':this.container,
                            'position':[30, 180],
                            'font':ui.getFont('16_33'),
                            'width':500,
                            'text':'There are no more leagues yet, which means you win!\nCheck back soon for more cars, weapons and tracks. Follow BanditRacer on twitter!'});

}

gamejs.utils.objects.extend(CongratulationsScene, ui.UIScene);

var SPGameOverScene=exports.SPGameOverScene=function(table, place, scene){
    SPGameOverScene.superConstructor.apply(this, []);
    var win=place==1;
    this.titlelbl=new GUI.Label({'parent':this.container,
                                'position':[210, 40],
                                'text':'Race Over',
                                'font':ui.getFont('header_black')});
    
    this.label=new GUI.Label({'parent':this.container,
                                'position':[30, 120],
                                'text':win ? 'You win! Well done.' : 'You lose! Better luck next time.',
                                'font':ui.getFont('header')});
    
    var columns=[{'key':'place', 'label':'Place', 'width':80},
              {'key':'player', 'label':'Player', 'width':200},
              {'key':'kills', 'label':'Kills', 'width':80},
              {'key':'deaths', 'label':'Deaths', 'width':80}];
    
    new ui.Table({'parent':this.container,
                  'size':[460, 300],
                  'position':[30, 200],
                  'columns':columns,
                  'data':table});
    

    
        
    var league=leagues[combatracer.game.player.singleplayer.league];
    
    
    //REWARD
    if(!(combatracer.game.return_to=='editor')){
        var reward = 0;
        
        new GUI.Label({'position':[510, 200],
                  'parent':this.container,
                  'font':ui.getFont('button2'),
                  'text':'Reward'});
        
        if(place>0&&place<4) reward=league['reward_'+place];
        
    
        if(place>0){
            var l;
            if(place==1)l='1st place:';
            else if(place==2)l='2nd place:';
            else if(place==3)l='3d place:';
            else{
                l='4th place:';
            }
            new GUI.Label({'position':[510, 240],
                          'font':ui.getFont('alias'),
                          'parent':this.container,
                          'text':l});
            
            var lbl= new GUI.Label({'position':[510, 240],
                          'font':ui.getFont('alias'),
                          'parent':this.container,
                          'text':String(reward)+EURO_SYMBOL});
            lbl.rightAlign(730);
        }
        
        new GUI.Label({'position':[510, 270],
                     'font':ui.getFont('alias'),
                     'parent':this.container,
                     'text':'Kills:'});
        
        lbl= new GUI.Label({'position':[510, 270],
                      'font':ui.getFont('alias'),
                      'parent':this.container,
                      'text':String(scene.player_car.kills*100)+EURO_SYMBOL});
        lbl.rightAlign(730);
        
        var total=reward+scene.player_car.kills*100;
        new GUI.Label({'position':[510, 300],
                     'font':ui.getFont('alias'),
                     'parent':this.container,
                     'text':'TOTAL:'});
        
        lbl= new GUI.Label({'position':[510, 300],
                      'font':ui.getFont('alias'),
                      'parent':this.container,
                      'text':String(total)+EURO_SYMBOL});
        lbl.rightAlign(730);
    
        combatracer.game.player.singleplayer.balance+=total;
    }
    
    
    //dirty hax, show congratulate scene if no more tracks/leagues remain
    this.update=function(ms){
        new ui.UIScene().update.apply(this, [ms]);
        if(this.congratulate)this.game.showCongratulations();
    };
    
    //HANDLE WIN
    if(win){
        combatracer.game.player.singleplayer.completed_tracks.push(scene.level.id);
    
        if(combatracer.game.player.singleplayer.completed_tracks.length>=league.tracks.length){
            if(leagues[combatracer.game.player.singleplayer.league+1]){
                combatracer.game.player.singleplayer.league++;
                combatracer.game.player.singleplayer.completed_tracks = [];
                this.alert('You have advanced to '+leagues[combatracer.game.player.singleplayer.league].name+'!');
            }else{
                this.alert('You win the tournament! Hell difficulty unlocked.')
                combatracer.game.player.singleplayer.league = 0;
                combatracer.game.player.singleplayer.completed_tracks = [];
                combatracer.game.player.singleplayer.completed = true;
            }
        }
    }
    
    //SAVE GAME
    if(!(combatracer.game.return_to=='editor')){
        if(combatracer.game.save()){
            new GUI.Text({'position':[30, 510],
                  'font':ui.getFont('13_green'),
                  'parent':this.container,
                  'width':460,
                  'text':'Game saved to HTML5 storage. You will be able to load it next time you play Bandit Racer on this browser.'});
        }
    }  
    
    
    var btn=new ui.Button({'parent':this.container,
                   'position':[800-150, 500],
                   'size':[150, 50],
                   'lean':'right',
                   'text':'Continue...'});
    btn.onClick(function(){
        this.game.returnTo();
    }, this);
    
    

};

gamejs.utils.objects.extend(SPGameOverScene, ui.UIScene);

/*
var JoinLobbyScene2=exports.JoinLobbyScene2=function(game, cache){
    JoinLobbyScene2.superConstructor.apply(this, [game, cache]);

    this.refresh_lobbies=function(){
        this.lobby_table.setData([]);
        this.lobby_table.no_data_text='Loading, please wait...';
        this.game.getCommunicator().queueMessage('LIST_LOBBIES', {});
    };


    this.join=function(){
        if(!this.lobby_table.selected_row_id){
            this.alert('You must select a lobby first!');
        }else{
            this.game.getCommunicator().queueMessage('JOIN_LOBBY', {'lobby_id':this.lobby_table.selected_row_id});
        }
    };

    this.handleMessage=function(cmd, payload){
        if(cmd=='LOBBY_LIST'){
            var data=payload.lobbies;
            var row;
            for(var i=0;i<data.length;i++){
                row=data[i];
                row.track=levels[row.track].title;
                row.players=row.playercount;
            }
            this.lobby_table.setData(data);
            this.lobby_table.no_data_text='No lobbies found.';
        }else if(cmd=="JOIN_LOBBY_OK"){
            this.game.joinLobby(payload.lobby_id);
        }else{
            this.handleMessageDefault(cmd, payload);
        }

    };

    new ui.Label({'scene':this,
                 'position':[10, 10],
                 'text':'Join lobby',
                 'font':'header'});

    new ui.Button({'scene':this,
                  'position':[10, 410],
                  'text':'Back',
                  'onclick':this.returnToTitle});

    new ui.Button({'scene':this,
                  'position':[220, 410],
                  'text':'Refresh',
                  'onclick':this.refresh_lobbies});

    new ui.Button({'scene':this,
                  'position':[430, 410],
                  'text':'Join',
                  'onclick':this.join});

    var columns=[{'key':'title', 'label':'Title', 'width':220},
                 {'key':'track', 'label':'Track', 'width':200},
                 {'key':'players', 'label':'Players', 'width':200}];

    this.lobby_table=new ui.Table({'scene':this,
                                  'position':[10, 70],
                                  'rows':10,
                                  'selectable':true,
                                  'columns':columns});

    this.refresh_lobbies();


};
gamejs.utils.objects.extend(JoinLobbyScene2, ui.UIScene);
*/

var CreateLobbyScene = exports.CreateLobbyScene = function(){
    CreateLobbyScene.superConstructor.apply(this, []);
    
    
    new GUI.Label({'parent':this.container,
                    'position':[210, 40],
                    'text':'Create Lobby',
                    'font':ui.getFont('header_black')});
                                
    new GUI.Label({'parent':this.container,
                   'position':[20, 150],
                   'text':'Title',
                   'font':ui.getFont('alias')
                });
                
    this.title = new GUI.TextInput({'parent':this.container,
                                   'position':[20, 190],
                                   'size':[200, 34],
                                   'text':'some game',
                                   'font':ui.getFont('alias')});
                                   
    new GUI.Label({'parent':this.container,
                   'position':[20, 250],
                   'text':'Budget',
                   'font':ui.getFont('alias')
                });
                
    this.title = new GUI.TextInput({'parent':this.container,
                                   'position':[20, 290],
                                   'size':[200, 34],
                                   'text':'10000',
                                   'font':ui.getFont('alias')});
                                                              
    this.track_selector=new ui.TrackSelector({'position':[254, 160],
                                              'parent':this.container,
                                              'tracks':levels.all,
                                              'label':'Tracks'});
                                              
                                              
    this.backbtn=new ui.Button({'size':[130, 50],
                                'parent':this.container,
                                'position':[0, 520],
                                'lean':'left',
                                'text':'BACK'});
    this.backbtn.onClick(this.back, this);
    
    this.racebtn=new ui.Button({'size':[130, 50],
                                'parent':this.container,
                                'position':[this.container.size[0]-130, 520],
                                'lean':'right',
                                'text':'CREATE'});
    this.racebtn.onClick(this.create, this);              
    
};

gamejs.utils.objects.extend(CreateLobbyScene, ui.UIScene);

CreateLobbyScene.prototype.back = function(){
    this.game.showLobbyList();  
};

CreateLobbyScene.prototype.create = function(){
    
};

var JoinLobbyScene=exports.JoinLobbyScene=function(){
    JoinLobbyScene.superConstructor.apply(this, []);
    
    
    
    this.titlelbl=new GUI.Label({'parent':this.container,
                                'position':[210, 40],
                                'text':'Multiplayer',
                                'font':ui.getFont('header_black')});
    
    var columns=[{'key':'title', 'label':'Title', 'width':150},
                 {'key':'track', 'label':'Track', 'width':150},
                 {'key':'players', 'label':'Players', 'width':150}]
    this.table=new ui.Table({'parent':this.container,
                             'size':[450, 350],
                             'position':[300, 150],
                             'columns':columns,
                             'data':[]});
    
    this.create_btn=new ui.Button({'parent':this.container,
                                  'size':[200, 50],
                                  'lean':'left',
                                  'position':[0, 150],
                                  'text':'Create Lobby'});
    
    this.refresh_btn=new ui.Button({'parent':this.container,
                                    'size':[200, 50],
                                    'lean':'left',
                                    'position':[0, 210],
                                    'text':'Refresh'});
    
    this.back_btn=new ui.Button({'parent':this.container,
                                    'size':[200, 50],
                                    'lean':'left',
                                    'position':[0, 520],
                                    'text':'Back'});
    this.back_btn.onClick(this.returnToTitle, this);
    
    this.join_btn=new ui.Button({'parent':this.container,
                                'size':[200, 50],
                                'lean':'right',
                                'position':[this.container.size[0]-200, 520],
                                'text':'Join'});
                                
    this.handleMessage=function(cmd, payload){
        if(cmd=='LOBBY_LIST'){
            var data=payload.lobbies;
            var row;
            for(var i=0;i<data.length;i++){
                row = data[i];
                row.track=levels[row.track].title;
                row.players = row.playercount;
            }
            this.table.setData(data, 'No lobbies found.');
        }else if(cmd == "JOIN_LOBBY_OK"){
            this.game.joinLobby(payload.lobby_id);
        }else{
            this.handleMessageDefault(cmd, payload);
        }

    };
    
    this.refresh_btn.onClick(function(){
        this.game.getCommunicator().queueMessage('LIST_LOBBIES', {});
    }, this);
    
    this.create_btn.onClick(function(){
        this.game.createLobby();
    }, this);
    
    this.game.getCommunicator().queueMessage('LIST_LOBBIES', {});
};
gamejs.utils.objects.extend(JoinLobbyScene, ui.UIScene);

/*
var CreateLobbyScene=exports.CreateLobbyScene=function(game, cache){
    CreateLobbyScene.superConstructor.apply(this, [game, cache]);

    this.create=function(){
        if(!this.title.getText().length){
            this.alert('Lobby title is required!');
            return;
        }
        if(!this.selector.selected){
            this.alert('You must select a track!');
            return;
        }
        else{
            this.alert('Please wait...', false);
            this.game.getCommunicator().queueMessage('CREATE_LOBBY', {'title':this.title.getText(), 'track':this.selector.selected});

        }
    };

    this.handleMessage=function(cmd, payload){
        if(cmd=='CREATE_LOBBY_OK'){
            this.game.joinLobby(payload.lobby_id);
        }else{
            this.handleMessageDefault(cmd, payload);
        }

    };

    new ui.Label({'scene':this,
                 'position':[10, 10],
                 'text':'Create lobby',
                 'font':'header'});

    new ui.Button({'scene':this,
                  'position':[10, 400],
                  'text':'Back',
                  'onclick':this.returnToTitle});

    new ui.Button({'scene':this,
                  'position':[220, 400],
                  'text':'Create',
                  'onclick':this.create});


    new ui.Label({'scene':this,
                 'position':[10, 90],
                 'text':'Lobby title'});

    this.title=ui.TextBox({'scene':this,
                'position':[10, 130],
                'size':[220, 25],
                'text':'Some lobby'});

    this.selector=new ui.LevelSelector({'scene':this,
                         'position':[250, 90]});
};
gamejs.utils.objects.extend(CreateLobbyScene, ui.UIScene);*/

var TitleScene=exports.TitleScene=function(game, cache){
    TitleScene.superConstructor.apply(this, [game, cache]);
    
    //paint background under text box
    this.container.on(GUI.EVT_PAINT, function(){
        gamejs.draw.polygon(this.surface, skin.alias_background, [[0, 110], [420, 110], [390, 180], [0, 180]]);
    }, this.container);
    
    //logo
    new GUI.Image({'position':[40, 260],
                  'parent':this.container,
                  'image':this.cache.getUIImage('logo.png')});
    
    //name: label
    new GUI.Label({'position':[50, 115],
                  'parent':this.container,
                  'font':ui.getFont('alias_label'),
                  'text':'name:'});
    
    //name input
    this.nameinput=new ui.NameInput({'position':[178, 129],
                                     'size':[200, 40],
                                     'text':this.game.player.alias,
                                     'parent':this.container});
    
    this.nameinput.on(GUI.EVT_CHANGE, function(event){
        this.game.player.alias=event.value; 
    }, this);
    
    this.btn_single=new ui.TitleButton({'position':[440, 210],
                                        'size':[360, 65],
                                        'text':'Single player',
                                        'parent':this.container});
    
    this.btn_single.onClick(this.singleplayer, this);
    
   /* this.btn_multi=new ui.TitleButton({'position':[440, 300],
                                        'size':[360, 65],
                                        'text':'Multiplayer',
                                        'parent':this.container});
    
    this.btn_multi.onClick(this.joinLobby, this);*/
    
    this.btn_editor=new ui.TitleButton({'position':[440, 300],
                                        'size':[360, 65],
                                        'text':'Track Editor',
                                        'parent':this.container});
    
    this.btn_editor.onClick(this.editTrack, this);
    
    if(!this.game.tried_loading){
        if(this.game.haveSave()){
            this.yes_no_dialog=new ui.YesNoDialog({'parent':this.gui,
                                     'size':[550, 150],
                                     'text':'Saved game found. Do you want to load?'});
            this.yes_no_dialog.yes.onClick(function(){
                this.yes_no_dialog.close();
                if(this.game.load())this.nameinput.setText(combatracer.game.player.alias);
            }, this);
            
            this.yes_no_dialog.no.onClick(function(){
                this.yes_no_dialog.close();
            }, this);
            this.yes_no_dialog.show();
        }
        this.game.tried_loading=true;
    }
};

gamejs.utils.objects.extend(TitleScene, ui.UIScene);

TitleScene.prototype.editTrack=function(){
    this.game.showEditor();
};

TitleScene.prototype.handleMessage=function(cmd, payload){
    if(cmd=='HELLO'){
        this.game.player.uid=payload.uid;
        this.game.acquainted=true;
        this.clearAlert();
        this.game.showLobbyList();     
    }else{
        this.handleMessageDefault(cmd, payload);
    }
};

TitleScene.prototype.joinLobby=function(){
        var alias=this.game.player.alias;
        if(!alias) this.alert('You must enter your name first!');
        else{
            this.alert('Connecting. Please wait...', false);
            this.game.getCommunicator().queueMessage('HI',{'alias':alias});
        }
    };

TitleScene.prototype.singleplayer=function(){
    this.game.singleplayer();
};



var SinglePlayerScene=exports.SinglePlayerScene=function(){
    SinglePlayerScene.superConstructor.apply(this, []);
    
    this.container.header_height=130;
    this.container.background_color=skin.single_player_scene.background_color;
    this.container.refresh();
    
    this.titlelbl=new GUI.Label({'parent':this.container,
                                'position':[210, 40],
                                'text':'Single Player',
                                'font':ui.getFont('header_black')});
    
    this.backbtn=new ui.Button({'size':[130, 50],
                                'parent':this.container,
                                'position':[0, 520],
                                'lean':'left',
                                'fill':skin.sp_button.fill,
                                'font':ui.getFont(skin.sp_button.font),
                                'hover_fill':skin.sp_button.fill_hover,
                                'text':'BACK'});
    this.backbtn.onClick(this.back, this);
    
    this.racebtn=new ui.Button({'size':[130, 50],
                                'parent':this.container,
                                'position':[this.container.size[0]-130, 520],
                                'lean':'right',
                                'fill':skin.sp_button.fill,
                                'font':ui.getFont(skin.sp_button.font),
                                'hover_fill':skin.sp_button.fill_hover,
                                'text':'RACE!'});
    this.racebtn.onClick(this.race, this);
    
    this.gotogarage=new ui.GoToGarage({'position':[14, 160],
                                       'parent':this.container});
    this.gotogarage.on(GUI.EVT_MOUSE_DOWN, function(){
        this.game.return_to='singleplayer';
        sounds.play({'filename':'button_click.wav'});
        this.game.showSPGarage();
    }, this);
    
    this.car_display=new ui.CarDisplay({'position':[14, 356],
                                        'gameinfo':combatracer.game.player.singleplayer,
                                          'parent':this.container});
    
    var tracks = [];
    
    leagues[combatracer.game.player.singleplayer.league].tracks.forEach(function(track){
        if(levels[track].title && (!utils.inArray(combatracer.game.player.singleplayer.completed_tracks, track))){
            tracks.push(levels[track]);
        }
    });

    this.track_selector=new ui.TrackSelector({'position':[254, 160],
                                              'parent':this.container,
                                              'tracks':tracks,
                                              'label':leagues[combatracer.game.player.singleplayer.league].name});
    
    this.diff_selector=new ui.DifficultySelect({'position':[14, 431],
                                               'parent':this.container,
                                               'size':[210, 65]});
    
};
gamejs.utils.objects.extend(SinglePlayerScene, ui.UIScene);

SinglePlayerScene.prototype.back=function(){
    this.game.showTitle();
};

SinglePlayerScene.prototype.race=function(){
    if(!this.track_selector.track){
        this.alert('You must select a track first!', true); 
    }else{
        this.game.playLevel(levels[this.track_selector.track], false, 'singleplayer');
    }
};

var LoadingScene=exports.LoadingScene=function(game, cache, next_scene){
    LoadingScene.superConstructor.apply(this, [game, cache]);
    this.container.destroy();
    var lbl=new GUI.Label({'position':[0, 0],
                     'parent':this.gui,
                      'text':'Loading, please wait...',
                      'font':ui.getFont('25_66')});
    this.gui.center(lbl);
    this.next_scene=next_scene;
};

gamejs.utils.objects.extend(LoadingScene, ui.UIScene);

var ControlsSplash=exports.ControlsSplash=function(game, cache, next_scene){
    ControlsSplash.superConstructor.apply(this, [game, cache]);
    this.container.destroy();
    this.next_scene=next_scene;
    this.gui.on(GUI.EVT_PAINT, function(){
        this.surface.fill(skin.ui_background);
    }, this.gui);
    
    var img=new GUI.Image({'position':[0, 0],
                  'image':cache.getUIImage('controls.png'),
                  'parent':this.gui});
    this.gui.center(img);
    var y=img.getPosition()[1]-120;
    x=img.getPosition()[0];
    img.move([x, y]);
    x-=60;
    y+=img.getSize()[1]+10;
    
    new ui.KeyExplanation({'position':[x, y],
                          'key':'x',
                          'parent':this.gui,
                          'text':'Fire front weapon'});
    y+=62;
    
    new ui.KeyExplanation({'position':[x, y],
                          'key':'c',
                          'parent':this.gui,
                          'text':'Use utility'});
    y+=62;
    
    new ui.KeyExplanation({'position':[x, y],
                          'key':'v',
                          'parent':this.gui,
                          'text':'Fire rear weapon'});
    y+=62;
    
    new ui.KeyExplanation({'position':[x, y],
                          'key':'ESC',
                          'parent':this.gui,
                          'text':'Menu'});
    y+=62;
    
    
    
   this.lbl=new GUI.Label({'position':[x-30, y],
                            'parent':this.gui,
                            'text':'Loading. Please wait...',
                            'font':ui.getFont('25_66')});
   this.loaded=false;
   this.first=false;
   
   this.update=function(msDuration){
        ui.UIScene().update.apply(this, [msDuration]);
        if(!this.first){
            this.first=true;
        }else{
            if(!this.loaded){
                this.game.cacheCarSprites(this.next_scene);
                this.lbl.setText('Press any key or click to continue...');
                this.gui.despatchEvent({'type':GUI.EVT_FOCUS});
                this.gui.on(GUI.EVT_MOUSE_DOWN, this.next, this);
                this.gui.on(GUI.EVT_KEY_DOWN, this.next, this);
                this.loaded=true;
            }
        }
   }
};

gamejs.utils.objects.extend(ControlsSplash, ui.UIScene);


ControlsSplash.prototype.next=function(){
    this.game.director.replaceScene(this.next_scene);  
};


},{"./car_descriptions":4,"./combatracer":6,"./gamejs-gui":18,"./leagues":21,"./levels":22,"./renderer":26,"./skin":29,"./sounds":30,"./ui":31,"./utils":33,"gamejs":37}],33:[function(require,module,exports){
var gamejs=require('gamejs');
var math=gamejs.utils.math;
var box2d=require('./engine').box2d;
var buffs=require('./buffs');
var settings=require('./settings');
var vectors = gamejs.utils.vectors;
var renderer=require('./renderer');

exports.renderLevelBackground=function(level, render_props){
    var cache=renderer.cache;
    var width=level.size[0];
    var height=level.size[1];
    var background=new gamejs.Surface([width, height]);
    var x, y;
    var tile=cache.getTile(level.bgtile);
    var sz=tile.getSize();
    for(y=0;y<height;y=y+sz[1]){
        for(x=0;x<width;x=x+sz[0]){
                background.blit(tile, [x, y]);             
        }
    }
    
    //render decals into background
    var position, angle;
    level.decals.forEach(function(decal){
        angle=math.normaliseDegrees(decal.a);
        background.blit(cache.getDecalSprite(level.dict[decal['f']], angle), decal.p)
    }, this);

    if(render_props ||(render_props==undefined)){
        //RENDER PROPS INTO BACKGROUND
        level.props.forEach(function(prop){
            angle=math.normaliseDegrees(prop.a);
            background.blit(cache.getPropSprite(level.dict[prop['f']], angle), prop.p)
        }, this);
    }
    
    return background;
};

exports.interpolatePoints=function(pt1, pt2, q){
    return [pt1[0]+(pt2[0]>pt1[0]? 1 : -1)*Math.abs(pt2[0]-pt1[0])*q,
            pt1[1]+(pt2[1]>pt1[1]? 1 : -1)*Math.abs(pt2[1]-pt1[1])*q];
};

exports.interpolateInts=function(a1, a2, q){
    return a1+(a2>a1? 1: -1)*Math.abs(a2-a1)*q;
};

var copy=exports.copy=function(src, dest){
    for(var attr in src) dest[attr]=src[attr];
    return dest;
};

var vec=exports.vec=function(){
    if(!(arguments.length && arguments[0].hasOwnProperty('x'))){
        if(arguments.length==1) return new box2d.b2Vec2(arguments[0][0], arguments[0][1]);
        else if(arguments.length==2) return new box2d.b2Vec2(arguments[0], arguments[1]);
        else throw "kablooie"
    }else return arguments[0];
};

var vectorToList=exports.vectorToList=exports.arr=function(vect){
    if(vect.hasOwnProperty('x')) return [vect.x, vect.y];
    return vect;
};

exports.removeObjFromList=function(val, list){
    for(var i=0; i<list.length; i++) {
        if(list[i] == val) {
            list.splice(i, 1);
            break;
        }
    }
};

exports.resizeSurfaceToHeight=function(surface, height){
    var sz=surface.getSize();
    var q=sz[1]/height
    var new_sz=[parseInt(sz[0]/q), parseInt(sz[1]/q)];
    var s=new gamejs.Surface(new_sz[0], new_sz[1]);
    s.blit(surface, new gamejs.Rect([0, 0], s.getSize()), new gamejs.Rect([0, 0], surface.getSize()));
    return s;
};

exports.inArray=function(haystack, needle){
    for(var i=0;i<haystack.length;i++){
        if(haystack[i]==needle) return true;
    }
    return false;
};

exports.supports_html5_storage=function() {
  try {
    return 'localStorage' in window && window['localStorage'] !== null;
  } catch (e) {
    return false;
  }
}

exports.push = function(obj, obj_from, force_multiplier, debuff_duration){
    if(obj.has_tag('car') && debuff_duration)
        obj.world.create(buffs.SlipDebuff, {'duration':debuff_duration,
                                             'object':obj});
    var fvect = vectors.unit(vectors.subtract(obj.get_position(), obj_from.get_position()));
    fvect = vectors.multiply(fvect, obj.get_mass()*force_multiplier);
    obj.apply_impulse(fvect, obj.get_position());
}

},{"./buffs":3,"./engine":9,"./renderer":26,"./settings":28,"gamejs":37}],34:[function(require,module,exports){
exports.Machinegun = {
    'damage' : 5,
    'preload' : ['bullet.png'],
    'type' : 'front_weapon',
    'launcher' : 'Machinegun',
    'projectile' : 'Bullet',
    'speed' : 500,
    'fire_rate' : 200,
    'ammo_capacity' : 50,
    'damage_upgrade' : 1,
    'damage_upgrade_price' : 500,
    'ammo_upgrade' : 10,
    'ammo_upgrade_price' : 500,
    'name' : 'Machineguns',
    'icon' : 'icon_machinegun.png',
    'price' : 700,
    'description' : 'Your basic car accessory: two front mounted high caliber machineguns'
};

exports.MissileLauncher = {
    'damage' : 25,
    'preload' : ['missile.png'],
    'speed' : 400,
    'type' : 'front_weapon',
    'launcher' : 'MissileLauncher',
    'projectile' : 'Missile',
    'fire_rate' : 600,
    'ammo_capacity' : 10,
    'ammo_upgrade' : 2,
    'ammo_upgrade_price' : 700,
    'damage_upgrade' : 5,
    'damage_upgrade_price' : 700,
    'name' : 'Missiles',
    'icon' : 'icon_missiles.png',
    'price' : 1000,
    'description' : 'Torpedo missiles with high yield warheads, for when you really don\'t like the guy in front of you'
};

exports.RepairKit = {
    'damage' : 30,
    'type' : 'util',
    'launcher' : 'RepairKit',
    'projectile' : null,
    'fire_rate' : 500,
    'ammo_capacity' : 2,
    'ammo_upgrade' : 1,
    'ammo_upgrade_price' : 500,
    'damage_upgrade' : 10,
    'damage_upgrade_price' : 700,
    'name' : 'Repair Kit',
    'icon' : 'icon_fix.png',
    'price' : 1000,
    'description' : 'Repair your car on the go with a automatic repair kit'
};

exports.NOS = {
    'damage' : 15,
    'type' : 'util',
    'fire_rate' : 2000,
    'duration' : 2000,
    'ammo_capacity' : 2,
    'ammo_upgrade' : 1,
    'ammo_upgrade_price' : 1500,
    'damage_upgrade' : 4,
    'damage_upgrade_price' : 1000,
    'launcher' : 'NOS',
    'name' : 'Boost',
    'price' : 2000,
    'icon' : 'ico_nos.png',
    'description' : 'Increases top speed and acceleration for a shot time'
};

exports.Shockwave = {
    'damage' : 10,
    'type' : 'util',
    'fire_rate' : 1500,
    'ammo_capacity' : 3,
    'ammo_upgrade' : 1,
    'ammo_upgrade_price' : 1300,
    'damage_upgrade' : 5,
    'damage_upgrade_price' : 800,
    'launcher' : 'ShockwaveGenerator',
    'name' : 'Shockwave',
    'price' : 1500,
    'icon' : 'icon_sw.png',
    'description' : 'Generates a shockwave that slams nearby cars away from your car'
};

exports.HomingMissiles = {
    'damage' : 18,
    'speed' : 400,
    'preload' : ['missile_homing.png'],
    'type' : 'front_weapon',
    'launcher' : 'MissileLauncher',
    'projectile' : 'HomingMissile',
    'fire_rate' : 500,
    'ammo_capacity' : 10,
    'ammo_upgrade' : 2,
    'ammo_upgrade_price' : 700,
    'damage_upgrade' : 4,
    'damage_upgrade_price' : 800,
    'name' : 'Homing Missiles',
    'price' : 1300,
    'icon' : 'icon_missiles_homing.png',
    'description' : "Heat seeking missiles, a blind driver's favourite weapon"
};

exports.MineLauncher = {
    'damage' : 30,
    'type' : 'rear_weapon',
    'launcher' : 'MineLauncher',
    'projectile' : 'Mine',
    'fire_rate' : 500,
    'ammo_capacity' : 5,
    'ammo_upgrade' : 2,
    'ammo_upgrade_price' : 600,
    'damage_upgrade' : 8,
    'damage_upgrade_price' : 500,
    'name' : 'Mines',
    'icon' : 'icon_mine.png',
    'price' : 800,
    'description' : 'Discourage tailgating with anti-vehicle mines'
};

exports.Oil = {
    'damage' : 0,
    'type' : 'rear_weapon',
    'fire_rate' : 500,
    'duration' : 800,
    'ammo_capacity' : 2,
    'ammo_upgrade' : 1,
    'ammo_upgrade_price' : 2000,
    'damage_upgrade' : null,
    'damage_upgrade_price' : null,
    'name' : 'Oil',
    'icon' : 'ico_oil.png',
    'price' : 2000,
    'launcher' : 'Oil',
    'projectile' : 'OilPuddle',
    'description' : 'Leave slippery puddles of finest grade oil'
};

exports.Napalm = {
    'damage' : 10,
    'type' : 'rear_weapon',
    'launcher' : 'MineLauncher',
    'projectile' : 'NapalmFlame',
    'fire_rate' : 160,
    'ammo_capacity' : 20,
    'ammo_upgrade' : 5,
    'ammo_upgrade_price' : 1000,
    'damage_upgrade' : 2,
    'damage_upgrade_price' : 1000,
    'name' : 'Napalm',
    'icon' : 'icon_flame.png',
    'price' : 2500,
    'description' : 'Burn your opponents to a crisp'
};

exports.PlasmaCannon = {
    'damage' : 12,
    'speed' : 500,
    'preload' : ['plasma_projectile.png'],
    'type' : 'front_weapon',
    'launcher' : 'PlasmaCannon',
    'projectile' : 'PlasmaProjectile',
    'fire_rate' : 400,
    'ammo_capacity' : 24,
    'damage_upgrade' : 3,
    'damage_upgrade_price' : 1500,
    'ammo_upgrade' : 6,
    'ammo_upgrade_price' : 1500,
    'name' : 'Plasma Cannon',
    'icon' : 'icon_plasma.png',
    'price' : 3000,
    'description' : 'Fires super heated blobs of pure plasma that will burn through anything'
};

exports.Shield = {
    'damage' : 0,
    'type' : 'util',
    'launcher' : 'Shield',
    'fire_rate' : 2000,
    'ammo_capacity' : 2,
    'ammo_upgrade' : 1,
    'ammo_upgrade_price' : 1000,
    'name' : 'Force Shield',
    'icon' : 'icon_shield.png',
    'price' : 2000,
    'duration' : 2000,
    'description' : 'Puts up a forcefield that absorbs 3 hits before disintegrating'
};

exports.Cannon = {
    'damage' : 60,
    'preload' : ['cannon_shell.png'],
    'type' : 'front_weapon',
    'launcher' : 'MissileLauncher',
    'projectile' : 'TankShell',
    'fire_rate' : 800,
    'speed' : 500,
    'ammo_capacity' : 10,
    'ammo_upgrade' : 3,
    'ammo_upgrade_price' : 1500,
    'damage_upgrade' : 10,
    'damage_upgrade_price' : 1500,
    'name' : 'Cannon',
    'icon' : 'icon_cannon.png',
    'price' : 4000,
    'description' : "Guns don't get bigger than this massive anti-tank cannon"
};

},{}],35:[function(require,module,exports){
var gamejs = require('gamejs');
var utils = require('./utils');
var sounds = require('./sounds');
var buffs = require('./buffs');
var vec=utils.vec;
var arr=utils.arr;
var weapon_descriptions=require('./weapon_descriptions');
var vectors = gamejs.utils.vectors;
var math = gamejs.utils.math;
var buffs = require('./buffs');
var engine = require('./engine');
var settings = require('./settings');
var box2d= engine.box2d;

radians=math.radians;
degrees=math.degrees;

var animation = require('./animation');

var fireAtNearbyTargets = function(){
    var i, c, len;
    var cars = this.world.get_objects_by_tag('car');
    for(i = 0; i < cars.length; i++){
        c = cars[i];
        if(c.id != this.car.id){
            len = vectors.distance(this.car.get_position(), c.get_position());
            if(len <= 10){
                return true;
            }
        }
    }
    return false;
};

var fireAtRearTargets = function(){
    var i, c, len, angle;
    var cars = this.world.get_objects_by_tag('car');
    for(i = 0; i < cars.length; i++){
        c = cars[i];
        if(c.id!=this.car.id){
            len = vectors.distance(this.car.get_position(), c.get_position());
            angle = degrees(vectors.angle([0, 1], this.car.get_local_point(c.get_position())));
            if(len < 20 && angle < 15){
                return true;
            }
        }
    }
    return false;
};

var fireAtFrontTargets = function(){
    var i, c, len, angle;
    var cars = this.world.get_objects_by_tag('car');
    for(i = 0; i < cars.length; i++){
        c = cars[i];
        if(c.id != this.car.id){
            len = vectors.distance(this.car.get_position(), c.get_position());
            angle = degrees(vectors.angle([0, -1], this.car.get_local_point(c.get_position())));
            if(len < 50 && angle < 15){
                return true;
            }
        }
    }
    return false;  
};

var Projectile = exports.Projectile = function(pars){
    /*
    pars:
    weapon   - weapon object
    position - [x, y]
    angle    - degrees
    width    - meters
    height   - meters
    damage   - damage, points
    */
   
    pars.fixed_rotation = true;
    pars.bullet = true;
    pars.linear_damping = 0;
    pars.angular_damping = 0;
    //pars.sensor = true;
    Projectile.superConstructor.apply(this, [pars]);
    this.weapon   = pars.weapon;
    this.speed    = pars.speed;
    this.damage   = pars.damage;
    this.position = pars.position;
    this.angle    = pars.angle;
    this.speed    = pars.speed;
    this.damage   = pars.damage;
    this.car      = pars.car;
    this.world    = this.car.world;
    this.add_tag('projectile');
    this.spent    = false;
    this.set_speed(this.speed);
};

gamejs.utils.objects.extend(Projectile, engine.Entity);


engine.register_class(Projectile);

Projectile.prototype.impact = function(obj, cpoint, direction) {
    if(obj.has_tag('solid') && (!this.spent)) {
        this.world.destroy(this);
        if(obj.has_tag('car')) {
            obj.apply_damage(this.damage, this.car);
            
        }
        if(this.onimpact)
            this.onimpact(obj);
        this.spent = true;
    }
};

Projectile.prototype.update = function(msDuration) {
    var pos = this.get_position();
    if((pos[0] < 0) || (pos[1] < 0) || (pos[0] > this.car.world.width) || (pos[1] > this.car.world.height)) {
        this.world.destroy(this);
    }
};


var Mine = exports.Mine = function(pars){
    /*
    pars:
    car   - car object
    position - [x, y]
    */
    pars.size = [2, 2];
    pars.sensor = true;
    pars.angle = 0;
    pars.fixed_rotation = true;
    Mine.superConstructor.apply(this, [pars]);
    this.car=pars.car;
    this.damage=pars.damage;
    this.add_tag('mine');
};

gamejs.utils.objects.extend(Mine, engine.Entity);

engine.register_class(Mine);

Mine.prototype.impact=function(obj, cpoint, direction){
        if((obj.has_tag('car'))){
            var i, c;
            this.world.get_objects_by_tag('car').forEach(function(c){
                if((c == obj) || (vectors.distance(this.position, c.get_position())<=8)){
                    c.apply_damage(this.damage, this.car);
                    utils.push(c, this, 15, 200);
                    if(this.onimpact) this.onimpact();
                }
            }, this);
            this.world.spawn_animation('explosion', this.position);
            this.world.play_sound('explosion.wav', this.position);
            this.world.destroy(this);
        }
    };

Mine.prototype.draw = function(renderer){
    renderer.drawStatic('mine.png', this.position);
};

var OilPuddle = exports.OilPuddle = function(pars){
    /*
    pars:
    car   - car object
    position - [x, y]
    */
    pars.size = [4.5, 3.5];
    pars.angle = 0;
    pars.sensor = true;
    pars.fixed_rotation = true;
    
    OilPuddle.superConstructor.apply(this, [pars]);   
    this.damage = pars.damage;
    this.car = this.parameters.car;
    this.drawn = false;
};

gamejs.utils.objects.extend(OilPuddle, engine.Entity);

engine.register_class(OilPuddle);

OilPuddle.prototype.impact = function(obj, cpoint, direction){
    if(obj.has_tag('car')){
        this.world.create(buffs.SlipDebuff, {'duration':weapon_descriptions.Oil.duration,
                                              'object':obj});
    }
};

OilPuddle.prototype.draw=function(renderer){
    if(!this.drawn){
        var sprite = renderer.cache.getStaticSprite('oil_spill.png');
        var sz = sprite.getSize();
        var phys_scale = settings.get('PHYS_SCALE');
        var pos= [this.position[0] * phys_scale, this.position[1] * phys_scale];
        renderer.background.blit(sprite, [pos[0]-sz[0]/2, pos[1]-sz[1]/2]);
        this.drawn=true;
    }
};


var Missile=exports.Missile=function(pars){
    /*
    pars:
    car   - car obj;
    position - [x, y]
    angle    - degrees
    */

    pars.size = [0.5, 2.5];
    pars.density = 0.3;
    this.tts=50;
    Missile.superConstructor.apply(this, [pars]);
    this.world.play_sound('missile_launch.wav', this.position);
};

gamejs.utils.objects.extend(Missile, Projectile);

engine.register_class(Missile);
    
Missile.prototype.onimpact = function(){
    var pos = this.get_position();
    this.world.spawn_animation('explosion',pos);
    this.world.play_sound('explosion.wav', pos);
};

Missile.prototype.draw = function(renderer){
    if(!this.spent) renderer.drawCar('missile.png', this.get_position(), this.get_angle());
};

Missile.prototype.update = function(msDuration){
    this.tts -= msDuration;
    if(this.tts<0){
        this.world.spawn_animation('smoke', this.get_world_point([0, 1.25]));
        this.tts = 50;
    }
};



var NapalmFlame = exports.NapalmFlame = function(pars) {
    
    //how often damage can be reapplied on the same flame
    pars.size = [4, 4];
    pars.sensor = true;
    pars.fixed_rotation = true;
    
    NapalmFlame.superConstructor.apply(this, [pars]);

    this.car = pars.car;
    this.life = 6000;
    this.damage = pars.damage;
    this.burn_cooldown = 200;
    this.burning = {};
    this.collapse = false;
    this.animation = new animation.Animation({
        'filename' : 'fire64.png',
        'duration' : 800,
        'repeat' : true
    });
    this.animation.resize(30, 64, 800);
};

gamejs.utils.objects.extend(NapalmFlame, engine.Entity);

engine.register_class(NapalmFlame);

NapalmFlame.prototype.impact = function(obj, cpoint, direction){
    if(obj.has_tag('car')){
        if(!this.burning[obj.id]){
        	obj.apply_damage(this.damage, this.car);
        	this.burning[obj.id] = this.burn_cooldown;
        }
    }
};
    
NapalmFlame.prototype.update = function(msDuration){
	for(var id in this.burning){
		this.burning[id] -= msDuration;
		if(this.burning[id] <0){
			delete this.burning[id];
		}
	}
	this.animation.update(msDuration);
	this.life -= msDuration;
	if(this.life <= 800 && (!this.collapse)){
		this.animation.resize(64, 30, 800);
		this.collapse=true;
	}
	
	if(this.life < 0) this.world.destroy(this);
};

NapalmFlame.prototype.draw = function(renderer){
    this.animation.draw(renderer, this.get_position());
};

var HomingMissile = exports.HomingMissile = function(pars){
    
    HomingMissile.superConstructor.apply(this, [pars]);
};

gamejs.utils.objects.extend(HomingMissile, Missile);

engine.register_class(HomingMissile);

HomingMissile.prototype.draw = function(renderer){
    if(!this.spent) renderer.drawCar('missile_homing.png', 
                                     this.get_position(),
                                     this.get_angle());
};
    
HomingMissile.prototype.update = function(msDuration){
    //spawn smoke
    this.tts -= msDuration;
    if(this.tts < 0 ){
        this.world.spawn_animation('smoke', this.get_world_point([0, 1.25]));
        this.tts = 50;
    }
    
    //drive the missile towards nearest front facing target
    var target = null;
    var target_distance = 1000000;
    this.world.objects_by_tag.car.forEach(function(car){
        var cpos = this.get_local_point(car.get_position());
        if(cpos[1]<0){
            var distance = gamejs.utils.vectors.distance(this.get_position(), car.get_position());
            if(target_distance > distance){
                target = car;
                target_distance = distance;
                
            }
        }
        return false;
    }, this);
    
    if(target){
        var cpos = this.get_local_point(target.get_position());
        var angle = gamejs.utils.math.radians(this.get_angle());
        if(cpos[0] < 0){
            angle += gamejs.utils.math.radians((-90 / 700) * msDuration);
        }else if(cpos[0] > 0){
            angle += gamejs.utils.math.radians((90 / 700) * msDuration);
        }
        this.set_angle(gamejs.utils.math.degrees(angle));
        
        this.set_speed(this.speed);
    }
    
};

var Bullet = exports.Bullet = function(pars){
    /*
    pars:
    car   - car obj
    position - [x, y]
    angle    - degrees
    */
    pars.size = [0.3, 0.8];
    pars.density = 0.1;
    Bullet.superConstructor.apply(this, [pars]);
    this.color = '#FFD800';
    this.world.play_sound('machinegun_shot.wav', this.position);
};

gamejs.utils.objects.extend(Bullet, Projectile);

engine.register_class(Bullet);

Bullet.prototype.onimpact = function(obj) {
    var pos = this.get_position();
    this.world.spawn_animation('small_explosion', pos);
    if(obj.has_tag('car')){
        this.world.play_sound('bullet_impact_metal.wav', pos);
    }else if(obj.has_tag('prop')){
        this.world.play_sound('bullet_impact_soft.wav', pos);
    }
};

Bullet.prototype.draw = function(renderer){
    if(!this.spent) renderer.drawCar('bullet.png', 
                                     this.get_position(), 
                                     this.get_angle());
};

var PlasmaProjectile = exports.PlasmaProjectile = function(pars){
    /*
    pars:
    car   - car obj
    position - [x, y]
    angle    - degrees
    */
    pars.size = [0.6, 2.5];
    pars.sensor = true;
    PlasmaProjectile.superConstructor.apply(this, [pars]);
};

gamejs.utils.objects.extend(PlasmaProjectile, Projectile);
engine.register_class(PlasmaProjectile);

PlasmaProjectile.prototype.impact = function(obj, cpoint, direction){
    if((obj.has_tag('car') || obj.has_tag('prop'))){
        if(obj.has_tag('car')){
            obj.apply_damage(this.damage, this.car);
        }
        if(this.onimpact) this.onimpact(obj);
    }
};

PlasmaProjectile.prototype.onimpact = function(obj){
    var pos = this.get_position();
    this.world.spawn_animation('small_explosion', pos);
};

PlasmaProjectile.prototype.draw = function(renderer){
    if(!this.spent) renderer.drawCar('plasma_projectile.png', 
                                      this.get_position(), 
                                      this.get_angle());
};

var Weapon = exports.Weapon = function(pars){
    pars = this.pars = utils.copy(pars, utils.copy(weapon_descriptions[pars.type], {}));
    Weapon.superConstructor.apply(this, [pars]);
    this.type = pars.type;
    this.add_tag('weapon');
    this.car = pars.car;
    this.car[pars.slot] = this;
    this.ammo_capacity = pars.ammo_capacity+(pars.ammo_upgrades*pars.ammo_upgrade);
    this.fire_rate = pars.fire_rate;
    this.cooldown = 0;
    this.ammo = 0;
    this.damage = pars.damage+(pars.damage_upgrades*pars.damage_upgrade);
    this.speed = pars.speed;
    this.projectile = pars.projectile;
};
gamejs.utils.objects.extend(Weapon, engine.Object);

engine.register_class(Weapon);

Weapon.prototype.update = function(msDuration) {
    if(this.cooldown > 0) this.cooldown -= msDuration;
};

Weapon.prototype.reload = function(){
    this.ammo = this.ammo_capacity;
};

Weapon.prototype._fire = function(){
    if(this.ammo && this.cooldown<=0){
        this.fire();
        this.ammo--;
        this.cooldown = this.fire_rate;
    }
};

Weapon.prototype.AI = function(){ return false; };
    
Weapon.prototype.fire = function(){
    var pos = this.get_fire_pos();
    this.world.create(exports[this.projectile], {'position':pos,
                                                 'damage':this.damage,
                                                 'weapon':this,
                                                 'speed':this.speed,
                                                 'angle':this.car.get_angle(),
                                                 'car':this.car});     
};
    
Weapon.prototype.get_fire_pos = function(){
    var retv = this.car.get_world_point([0, -(this.car.size[1]/2+3)]);
    return retv;
};


var RepairKit = exports.RepairKit = function(pars){
    RepairKit.superConstructor.apply(this, [pars]);
    this.add_tag('repairkit');
};

gamejs.utils.objects.extend(RepairKit, Weapon);

engine.register_class(RepairKit);
    
RepairKit.prototype.AI = function() {
    if(this.car.health <= this.car.max_health / 2){
        return true;
    }
    return false;
};
    
RepairKit.prototype._fire = function() {
    if(this.ammo&&(this.cooldown<=0) && (this.car.health<this.car.max_health)){
        this.fire();
        this.ammo--;
        this.cooldown = this.fire_rate;
    }
};
    
RepairKit.prototype.fire = function(){
    this.world.spawn_animation('heal', this.car.get_position(), this.car);
    this.world.play_sound('repair.wav', this.car.get_position());
    this.car.apply_damage(-this.damage, this.car);
};


var Machinegun=exports.Machinegun=function(pars){
    /*
    pars:
    car - car object this weapon belongs to
    */
    Machinegun.superConstructor.apply(this, [pars]);
    this.add_tag('machinegun');
    this.ofst_x = -0.5;
};

gamejs.utils.objects.extend(Machinegun, Weapon);

engine.register_class(Machinegun);

Machinegun.prototype.AI = fireAtFrontTargets;

Machinegun.prototype.get_fire_pos = function(){
    this.ofst_x *= -1;
    return this.car.get_world_point([this.ofst_x, -(this.car.parameters.size[1] / 2 + 0.9)]);
};

var PlasmaCannon = exports.PlasmaCannon = function(pars){

    PlasmaCannon.superConstructor.apply(this, [pars]);
    
    this.add_tag('plasmacannon');

    this.AI=fireAtFrontTargets;
};

gamejs.utils.objects.extend(PlasmaCannon, Weapon);

engine.register_class(PlasmaCannon);

PlasmaCannon.prototype.fire = function(){
    var pos = this.car.get_world_point([-0.6, -(this.car.parameters.size[1]/2+3)]);
    this.world.create(exports[this.projectile], {'position':pos,
                                                'damage':this.damage,
                                                'speed':this.speed,
                                                'weapon':this,
                                                'angle':this.car.get_angle(),
                                                'car':this.car});
    if(this.ammo){
        var pos = this.car.get_world_point([0.6, -(this.car.parameters.size[1]/2+3)]);
        this.world.create(exports[this.projectile], {'position':pos,
                                            'damage':this.damage,
                                            'speed':this.speed,
                                            'weapon':this,
                                            'angle':this.car.get_angle(),
                                            'car':this.car});
        this.ammo--;
    }
    this.world.play_sound('plasma_cannon.wav');
};

var NOS = exports.NOS = function(pars){
    NOS.superConstructor.apply(this, [pars]);
    this.duration = this.parameters.duration;
    this.add_tag('nos');
};

gamejs.utils.objects.extend(NOS, Weapon);

engine.register_class(NOS);
   
NOS.prototype.AI = function(){
    if(this.car.get_speed_KMH() > this.car.get_max_speed()-10){
        return true;
    }
    return false;
};

NOS.prototype.fire = function(){
    this.world.create(buffs.EngineBuff,{'duration':this.duration,
                                        'value':this.damage,
                                        'object':this.car});
};

var ShockwaveGenerator = exports.ShockwaveGenerator = function(pars){
    ShockwaveGenerator.superConstructor.apply(this, [pars]);
    this.add_tag('shockwave')
};

gamejs.utils.objects.extend(ShockwaveGenerator, Weapon);

engine.register_class(ShockwaveGenerator);

ShockwaveGenerator.prototype.AI = fireAtNearbyTargets;
    
ShockwaveGenerator.prototype.fire = function(){
    this.world.get_objects_by_tag('solid').forEach(function(obj){
        if(obj.id != this.car.id){
            var tp = this.car.get_position();
            var cp= obj.get_position();
            var d = vectors.distance(tp, cp);
            if(d <= 12){
                obj.apply_damage(this.damage, this.car);
                utils.push(obj, this.car, 40, 500);
            };
        }
    }, this);
    
    this.world.play_sound('shockwave.wav', this.car.get_position());
    this.world.spawn_animation('shockwave', this.car.get_position(), this.car);
    
};

var MineLauncher = exports.MineLauncher=function(pars){
    MineLauncher.superConstructor.apply(this, [pars]);
    this.add_tag('minelauncher');
};

gamejs.utils.objects.extend(MineLauncher, Weapon);

engine.register_class(MineLauncher);
    
MineLauncher.prototype.AI = fireAtRearTargets;
    
MineLauncher.prototype.get_fire_pos=function(){
    return this.car.get_world_point([0, (this.car.parameters.size[1] / 2 + 3)]);  
};

var MissileLauncher = exports.MissileLauncher = function(pars){
    MineLauncher.superConstructor.apply(this, [pars]);
    this.add_tag('missilelauncher');
};

gamejs.utils.objects.extend(MissileLauncher, Weapon);

engine.register_class(MissileLauncher);
   
MissileLauncher.prototype.AI = fireAtFrontTargets;
    
MissileLauncher.prototype.get_fire_pos=function(){
    return this.car.get_world_point([0, -(this.car.parameters.size[1] / 2 + 3)]);    
};

var Oil = exports.Oil = function(pars){
    Oil.superConstructor.apply(this, [pars]);
    this.add_tag('oil');
};

gamejs.utils.objects.extend(Oil, Weapon);

engine.register_class(Oil);
    
Oil.prototype.AI = fireAtRearTargets;

Oil.prototype.get_fire_pos = function(){
    return this.car.get_world_point([0, (this.car.parameters.size[1]/2+3)]);    
};

var Shield=exports.Shield=function(pars){
    Shield.superConstructor.apply(this, [pars]);
    this.duration = pars.duration;
    this.add_tag('shield');
};

gamejs.utils.objects.extend(Shield, Weapon);

engine.register_class(Shield);
    
Shield.prototype.AI = function(){
    if(this.car.health <= this.car.max_health/3){
        return true;
    }
    return false;
};
    
Shield.prototype._fire=function(){
    if(this.ammo && (this.cooldown <= 0)){
        this.fire();
        this.ammo--;
        this.cooldown = this.fire_rate;
    }
};
    
Shield.prototype.fire=function(){
    this.car.world.create(buffs.InvulnerabilityBuff, {'object':this.car});
};



var TankShell = exports.TankShell = function(pars){
    pars.size = [0.8, 1.5];
    TankShell.superConstructor.apply(this, [pars]);
	this.add_tag('tank_shell');
	this.world.play_sound('fire_cannon.wav', this.position);
};

gamejs.utils.objects.extend(TankShell, Projectile);

engine.register_class(TankShell);
	
TankShell.prototype.impact = function(obj, cpoint, direction){
    if((obj.has_tag('car') || obj.has_tag('prop')) && (!this.spent)){
        this.world.destroy(this);
        this.world.get_objects_by_tag('car').forEach(function(car){
            if(car.id != this.car.id){
                var tp = this.get_position();
                var cp = car.get_position();
                var d = vectors.distance(tp, cp);
                if(d <= 5){
                    car.apply_damage(this.damage, this.car);
                    this.world.create(buffs.SlipDebuff, {'duration':500,
                                                         'object':car});
                    var fvect = vectors.unit(vectors.subtract(cp, tp));
                    fvect=vectors.multiply(fvect, 200);
                    car.apply_impulse(fvect, car.get_position());
                };
            }
        }, this);
        
        this.spent = true;
        this.world.spawn_animation('explosion2', this.get_position());
        this.world.play_sound('explosion.wav', this.position);
    }
};

TankShell.prototype.draw = function(renderer){
    if(!this.spent) renderer.drawCar('cannon_shell.png',  this.get_position(), this.get_angle());
};


},{"./animation":1,"./buffs":3,"./engine":9,"./settings":28,"./sounds":30,"./utils":33,"./weapon_descriptions":34,"gamejs":37}],36:[function(require,module,exports){
var utils = require('./utils');
var vec=utils.vec;
var arr=utils.arr;
var weapon_descriptions=require('./weapon_descriptions');
var combatracer=require('./combatracer');
var car_descriptions=require('./car_descriptions');
var cars=require('./cars');
var weapons=require('./weapons');
var animation=require('./animation');
var props=require('./props');
var settings=require('./settings');
var gamejs=require('gamejs');
var sounds=require('./sounds');
var renderer=require('./renderer');
var buffs=require('./buffs');
var vectors = gamejs.utils.vectors;
var math = gamejs.utils.math;
var engine = require('./engine');

radians=math.radians;
degrees=math.degrees;



var MODE_CLIENT = exports.MODE_CLIENT = 1;
var MODE_SERVER = exports.MODE_SERVER = 2;
var MODE_STANDALONE = exports.MODE_STANDALONE = 3;

var World = exports.World = function(parameters){
    
    var par_list = ['width',
                    'height',
                    'ai_waypoints',
                    'checkpoints',
                    'start_positions',
                    'mode'];
    
    engine.utils.process_parameters(parameters, par_list);
    this.parameters = parameters;
    
    World.superConstructor.apply(this, [parameters]);
    
    this.width = parameters.width;
    this.height = parameters.height;
    this.size = [this.width, this.height];
    this.ai_waypoints = parameters.ai_waypoints;
    this.checkpoints = parameters.checkpoints;
    this.start_positions = parameters.start_positions;
    this.mode = parameters.mode;
    
    this.max_waypoint=0;
    for(var no in this.ai_waypoints) this.max_waypoint=Math.max(this.max_waypoint, no);
    
    this.max_checkpoint=0;
    for(var no in this.checkpoints) this.max_checkpoint=Math.max(this.max_checkpoint, no);
};

gamejs.utils.objects.extend(World, engine.World);

World.prototype.spawn_animation = function(anim_name, position, follow_obj){
    this.create(animation.AnimationObject, utils.copy(animation.animations[anim_name], {'position':position,
                                                                                        'follow_obj':follow_obj}));
};

World.prototype.play_sound = function(filename, position){
    if(settings.get('sound')) engine.World.prototype.play_sound.apply(this, ['sounds/fx/'+filename, position]);
};

exports.build_world = function(level, mode) {
    //level - data property of level module

    var phys_scale = settings.get('PHYS_SCALE');

    var dict = level.dict;

    //CAR POSITIONS
    var start_positions = {};
    level.start_positions.forEach(function(pos) {
        start_positions[pos.n] = {
            'x' : (pos.p[0] + 30) / phys_scale,
            'y' : (pos.p[1] + 30) / phys_scale,
            'angle' : pos.a
        }
    });
    //WAYPOINTS
    var ai_waypoints = {};
    level.ai_waypoints.forEach(function(wp) {
        ai_waypoints[wp.n] = {
            'x' : (wp.p[0] + 20) / phys_scale,
            'y' : (wp.p[1] + 20) / phys_scale
        };
    });
    //CHECKPOINTS
    var checkpoints = {}, pt1, pt2;
    level.checkpoints.forEach(function(c) {
        pt1 = [c.p[0] / phys_scale, c.p[1] / phys_scale];
        pt2 = [(c.p[0] + 280) / phys_scale, (c.p[1] + 280) / phys_scale];
        ;
        checkpoints[c.n] = {
            'pt1' : pt1,
            'pt2' : pt2,
            'width' : pt2[0] - pt1[0],
            'height' : pt2[1] - pt1[1],
            'center' : [(pt1[0] + pt2[0]) / 2, (pt1[1] + pt2[1]) / 2]
        };
    });
    //BUILD WORLD

    var width = level.size[0] / phys_scale;
    var height = level.size[1] / phys_scale;

    var world = new World({
        'width' : width,
        'height' : height,
        'ai_waypoints' : ai_waypoints,
        'checkpoints' : checkpoints,
        'start_positions' : start_positions,
        'mode' : mode
    });

    //BUILD PROPS
    var position, angle, s, sz, sz2, ws;
    level.props.forEach(function(prop) {
        angle = math.normaliseDegrees(prop.a);
        s = renderer.cache.getPropSprite(dict[prop.f], angle);
        sz = s.getSize();
        s = renderer.cache.props[dict[prop.f]].orig;
        sz2 = s.getSize();
        ws = [sz2[0] / phys_scale, sz2[1] / phys_scale];
        world.create(props.BoxProp, {
            'filename' : dict[prop.f],
            'position' : [((prop.p[0] + sz[0] / 2) / phys_scale), ((prop.p[1] + sz[1] / 2) / phys_scale)],
            'angle' : angle,
            'size' : ws
        });
    });
    return world;
}


},{"./animation":1,"./buffs":3,"./car_descriptions":4,"./cars":5,"./combatracer":6,"./engine":9,"./props":25,"./renderer":26,"./settings":28,"./sounds":30,"./utils":33,"./weapon_descriptions":34,"./weapons":35,"gamejs":37}],37:[function(require,module,exports){
var matrix = require('./gamejs/utils/matrix');
var objects = require('./gamejs/utils/objects');
var Callback = require('./gamejs/callback').Callback;

/**
 * @fileoverview This module holds the essential `Rect` and `Surface` classes as
 * well as static methods for preloading assets. `gamejs.ready()` is maybe
 * the most important as it kickstarts your app.
 *
 * Your game should provide callbacks for `gamejs.onEvent` to handle events.
 * To get called continuously, provide a callback to `gamejs.onTick.
 *
 */

var DEBUG_LEVELS = ['info', 'warn', 'error', 'fatal'];
var debugLevel = 2;

/**
 * set logLevel as string or number
 *   * 0 = info
 *   * 1 = warn
 *   * 2 = error
 *   * 3 = fatal
 *
 * @example
 * gamejs.setLogLevel(0); // debug
 * gamejs.setLogLevel('error'); // equal to setLogLevel(2)
 */
exports.setLogLevel = function(logLevel) {
   if (typeof logLevel === 'string' && DEBUG_LEVELS.indexOf(logLevel)) {
      debugLevel = DEBUG_LEVELS.indexOf(logLevel);
   } else if (typeof logLevel === 'number') {
      debugLevel = logLevel;
   } else {
      throw new Error('invalid logLevel ', logLevel, ' Must be one of: ', DEBUG_LEVELS);
   }
   return debugLevel;
};
/**
 * Log a msg to the console if console is enable
 * @param {String} msg the msg to log
 */
var log = exports.log = function() {

   if (gamejs.worker.inWorker === true) {
      gamejs.worker._logMessage(arguments);
      return;
   }

   // IEFIX can't call apply on console
   var args = Array.prototype.slice.apply(arguments, [0]);
   args.unshift(Date.now());
   if (window.console !== undefined && console.log.apply) {
      console.log.apply(console, args);
   }
};
exports.info = function() {
   if (debugLevel <= DEBUG_LEVELS.indexOf('info')) {
      log.apply(this, arguments);
   }
};
exports.warn = function() {
   if (debugLevel <= DEBUG_LEVELS.indexOf('warn')) {
      log.apply(this, arguments);
   }
};
exports.error = function() {
   if (debugLevel <= DEBUG_LEVELS.indexOf('error')) {
      log.apply(this, arguments);
   }
};
exports.fatal = function() {
   if (debugLevel <= DEBUG_LEVELS.indexOf('fatal')) {
      log.apply(this, arguments);
   }
};

/**
 * Normalize various ways to specify a Rect into {left, top, width, height} form.
 *
 */
function normalizeRectArguments() {
   var left = 0;
   var top = 0;
   var width = 0;
   var height = 0;

   if (arguments.length === 2) {
      if (arguments[0] instanceof Array && arguments[1] instanceof Array) {
         left = arguments[0][0];
         top = arguments[0][1];
         width = arguments[1][0];
         height = arguments[1][1];
      } else {
         left = arguments[0];
         top = arguments[1];
      }
   } else if (arguments.length === 1 && arguments[0] instanceof Array) {
      left = arguments[0][0];
      top = arguments[0][1];
      width = arguments[0][2];
      height = arguments[0][3];
   } else if (arguments.length === 1 && arguments[0] instanceof Rect) {
      left = arguments[0].left;
      top = arguments[0].top;
      width = arguments[0].width;
      height = arguments[0].height;
   } else if (arguments.length === 4) {
      left = arguments[0];
      top = arguments[1];
      width = arguments[2];
      height = arguments[3];
   } else {
      throw new Error('not a valid rectangle specification');
   }
   return {left: left || 0, top: top || 0, width: width || 0, height: height || 0};
}

/**
 * Creates a Rect. Rects are used to hold rectangular areas. There are a couple
 * of convinient ways to create Rects with different arguments and defaults.
 *
 * Any function that requires a `gamejs.Rect` argument also accepts any of the
 * constructor value combinations `Rect` accepts.
 *
 * Rects are used a lot. They are good for collision detection, specifying
 * an area on the screen (for blitting) or just to hold an objects position.
 *
 * The Rect object has several virtual attributes which can be used to move and align the Rect:
 *
 *   top, left, bottom, right
 *   topleft, bottomleft, topright, bottomright
 *   center
 *   width, height
 *   w,h
 *
 * All of these attributes can be assigned to.
 * Assigning to width or height changes the dimensions of the rectangle; all other
 * assignments move the rectangle without resizing it. Notice that some attributes
 * are Numbers and others are pairs of Numbers.
 *
 * @example
 * new Rect([left, top]) // width & height default to 0
 * new Rect(left, top) // width & height default to 0
 * new Rect(left, top, width, height)
 * new Rect([left, top], [width, height])
 * new Rect(oldRect) // clone of oldRect is created
 *
 * @property {Number} right
 * @property {Number} bottom
 * @property {Number} center
 *
 * @param {Array|gamejs.Rect} position Array holding left and top coordinates
 * @param {Array} dimensions Array holding width and height
 */
var Rect = exports.Rect = function() {

   var args = normalizeRectArguments.apply(this, arguments);

   /**
    * Left, X coordinate
    * @type Number
    */
   this.left = args.left;

   /**
    * Top, Y coordinate
    * @type Number
    */
   this.top = args.top;

   /**
    * Width of rectangle
    * @type Number
    */
   this.width = args.width;

   /**
    * Height of rectangle
    * @type Number
    */
   this.height = args.height;

   return this;
};

objects.accessors(Rect.prototype, {
   /**
    * Bottom, Y coordinate
    * @name Rect.prototype.bottom
    * @type Number
    */
   'bottom': {
      get: function() {
         return this.top + this.height;
      },
      set: function(newValue) {
         this.top = newValue - this.height;
         return;
      }
   },
   /**
    * Right, X coordinate
    * @name Rect.prototype.right
    * @type Number
    */
   'right': {
      get: function() {
         return this.left + this.width;
      },
      set: function(newValue) {
         this.left = newValue - this.width;
      }
   },
   /**
    * Center Position. You can assign a rectangle form.
    * @name Rect.prototype.center
    * @type Array
    */
   'center': {
      get: function() {
         return [this.left + (this.width / 2) | 0,
                 this.top + (this.height / 2) | 0
                ];
      },
      set: function() {
         var args = normalizeRectArguments.apply(this, arguments);
         this.left = args.left - (this.width / 2) | 0;
         this.top = args.top - (this.height / 2) | 0;
         return;
      }
   },
   /**
    * Top-left Position. You can assign a rectangle form.
    * @name Rect.prototype.topleft
    * @type Array
    */
   'topleft': {
      get: function() {
         return [this.left, this.top];
      },
      set: function() {
         var args = normalizeRectArguments.apply(this, arguments);
         this.left = args.left;
         this.top = args.top;
         return;
      }
   },
   /**
    * Bottom-left Position. You can assign a rectangle form.
    * @name Rect.prototype.bottomleft
    * @type Array
    */
   'bottomleft': {
      get: function() {
         return [this.left, this.bottom];
      },
      set: function() {
         var args = normalizeRectArguments.apply(this, arguments);
         this.left = args.left;
         this.bottom = args.top;
         return;
      }
   },
   /**
    * Top-right Position. You can assign a rectangle form.
    * @name Rect.prototype.topright
    * @type Array
    */
   'topright': {
      get: function() {
         return [this.right, this.top];
      },
      set: function() {
         var args = normalizeRectArguments.apply(this, arguments);
         this.right = args.left;
         this.top = args.top;
         return;
      }
   },
   /**
    * Bottom-right Position. You can assign a rectangle form.
    * @name Rect.prototype.bottomright
    * @type Array
    */
   'bottomright': {
      get: function() {
         return [this.right, this.bottom];
      },
      set: function() {
         var args = normalizeRectArguments.apply(this, arguments);
         this.right = args.left;
         this.bottom = args.top;
         return;
      }
   },
   /**
    * Position x value, alias for `left`.
    * @name Rect.prototype.y
    * @type Array
    */
   'x': {
      get: function() {
         return this.left;
      },
      set: function(newValue) {
         this.left = newValue;
         return;
      }
   },
   /**
    * Position y value, alias for `top`.
    * @name Rect.prototype.y
    * @type Array
    */
   'y': {
      get: function() {
         return this.top;
      },
      set: function(newValue) {
         this.top = newValue;
         return;
      }
   }
});

/**
 * Move returns a new Rect, which is a version of this Rect
 * moved by the given amounts. Accepts any rectangle form.
 * as argument.
 *
 * @param {Number|gamejs.Rect} x amount to move on x axis
 * @param {Number} y amount to move on y axis
 */
Rect.prototype.move = function() {
   var args = normalizeRectArguments.apply(this, arguments);
   return new Rect(this.left + args.left, this.top + args.top, this.width, this.height);
};

/**
 * Move this Rect in place - not returning a new Rect like `move(x, y)` would.
 *
 * `moveIp(x,y)` or `moveIp([x,y])`
 *
 * @param {Number|gamejs.Rect} x amount to move on x axis
 * @param {Number} y amount to move on y axis
 */
Rect.prototype.moveIp = function() {
   var args = normalizeRectArguments.apply(this, arguments);
   this.left += args.left;
   this.top += args.top;
   return;
};

/**
 * Return the area in which this Rect and argument Rect overlap.
 *
 * @param {gamejs.Rect} Rect to clip this one into
 * @returns {gamejs.Rect} new Rect which is completely inside the argument Rect,
 * zero sized Rect if the two rectangles do not overlap
 */
Rect.prototype.clip = function(rect) {
   if(!this.collideRect(rect)) {
      return new Rect(0,0,0,0);
   }

   var x, y, width, height;

   // Left
   if ((this.left >= rect.left) && (this.left < rect.right)) {
      x = this.left;
   } else if ((rect.left >= this.left) && (rect.left < this.right)) {
      x = rect.left;
   }

   // Right
   if ((this.right > rect.left) && (this.right <= rect.right)) {
      width = this.right - x;
   } else if ((rect.right > this.left) && (rect.right <= this.right)) {
      width = rect.right - x;
   }

   // Top
   if ((this.top >= rect.top) && (this.top < rect.bottom)) {
      y = this.top;
   } else if ((rect.top >= this.top) && (rect.top < this.bottom)) {
      y = rect.top;
   }

   // Bottom
   if ((this.bottom > rect.top) && (this.bottom <= rect.bottom)) {
     height = this.bottom - y;
   } else if ((rect.bottom > this.top) && (rect.bottom <= this.bottom)) {
     height = rect.bottom - y;
   }
   return new Rect(x, y, width, height);
};

/**
 * Join two rectangles
 *
 * @param {gamejs.Rect} union with this rectangle
 * @returns {gamejs.Rect} rectangle containing area of both rectangles
 */
Rect.prototype.union = function(rect) {
   var x, y, width, height;

   x = Math.min(this.left, rect.left);
   y = Math.min(this.top, rect.top);
   width = Math.max(this.right, rect.right) - x;
   height = Math.max(this.bottom, rect.bottom) - y;
   return new Rect(x, y, width, height);
};

/**
 * Grow or shrink the rectangle size
 *
 * @param {Number} amount to change in the width
 * @param {Number} amount to change in the height
 * @returns {gamejs.Rect} inflated rectangle centered on the original rectangle's center
 */
Rect.prototype.inflate = function(x, y) {
    var copy = this.clone();

    copy.inflateIp(x, y);

    return copy;
};

/**
 * Grow or shrink this Rect in place - not returning a new Rect like `inflate(x, y)` would.
 *
 * @param {Number} amount to change in the width
 * @param {Number} amount to change in the height
 */
Rect.prototype.inflateIp = function(x, y) {
    // Use Math.floor here to deal with rounding of negative numbers the
    // way this relies on.
    this.left -= Math.floor(x / 2);
    this.top -= Math.floor(y / 2);
    this.width += x;
    this.height += y;
};

/**
 * Check for collision with a point.
 *
 * `collidePoint(x,y)` or `collidePoint([x,y])` or `collidePoint(new Rect(x,y))`
 *
 * @param {Array|gamejs.Rect} point the x and y coordinates of the point to test for collision
 * @returns {Boolean} true if the point collides with this Rect
 */
Rect.prototype.collidePoint = function() {
   var args = normalizeRectArguments.apply(this, arguments);
   return (this.left <= args.left && args.left <= this.right) &&
       (this.top <= args.top && args.top <= this.bottom);
};

/**
 * Check for collision with a Rect.
 * @param {gamejs.Rect} rect the Rect to test check for collision
 * @returns {Boolean} true if the given Rect collides with this Rect
 */
Rect.prototype.collideRect = function(rect) {
   return !(this.left > rect.right || this.right < rect.left ||
      this.top > rect.bottom || this.bottom < rect.top);
};

/**
 * @param {Array} pointA start point of the line
 * @param {Array} pointB end point of the line
 * @returns true if the line intersects with the rectangle
 * @see http://stackoverflow.com/questions/99353/how-to-test-if-a-line-segment-intersects-an-axis-aligned-rectange-in-2d/293052#293052
 *
 */
Rect.prototype.collideLine = function(p1, p2) {
   var x1 = p1[0];
   var y1 = p1[1];
   var x2 = p2[0];
   var y2 = p2[1];

   function linePosition(point) {
      var x = point[0];
      var y = point[1];
      return (y2 - y1) * x + (x1 - x2) * y + (x2 * y1 - x1 * y2);
   }

   var relPoses = [[this.left, this.top],
                   [this.left, this.bottom],
                   [this.right, this.top],
                   [this.right, this.bottom]
                  ].map(linePosition);

   var noNegative = true;
   var noPositive = true;
   var noZero = true;
   relPoses.forEach(function(relPos) {
      if (relPos > 0) {
         noPositive = false;
      } else if (relPos < 0) {
         noNegative = false;
      } else if (relPos === 0) {
         noZero = false;
      }
   }, this);

   if ( (noNegative || noPositive) && noZero) {
      return false;
   }
   return !((x1 > this.right && x2 > this.right) ||
            (x1 < this.left && x2 < this.left) ||
            (y1 < this.top && y2 < this.top) ||
            (y1 > this.bottom && y2 > this.bottom)
            );
};

/**
 * @returns {String} Like "[x, y][w, h]"
 */
Rect.prototype.toString = function() {
   return ["[", this.left, ",", this.top, "]"," [",this.width, ",", this.height, "]"].join("");
};

/**
 * @returns {gamejs.Rect} A new copy of this rect
 */
Rect.prototype.clone = function() {
   return new Rect(this);
};

/**
 * A Surface represents a bitmap image with a fixed width and height. The
 * most important feature of a Surface is that they can be `blitted`
 * onto each other.
 *
 * @example
 * new gamejs.Surface([width, height]);
 * new gamejs.Surface(width, height);
 * new gamejs.Surface(rect);
 * @constructor
 *
 * @param {Array} dimensions Array holding width and height
 */
var Surface = exports.Surface = function() {
   var args = normalizeRectArguments.apply(this, arguments);
   var width = args.left;
   var height = args.top;
   // unless argument is rect:
   if (arguments.length == 1 && arguments[0] instanceof Rect) {
      width = args.width;
      height = args.height;
   }
   // only for rotatation & scale
   /** @ignore */
   this._matrix = matrix.identity();
   /** @ignore */
	this._canvas = document.createElement("canvas");
	this._canvas.width = width;
	this._canvas.height = height;
	/** @ignore */
	this._blitAlpha = 1.0;

   /** @ignore */
   this._context = this._canvas.getContext('2d');
   // using exports is weird but avoids circular require
   if (exports.display._isSmoothingEnabled()) {
      this._smooth();
   } else {
      this._noSmooth();
   }
   return this;
};

/** @ignore */
Surface.prototype._noSmooth = function() {
	// disable image scaling
	// see https://developer.mozilla.org/en/Canvas_tutorial/Using_images#Controlling_image_scaling_behavior
	// and https://github.com/jbuck/processing-js/commit/65de16a8340c694cee471a2db7634733370b941c
	this.context.mozImageSmoothingEnabled = false;
  this.context.webkitImageSmoothingEnabled = false;
   return;
};
/** @ignore */
Surface.prototype._smooth = function() {
  this.context.mozImageSmoothingEnabled = true;
  this.context.webkitImageSmoothingEnabled = true;

};

/**
 * Blits another Surface on this Surface. The destination where to blit to
 * can be given (or it defaults to the top left corner) as well as the
 * Area from the Surface which should be blitted (e.g., for cutting out parts of
 * a Surface).
 *
 * @example
 * // blit flower in top left corner of display
 * displaySurface.blit(flowerSurface);
 *
 * // position flower at 10/10 of display
 * displaySurface.blit(flowerSurface, [10, 10])
 *
 * // ... `dest` can also be a rect whose topleft position is taken:
 * displaySurface.blit(flowerSurface, new gamejs.Rect([10, 10]);
 *
 * // only blit half of the flower onto the display
 * var flowerRect = flowerSurface.rect;
 * flowerRect = new gamejs.Rect([0,0], [flowerRect.width/2, flowerRect.height/2])
 * displaySurface.blit(flowerSurface, [0,0], flowerRect);
 *
 * @param {gamejs.Surface} src The Surface which will be blitted onto this one
 * @param {gamejs.Rect|Array} dst the Destination x, y position in this Surface.
 *            If a Rect is given, it's top and left values are taken. If this argument
 *            is not supplied the blit happens at [0,0].
 * @param {gamesjs.Rect|Array} area the Area from the passed Surface which
 *            should be blitted onto this Surface.
 * @param {Number} compositionOperation how the source and target surfaces are composited together; one of: source-atop, source-in, source-out, source-over (default), destination-atop, destination-in, destination-out, destination-over, lighter, copy, xor; for an explanation of these values see: http://dev.w3.org/html5/2dcontext/#dom-context-2d-globalcompositeoperation
 * @returns {gamejs.Rect} Rect actually repainted FIXME actually return something?
 */
Surface.prototype.blit = function(src, dest, area, compositeOperation) {

   var rDest, rArea;

   if (dest instanceof Rect) {
      rDest = dest.clone();
      var srcSize = src.getSize();
      if (!rDest.width) {
         rDest.width = srcSize[0];
      }
      if (!rDest.height) {
         rDest.height = srcSize[1];
      }
    } else if (dest && dest instanceof Array && dest.length == 2) {
      rDest = new Rect(dest, src.getSize());
    } else {
      rDest = new Rect([0,0], src.getSize());
    }
   compositeOperation = compositeOperation || 'source-over';

   // area within src to be drawn
   if (area instanceof Rect) {
      rArea = area;
   } else if (area && area instanceof Array && area.length == 2) {
      var size = src.getSize();
      rArea = new Rect(area, [size[0] - area[0], size[1] - area[1]]);
   } else {
      rArea = new Rect([0,0], src.getSize());
   }

   if (isNaN(rDest.left) || isNaN(rDest.top) || isNaN(rDest.width) || isNaN(rDest.height)) {
      throw new Error('[blit] bad parameters, destination is ' + rDest);
   }

   this.context.save();
   this.context.globalCompositeOperation = compositeOperation;
   // first translate, then rotate
   var m = matrix.translate(matrix.identity(), rDest.left, rDest.top);
   m = matrix.multiply(m, src._matrix);
   this.context.transform(m[0], m[1], m[2], m[3], m[4], m[5]);
   // drawImage(image, sx, sy, sWidth, sHeight, dx, dy, dWidth, dHeight)
   this.context.globalAlpha = src._blitAlpha;
   this.context.drawImage(src.canvas, rArea.left, rArea.top, rArea.width, rArea.height, 0, 0, rDest.width, rDest.height);
   this.context.restore();
   return;
};

/**
 * @returns {Number[]} the width and height of the Surface
 */
Surface.prototype.getSize = function() {
   return [this.canvas.width, this.canvas.height];
};

/**
 * Obsolte, only here for compatibility.
 * @deprecated
 * @ignore
 * @returns {gamejs.Rect} a Rect of the size of this Surface
 */
Surface.prototype.getRect = function() {
   return new Rect([0,0], this.getSize());
};

/**
 * Fills the whole Surface with a color. Usefull for erasing a Surface.
 * @param {String} CSS color string, e.g. '#0d120a' or '#0f0' or 'rgba(255, 0, 0, 0.5)'
 * @param {gamejs.Rect} a Rect of the area to fill (defauts to entire surface if not specified)
 */
Surface.prototype.fill = function(color, rect) {
   this.context.save();
   this.context.fillStyle = color || "#000000";
   if (rect === undefined) {
       rect = new Rect(0, 0, this.canvas.width, this.canvas.height);
    }

   this.context.fillRect(rect.left, rect.top, rect.width, rect.height);
   this.context.restore();
   return;
};

/**
 * Clear the surface.
 */
Surface.prototype.clear = function(rect) {
   var size = this.getSize();
   rect = rect || new Rect(0, 0, size[0], size[1]);
   this.context.clearRect(rect.left, rect.top, rect.width, rect.height);
   return;
};

objects.accessors(Surface.prototype, {
   /**
    * @type gamejs.Rect
    */
   'rect': {
      get: function() {
         return this.getRect();
      }
   },
   /**
    * @ignore
    */
   'context': {
      get: function() {
         return this._context;
      }
   },
   'canvas': {
      get: function() {
         return this._canvas;
      }
   }
});

/**
 * @returns {gamejs.Surface} a clone of this surface
 */
Surface.prototype.clone = function() {
  var newSurface = new Surface(this.getRect());
  newSurface.blit(this);
  return newSurface;
};

/**
 * @returns {Number} current alpha value
 */
Surface.prototype.getAlpha = function() {
   return (1 - this._blitAlpha);
};

/**
 * Set the alpha value for the whole Surface. When blitting the Surface on
 * a destination, the pixels will be drawn slightly transparent.
 * @param {Number} alpha value in range 0.0 - 1.0
 * @returns {Number} current alpha value
 */
Surface.prototype.setAlpha = function(alpha) {
   if (isNaN(alpha) || alpha < 0 || alpha > 1) {
      return;
   }

   this._blitAlpha = (1 - alpha);
   return (1 - this._blitAlpha);
};

/**
 * The data must be represented in left-to-right order, row by row top to bottom,
 * starting with the top left, with each pixel's red, green, blue, and alpha components
 * being given in that order for each pixel.
 * @see http://dev.w3.org/html5/2dcontext/#canvaspixelarray
 * @returns {ImageData} an object holding the pixel image data {data, width, height}
 */
Surface.prototype.getImageData = function() {
   var size = this.getSize();
   return this.context.getImageData(0, 0, size[0], size[1]);
};

/**
 * @ignore
 */
exports.display = require('./gamejs/display');
/**
 * @ignore
 */
exports.draw = require('./gamejs/draw');
/**
 * @ignore
 */
exports.event = require('./gamejs/event');
/**
 * @ignore
 */
exports.font = require('./gamejs/font');
/**
 * @ignore
 */
exports.http = require('./gamejs/http');
/**
 * @ignore
 */
exports.image = require('./gamejs/image');
/**
 * @ignore
 */
exports.mask = require('./gamejs/mask');
/**
 * @ignore
 */
exports.mixer = require('./gamejs/mixer');
/**
 * @ignore
 */
exports.sprite = require('./gamejs/sprite');
/**
 * @ignore
 */
exports.surfacearray = require('./gamejs/surfacearray');
/**
 * @ignore
 */
exports.time = require('./gamejs/time');
/**
 * @ignore
 */
exports.transform = require('./gamejs/transform');

/**
 * @ignore
 */
exports.utils = {
   arrays: require('./gamejs/utils/arrays'),
   objects: require('./gamejs/utils/objects'),
   matrix: require('./gamejs/utils/matrix'),
   vectors: require('./gamejs/utils/vectors'),
   math: require('./gamejs/utils/math'),
   uri: require('./gamejs/utils/uri'),
   prng: require('./gamejs/utils/prng'),
   base64: require('./gamejs/utils/base64')
};

/**
 * @ignore
 */
exports.pathfinding = {
   astar: require('./gamejs/pathfinding/astar')
};

/**
 * @ignore
 */
exports.worker = require('./gamejs/worker');

/**
 * @ignore
 */
exports.xml = require('./gamejs/xml');

/**
 * @ignore
 */
exports.tmx = require('./gamejs/tmx');

/**
 * @ignore
 */
exports.noise = require('./gamejs/noise');

// preloading stuff
var gamejs = exports;
var RESOURCES = {};

/**
 * ReadyFn is called once all modules and assets are loaded.
 * @param {Function} readyFn the function to be called once gamejs finished loading
 * @name ready
 */
if (gamejs.worker.inWorker === true) {
   exports.ready = function(readyFn) {
      require('./gamejs/worker')._ready();
      gamejs.init();
      readyFn();
   };
} else {
   exports.ready = function(readyFn) {

      var getMixerProgress = null;
      var getImageProgress = null;

      // init time instantly - we need it for preloaders
      gamejs.time.init();

      // 2.
      function _ready() {
         if (!document.body) {
            return window.setTimeout(_ready, 50);
         }
         getImageProgress = gamejs.image.preload(RESOURCES);
         try {
            getMixerProgress = gamejs.mixer.preload(RESOURCES);
         } catch (e) {
            gamejs.debug('Error loading audio files ', e);
         }
         window.setTimeout(_readyResources, 50);
      }

      // 3.
      function _readyResources() {
         if (getImageProgress() < 1 || getMixerProgress() < 1) {
            return window.setTimeout(_readyResources, 100);
         }
         gamejs.display.init();
         gamejs.image.init();
         gamejs.mixer.init();
         gamejs.event.init();
         gamejs.utils.prng.init();
         readyFn();
      }

      // 1.
      window.setTimeout(_ready, 13);

      function getLoadProgress() {
         if (getImageProgress) {
            return (0.5 * getImageProgress()) + (0.5 * getMixerProgress());
         }
         return 0.1;
      }

      return getLoadProgress;
   };
}

/**
 * Initialize all gamejs modules. This is automatically called
 * by `gamejs.ready()`.
 * @returns {Object} the properties of this objecte are the moduleIds that failed, they value are the exceptions
 * @ignore
 */
exports.init = function() {
   var errorModules = {};
   ['time', 'display', 'image', 'mixer', 'event'].forEach(function(moduleName) {
      try {
         gamejs[moduleName].init();
      } catch (e) {
         errorModules[moduleName] = e.toString();
      }
   });
   return errorModules;
};

var resourceBaseHref = function() {
    return (window.$g && window.$g.resourceBaseHref) || document.location.href;
};

/**
 * Preload resources.
 * @param {Array} resources list of resources paths
 * @name preload
 */
var preload = exports.preload = function(resources) {
   var uri = require('./gamejs/utils/uri');
   var baseHref = resourceBaseHref();
   resources.forEach(function(res) {
      RESOURCES[res] = uri.resolve(baseHref, res);
   }, this);
   return;
};

/**
 * The function passsed to `onEvent` will be called whenever
 * an event (mouse, keyboard, etc) was triggered.
 */
exports.onEvent = function(fn, scope) {
  exports.event._CALLBACK = new Callback(fn, scope);
};

/**
 * The function passed to `onTick` will continously be called at a
 * frequency determined by the browser (typically between 1 and 60 times per second).
 * @param {Function} callback the function you want to be called
 * @param {Function} callbackScope optional scope for the function call
 */
exports.onTick = function(fn, scope) {
  exports.time._CALLBACK = new Callback(fn, scope);
};
},{"./gamejs/callback":38,"./gamejs/display":39,"./gamejs/draw":40,"./gamejs/event":41,"./gamejs/font":42,"./gamejs/http":43,"./gamejs/image":44,"./gamejs/mask":45,"./gamejs/mixer":46,"./gamejs/noise":47,"./gamejs/pathfinding/astar":48,"./gamejs/sprite":49,"./gamejs/surfacearray":50,"./gamejs/time":51,"./gamejs/tmx":52,"./gamejs/transform":53,"./gamejs/utils/arrays":54,"./gamejs/utils/base64":55,"./gamejs/utils/math":57,"./gamejs/utils/matrix":58,"./gamejs/utils/objects":59,"./gamejs/utils/prng":60,"./gamejs/utils/uri":61,"./gamejs/utils/vectors":62,"./gamejs/worker":63,"./gamejs/xml":64}],38:[function(require,module,exports){
/**
 * Manage a callback with scope
 */

var Callback = exports.Callback = function(fn, scope) {
	this.fn = fn;
	this.fnScope = scope || {};
	return this;
};

Callback.prototype.trigger = function() {
	this.fn.apply(this.fnScope, arguments);
};
},{}],39:[function(require,module,exports){
var Surface = require('../gamejs').Surface;

/**
 * @fileoverview Methods to create, access and manipulate the display Surface.
 *
 * ## Flags
 *
 * `gamejs.display.setMode()` understands three flags:
 *
 *   * gamejs.display.FULLSCREEN
 *   * gamejs.display.DISABLE_SMOOTHING
 *   * gamejs.display.POINTERLOCK (implies FULLSCREEN)
 *
 *    // disable smoothing
 *    gamejs.display.setMode([800, 600], gamejs.display.DISABLE_SMOOTHING);
 *    // disable smoothing and fullscreen
 *    gamejs.display.setMode([800, 600], gamejs.display.DISABLE_SMOOTHING | gamejs.display.FULLSCREEN);
 *
 * DOM node ids accessed by this module:
 *
 *   * #gjs-canvas - the display surface
 *   * #gjs-loader - loading bar
 *   * #gjs-fullscreen-toggle a clickable element to enable fullscreen
 *   * #gjs-canvas-wrapper this wrapper is added when in fullscreen mode
 *
 * ## Fullscreen mode
 *
 * When `setMode()` is called with the fullscreen flag then the fullscreen mode can be enabled by the
 * player by clicking on the DOM element with id "gjs-fullscreen-toggle". Browser security requires
 * that a user enables fullscreen with a "gesture" (e.g., clicking a button) and we can not enable fullscreen
 * in code.
 *
 * Fullscreen mode can be exited by many keys, e.g., anything window manager related (ALT-TAB) or ESC. A lot
 * of keys will trigger a browser information popup explaining how fullscreen mode can be exited.
 *
 * The following keys are "whitelisted" in fullscreen mode and will not trigger such a browser popup:
 *
 *  * left arrow, right arrow, up arrow, down arrow
 *  * space
 *  * shift, control, alt
 *  * page up, page down
 *  * home, end, tab, meta
 *
 * @see https://developer.mozilla.org/en/DOM/Using_full-screen_mode
 *
 * @example
 * var display = gamejs.display.setMode([800, 600]);
 * // blit sunflower picture in top left corner of display
 * var sunflower = gamejs.image.load("images/sunflower");
 * display.blit(sunflower);
 *
 */

var CANVAS_ID = "gjs-canvas";
var LOADER_ID = "gjs-loader";
var SURFACE = null;

/**
 * Pass this flag to `gamejs.display.setMode(resolution, flags)` to disable
 * pixel smoothing; this is, for example, useful for retro-style, low resolution graphics
 * where you don't want the browser to smooth them when scaling & drawing.
 */
var DISABLE_SMOOTHING = exports.DISABLE_SMOOTHING = 2;
var FULLSCREEN = exports.FULLSCREEN = 4;
var POINTERLOCK = exports.POINTERLOCK = 8;

var _flags = 0;

/**
 * @returns {document.Element} the canvas dom element
 */
var getCanvas = function() {
   var displayCanvas = document.getElementById(CANVAS_ID);
   if (!displayCanvas) {
      displayCanvas = document.createElement("canvas");
      displayCanvas.setAttribute("id", CANVAS_ID);
      document.body.appendChild(displayCanvas);
   }
   return displayCanvas;
};


var getFullScreenToggle = function() {
   var fullScreenButton = document.getElementById('gjs-fullscreen-toggle');
   if (!fullScreenButton) {
      // before canvas
      fullScreenButton = document.createElement('button');
      fullScreenButton.innerHTML = 'Fullscreen';
      fullScreenButton.id = 'gjs-fullscreen-toggle';
      var canvas = getCanvas();
      canvas.parentNode.insertBefore(fullScreenButton, canvas);
      canvas.parentNode.insertBefore(document.createElement('br'), canvas);

   }
   return fullScreenButton;
};

var fullScreenChange = function(event) {
   var gjsEvent ={
      type: isFullScreen() ? require('./event').DISPLAY_FULLSCREEN_ENABLED :
                        require('./event').DISPLAY_FULLSCREEN_DISABLED

   };
   if (isFullScreen()) {
      if (_flags & POINTERLOCK) {
         enablePointerLock();
      }
   }
   require('./event')._triggerCallback(gjsEvent);
};

exports.hasPointerLock = function() {
   return !!(document.pointerLockElement ||
      document.webkitFullscreenElement ||
      document.mozFullscreenElement ||
      document.mozFullScreenElement);
};

/**
 * Create the master Canvas plane.
 * @ignore
 */
exports.init = function() {
   // create canvas element if not yet present
   var canvas = getCanvas();
   if (!canvas.getAttribute('tabindex')) {
      // to be focusable, tabindex must be set
      canvas.setAttribute("tabindex", 1);
      canvas.focus();
   }
   // remove loader if any;
   var $loader = document.getElementById('gjs-loader');
   if ($loader) {
      $loader.style.display = "none";
   }
   return;
};

var isFullScreen = exports.isFullscreen = function() {
   return (document.fullScreenElement || document.mozFullScreen || document.webkitIsFullScreen || document.webkitDisplayingFullscreen);
};

/*
 * Switches the display window normal browser mode and fullscreen.
 * @ignore
 * @returns {Boolean} true if operation was successfull, false otherwise
 */
var enableFullScreen = function(event) {
   var wrapper = getCanvas();
   wrapper.requestFullScreen = wrapper.requestFullScreen || wrapper.mozRequestFullScreen || wrapper.webkitRequestFullScreen;
   if (!wrapper.requestFullScreen) {
      return false;
   }
   // @xbrowser chrome allows keboard input onl if ask for it (why oh why?)
   if (Element.ALLOW_KEYBOARD_INPUT) {
      wrapper.webkitRequestFullScreen(Element.ALLOW_KEYBOARD_INPUT);
   } else {
      wrapper.requestFullScreen();
   }
   return true;
};

var enablePointerLock = function() {
   var wrapper = getCanvas();
   wrapper.requestPointerLock = wrapper.requestPointerLock || wrapper.mozRequestPointerLock || wrapper.webkitRequestPointerLock;
   if (wrapper.requestPointerLock) {
      wrapper.requestPointerLock();
   }
};

/** @ignore **/
exports._hasFocus = function() {
   return document.activeElement == getCanvas();
};

/**
 * Set the width and height of the Display. Conviniently this will
 * return the actual display Surface - the same as calling [gamejs.display.getSurface()](#getSurface)
 * later on.
 * @param {Array} dimensions [width, height] of the display surface
 * @param {Number} flags gamejs.display.DISABLE_SMOOTHING | gamejs.display.FULLSCREEN | gamejs.display.POINTERLOCK
 */
exports.setMode = function(dimensions, flags) {
   SURFACE = null;
   var canvas = getCanvas();
   canvas.width = dimensions[0];
   canvas.height = dimensions[1];
   _flags = _flags || flags;
   // @ xbrowser firefox allows pointerlock only if fullscreen
   if (_flags & POINTERLOCK) {
      _flags = _flags | FULLSCREEN;
   }
   if (_flags & FULLSCREEN) {
      // attach fullscreen toggle checkbox
      var fullScreenToggle = getFullScreenToggle();
      fullScreenToggle.removeEventListener('click', enableFullScreen, false);
      fullScreenToggle.addEventListener('click', enableFullScreen, false);
      // @@ xbrowser
      document.removeEventListener('fullScreenchange',fullScreenChange, false);
      document.removeEventListener('webkitfullscreenchange',fullScreenChange, false);
      document.removeEventListener('mozfullscreenchange',fullScreenChange, false);
      document.addEventListener('fullscreenchange', fullScreenChange, false);
      document.addEventListener('webkitfullscreenchange', fullScreenChange, false);
      document.addEventListener('mozfullscreenchange', fullScreenChange, false);
   }
   return getSurface();
};

/**
 * Set the Caption of the Display (document.title)
 * @param {String} title the title of the app
 * @param {gamejs.Image} icon FIXME implement favicon support
 */
exports.setCaption = function(title, icon) {
   document.title = title;
};

/** @ignore **/
exports._isSmoothingEnabled = function() {
   return !(_flags & DISABLE_SMOOTHING);
};

/**
 * The Display (the canvas element) is most likely not in the top left corner
 * of the browser due to CSS styling. To calculate the mouseposition within the
 * canvas we need this offset.
 * @see gamejs/event
 * @ignore
 *
 * @returns {Array} [x, y] offset of the canvas
 */

exports._getCanvasOffset = function() {
   var boundRect = getCanvas().getBoundingClientRect();
   return [boundRect.left, boundRect.top];
};

/**
 * Drawing on the Surface returned by `getSurface()` will draw on the screen.
 * @returns {gamejs.Surface} the display Surface
 */
var getSurface = exports.getSurface = function() {
   if (SURFACE === null) {
      var canvas = getCanvas();
      SURFACE = new Surface([canvas.clientWidth, canvas.clientHeight]);
      SURFACE._canvas = canvas;
      SURFACE._context = canvas.getContext('2d');
      if (!(_flags & DISABLE_SMOOTHING)) {
         SURFACE._smooth();
      } else {
         SURFACE._noSmooth();
      }
   }
   return SURFACE;
};

},{"../gamejs":37,"./event":41}],40:[function(require,module,exports){
/**
 * @fileoverview Utilities for drawing geometrical objects to Surfaces. If you want to put images on
 * the screen see gamejs/image.
 *
 * There are several ways to specify colors. Whenever the docs says "valid #RGB string"
 * you can pass in any of the following formats.
 *
 *
 * @example
 *     "#ff00ff"
 *     "rgb(255, 0, 255)"
 *     "rgba(255,0, 255, 1)"
 * @see gamejs/image
 */

// FIXME all draw functions must return a minimal rect containing the drawn shape

/**
 * @param {gamejs.Surface} surface the Surface to draw on
 * @param {String} color valid #RGB string, e.g., "#ff0000"
 * @param {Array} startPos [x, y] position of line start
 * @param {Array} endPos [x, y] position of line end
 * @param {Number} width of the line, defaults to 1
 */
exports.line = function(surface, color, startPos, endPos, width) {
   var ctx = surface.context;
   ctx.save();
   ctx.beginPath();
   ctx.strokeStyle = color;
   ctx.lineWidth = width || 1;
   ctx.moveTo(startPos[0], startPos[1]);
   ctx.lineTo(endPos[0], endPos[1]);
   ctx.stroke();
   ctx.restore();
   return;
};

/**
 * Draw connected lines. Use this instead of indiviudal line() calls for
 * better performance
 *
 * @param {gamejs.Surface} surface the Surface to draw on
 * @param {String} color a valid #RGB string, "#ff0000"
 * @param {Boolean} closed if true the last and first point are connected
 * @param {Array} pointlist holding array [x,y] arrays of points
 * @param {Number} width width of the lines, defaults to 1
 */
exports.lines = function(surface, color, closed, pointlist, width) {
   closed = closed || false;
   var ctx = surface.context;
   ctx.save();
   ctx.beginPath();
   ctx.strokeStyle = ctx.fillStyle = color;
   ctx.lineWidth = width || 1;
   pointlist.forEach(function(point, idx) {
      if (idx === 0) {
         ctx.moveTo(point[0], point[1]);
      } else {
         ctx.lineTo(point[0], point[1]);
      }
   });
   if (closed) {
      ctx.lineTo(pointlist[0][0], pointlist[0][1]);
   }
   ctx.stroke();
   ctx.restore();
   return;
};

/**
 * Draw a circle on Surface
 *
 * @param {gamejs.Surface} surface the Surface to draw on
 * @param {String} color a valid #RGB String, #ff00cc
 * @param {Array} pos [x, y] position of the circle center
 * @param {Number} radius of the circle
 * @param {Number} width width of the circle, if not given or 0 the circle is filled
 */
exports.circle = function(surface, color, pos, radius, width) {
   if (!radius) {
      throw new Error('[circle] radius required argument');
   }
   if (!pos || !(pos instanceof Array)) {
      throw new Error('[circle] pos must be given & array' + pos);
   }

   var ctx = surface.context;
   ctx.save();
   ctx.beginPath();
   ctx.strokeStyle = ctx.fillStyle = color;
   ctx.lineWidth = width || 1;
   ctx.arc(pos[0], pos[1], radius, 0, 2*Math.PI, true);
   if (width === undefined || width === 0) {
      ctx.fill();
   } else {
      ctx.stroke();
   }
   ctx.restore();
   return;
};

/**
 * @param {gamejs.Surface} surface the Surface to draw on
 * @param {String} color a valid #RGB String, #ff00cc
 * @param {gamejs.Rect} rect the position and dimension attributes of this Rect will be used
 * @param {Number} width the width of line drawing the Rect, if 0 or not given the Rect is filled.
 */
exports.rect = function(surface, color, rect, width) {
   var ctx =surface.context;
   ctx.save();
   ctx.beginPath();
   ctx.strokeStyle = ctx.fillStyle = color;
   if (isNaN(width) || width === 0) {
      ctx.fillRect(rect.left, rect.top, rect.width, rect.height);
   } else {
      ctx.lineWidth = width || 1;
      ctx.strokeRect(rect.left, rect.top, rect.width, rect.height);
   }
   ctx.restore();
};

/**
 * @param {gamejs.Surface} surface the Surface to draw on
 * @param {String} color a valid #RGB String, #ff00cc
 * @param {gamejs.Rect} rect the position and dimension attributes of this Rect will be used
 * @param {Number} startAngle
 * @param {Number} stopAngle
 * @param {Number} width the width of line, if 0 or not given the arc is filled.
 */
exports.arc= function(surface, color, rect, startAngle, stopAngle, width) {
   var ctx = surface.context;
   ctx.save();
   ctx.beginPath();
   ctx.strokeStyle = ctx.fillStyle = color;
   ctx.arc(rect.center[0], rect.center[1],
            rect.width/2,
            startAngle * (Math.PI/180), stopAngle * (Math.PI/180),
            false
         );
   if (isNaN(width) || width === 0) {
      ctx.fill();
   } else {
      ctx.lineWidth = width || 1;
      ctx.stroke();
   }
   ctx.restore();
};

/**
 * Draw a polygon on the surface. The pointlist argument are the vertices
 * for the polygon.
 *
 * @param {gamejs.Surface} surface the Surface to draw on
 * @param {String} color a valid #RGB String, #ff00cc
 * @param {Array} pointlist array of vertices [x, y] of the polygon
 * @param {Number} width the width of line, if 0 or not given the polygon is filled.
 */
exports.polygon = function(surface, color, pointlist, width) {
   var ctx = surface.context;
   ctx.save();
   ctx.fillStyle = ctx.strokeStyle = color;
   ctx.beginPath();
   pointlist.forEach(function(point, idx) {
      if (idx == 0) {
         ctx.moveTo(point[0], point[1]);
      } else {
         ctx.lineTo(point[0], point[1]);
      }
   });
   ctx.closePath();
   if (isNaN(width) || width === 0) {
      ctx.fill();
   } else {
      ctx.lineWidth = width || 1;
      ctx.stroke();
   }
   ctx.restore();
};

/**
 * Draw a quadratic curve with one control point on the surface.
 * The control point position defines the shape of the quadratic curve.
 *
 * @param {gamejs.Surface} surface the Surface to draw on
 * @param {String} color valid #RGB string, e.g., "#ff0000"
 * @param {Array} startPos [x, y] the start position for the quadratic curve
 * @param {Array} endPos [x, y] the end position for the quadratic curve
 * @param {Array} controlPos [x, y] position of the control point
 * @param {Number} width of the quadratic curve, defaults to 1
 */
exports.quadraticCurve = function(surface, color, startPos, endPos, controlPos, width) {
   if (!startPos || !(startPos instanceof Array)) {
      throw new Error('[quadratic_curve] startPos must be defined!');
   }
   if (!endPos || !(endPos instanceof Array)) {
      throw new Error('[quadratic_curve] endPos must be defined!');
   }
   if (!controlPos || !(controlPos instanceof Array)) {
      throw new Error('[quadratic_curve] controlPos must be defined!');
   }

   var ctx = surface.context;
   ctx.save();
   ctx.fillStyle = ctx.strokeStyle = color;
   ctx.lineWidth = width || 1;

   ctx.beginPath();
   ctx.moveTo(startPos[0], startPos[1]);
   ctx.quadraticCurveTo(controlPos[0], controlPos[1], endPos[0], endPos[1]);
   ctx.stroke();

   ctx.restore();
};

/**
 * Draw a bezier curve with two control points on the surface.
 * The control point positions define the shape of the bezier curve.
 *
 * @param {gamejs.Surface} surface the Surface to draw on
 * @param {String} color valid #RGB string, e.g., "#ff0000"
 * @param {Array} startPos [x, y] the start position for the bezier curve
 * @param {Array} endPos [x, y] the end position for the bezier curve
 * @param {Array} ct1Pos [x, y] position of the first control point
 * @param {Array} ct2Pos [x, y] position of the second control point
 * @param {Number} width of the bezier curve, defaults to 1
 */
exports.bezierCurve = function(surface, color, startPos, endPos, ct1Pos, ct2Pos, width) {
   if (!startPos || !(startPos instanceof Array)) {
      throw new Error('[bezier_curve] startPos must be defined!');
   }
   if (!endPos || !(endPos instanceof Array)) {
      throw new Error('[bezier_curve] endPos must be defined!');
   }
   if (!ct1Pos || !(ct1Pos instanceof Array)) {
      throw new Error('[bezier_curve] ct1Pos must be defined!');
   }
   if (!ct2Pos || !(ct2Pos instanceof Array)) {
      throw new Error('[bezier_curve] ct2Pos must be defined!');
   }
   var ctx = surface.context;
   ctx.save();
   ctx.fillStyle = ctx.strokeStyle = color;
   ctx.lineWidth = width || 1;

   ctx.beginPath();
   ctx.moveTo(startPos[0], startPos[1]);
   ctx.bezierCurveTo(ct1Pos[0], ct1Pos[1], ct2Pos[0], ct2Pos[1], endPos[0], endPos[1]);
   ctx.stroke();

   ctx.restore();
};
},{}],41:[function(require,module,exports){
var display = require('./display');
var Callback = require('./callback').Callback;

exports._CALLBACK = new Callback(function(){}, {});

/** @ignore **/
exports._triggerCallback = function() {
  exports._CALLBACK.trigger.apply(exports._CALLBACK, arguments);
};


/**
 * @fileoverview
 * Mouse and keyboard events.
 *
 * All events have a type identifier. This event type is in between the values
 * of NOEVENT and NUMEVENTS. Each event has a constant in `gamejs.event.*`
 * All user defined events can have the value of USEREVENT or higher.
 * Make sure your custom event ids* follow this system.
 *
 * @example
 *     gamejs.onEvent(function(event) {
 *        if (event.type === gamejs.event.MOUSE_UP) {
 *          gamejs.log(event.pos, event.button);
 *        } else if (event.type === gamejs.event.KEY_UP) {
 *          gamejs.log(event.key);
 *        }
 *     });
 *
 */
// key constants
exports.K_UP = 38;
exports.K_DOWN = 40;
exports.K_RIGHT = 39;
exports.K_LEFT = 37;

exports.K_SPACE = 32;
exports.K_BACKSPACE = 8;
exports.K_TAB = 9;
exports.K_ENTER = 13;
exports.K_SHIFT = 16;
exports.K_CTRL = 17;
exports.K_ALT = 18;
exports.K_ESC = 27;

exports.K_0 = 48;
exports.K_1 = 49;
exports.K_2 = 50;
exports.K_3 = 51;
exports.K_4 = 52;
exports.K_5 = 53;
exports.K_6 = 54;
exports.K_7 = 55;
exports.K_8 = 56;
exports.K_9 = 57;
exports.K_a = 65;
exports.K_b = 66;
exports.K_c = 67;
exports.K_d = 68;
exports.K_e = 69;
exports.K_f = 70;
exports.K_g = 71;
exports.K_h = 72;
exports.K_i = 73;
exports.K_j = 74;
exports.K_k = 75;
exports.K_l = 76;
exports.K_m = 77;
exports.K_n = 78;
exports.K_o = 79;
exports.K_p = 80;
exports.K_q = 81;
exports.K_r = 82;
exports.K_s = 83;
exports.K_t = 84;
exports.K_u = 85;
exports.K_v = 86;
exports.K_w = 87;
exports.K_x = 88;
exports.K_y = 89;
exports.K_z = 90;

exports.K_KP1 = 97;
exports.K_KP2 = 98;
exports.K_KP3 = 99;
exports.K_KP4 = 100;
exports.K_KP5 = 101;
exports.K_KP6 = 102;
exports.K_KP7 = 103;
exports.K_KP8 = 104;
exports.K_KP9 = 105;

// event type constants
exports.NOEVENT = 0;
exports.NUMEVENTS = 32000;

exports.DISPLAY_FULLSCREEN_ENABLED = 300;
exports.DISPLAY_FULLSCREEN_DISABLED = 301;

exports.QUIT = 0;
exports.KEY_DOWN = 1;
exports.KEY_UP = 2;
exports.MOUSE_MOTION = 3;
exports.MOUSE_UP = 4;
exports.MOUSE_DOWN = 5;
exports.MOUSE_WHEEL = 6;
exports.USEREVENT = 2000;



/**
 * Holds all information about an event.
 * @class
 */

exports.Event = function() {
    /**
     * The type of the event. e.g., gamejs.event.QUIT, KEYDOWN, MOUSEUP.
     */
    this.type = null;
    /**
     * key the keyCode of the key. compare with gamejs.event.K_a, gamejs.event.K_b,...
     */
    this.key = null;
    /**
     * relative movement for a mousemove event
     */
    this.rel = null;
    /**
     * the number of the mousebutton pressed
     */
    this.button = null;
    /**
     * pos the position of the event for mouse events
     */
    this.pos = null;
};

/**
 * @ignore
 */
exports.init = function() {

   var lastPos = [];

   // anonymous functions as event handlers = memory leak, see MDC:elementAddEventListener

   function onMouseDown (ev) {
      var canvasOffset = display._getCanvasOffset();
      exports._CALLBACK.trigger({
         'type': exports.MOUSE_DOWN,
         'pos': [ev.clientX - canvasOffset[0], ev.clientY - canvasOffset[1]],
         'button': ev.button,
         'shiftKey': ev.shiftKey,
         'ctrlKey': ev.ctrlKey,
         'metaKey': ev.metaKey
      });
   }

   function onMouseUp (ev) {
      var canvasOffset = display._getCanvasOffset();
      exports._CALLBACK.trigger({
         'type':exports.MOUSE_UP,
         'pos': [ev.clientX - canvasOffset[0], ev.clientY - canvasOffset[1]],
         'button': ev.button,
         'shiftKey': ev.shiftKey,
         'ctrlKey': ev.ctrlKey,
         'metaKey': ev.metaKey
      });
   }

   function onKeyDown (ev) {
      var key = ev.keyCode || ev.which;
      exports._CALLBACK.trigger({
         'type': exports.KEY_DOWN,
         'key': key,
         'shiftKey': ev.shiftKey,
         'ctrlKey': ev.ctrlKey,
         'metaKey': ev.metaKey
      });

      // if the display has focus, we surpress default action
      // for most keys
      if (display._hasFocus() && (!ev.ctrlKey && !ev.metaKey &&
         ((key >= exports.K_LEFT && key <= exports.K_DOWN) ||
         (key >= exports.K_0    && key <= exports.K_z) ||
         (key >= exports.K_KP1  && key <= exports.K_KP9) ||
         key === exports.K_SPACE ||
         key === exports.K_TAB ||
         key === exports.K_ENTER)) ||
         key === exports.K_ALT ||
         key === exports.K_BACKSPACE) {
        ev.preventDefault();
      }
   }

   function onKeyUp (ev) {
      exports._CALLBACK.trigger({
         'type': exports.KEY_UP,
         'key': ev.keyCode,
         'shiftKey': ev.shiftKey,
         'ctrlKey': ev.ctrlKey,
         'metaKey': ev.metaKey
      });
   }

   function onMouseMove (ev) {
      var canvasOffset = display._getCanvasOffset();
      var currentPos = [ev.clientX - canvasOffset[0], ev.clientY - canvasOffset[1]];
      var relativePos = [];
      if (lastPos.length) {
         relativePos = [
            lastPos[0] - currentPos[0],
            lastPos[1] - currentPos[1]
         ];
      }
      exports._CALLBACK.trigger({
         'type': exports.MOUSE_MOTION,
         'pos': currentPos,
         'rel': relativePos,
         'buttons': null, // FIXME, fixable?
         'timestamp': ev.timeStamp,
         'movement': [ev.movementX       ||
                      ev.mozMovementX    ||
                      ev.webkitMovementX || 0,
                      ev.movementY       ||
                      ev.mozMovementY    ||
                      ev.webkitMovementY || 0
                      ]
      });
      lastPos = currentPos;
      return;
   }

   function onMouseScroll(ev) {
      var canvasOffset = display._getCanvasOffset();
      var currentPos = [ev.clientX - canvasOffset[0], ev.clientY - canvasOffset[1]];
      exports._CALLBACK.trigger({
         type: exports.MOUSE_WHEEL,
         pos: currentPos,
         delta: ev.detail || (- ev.wheelDeltaY / 40)
      });
      return;
   }

   function onBeforeUnload (ev) {
      exports._CALLBACK.trigger({
         'type': exports.QUIT
      });
      return;
   }

   // IEFIX does not support addEventListener on document itself
   // MOZFIX but in moz & opera events don't reach body if mouse outside window or on menubar
   var canvas = display.getSurface()._canvas;
   canvas.addEventListener('mousedown', onMouseDown, false);
   canvas.addEventListener('mouseup', onMouseUp, false);
   document.addEventListener('keydown', onKeyDown, false);
   document.addEventListener('keyup', onKeyUp, false);
   document.addEventListener('mousemove', onMouseMove, false);
   canvas.addEventListener('mousewheel', onMouseScroll, false);
   // MOZFIX
   // https://developer.mozilla.org/en/Code_snippets/Miscellaneous#Detecting_mouse_wheel_events
   canvas.addEventListener('DOMMouseScroll', onMouseScroll, false);
   canvas.addEventListener('beforeunload', onBeforeUnload, false);

};

},{"./callback":38,"./display":39}],42:[function(require,module,exports){
var Surface = require('../gamejs').Surface;
var objects = require('./utils/objects');

/**
 * @fileoverview Methods for creating Font objects which can render text
 * to a Surface.
 *
 * @example
 *     // create a font
 *     var font = new Font('20px monospace');
 *     // render text - this returns a surface with the text written on it.
 *     var helloSurface = font.render('Hello World')
 */

/**
 * Create a Font to draw on the screen. The Font allows you to
 * `render()` text. Rendering text returns a Surface which
 * in turn can be put on screen.
 *
 * @constructor
 * @property {Number} fontHeight the line height of this Font
 *
 * @param {String} fontSettings a css font definition, e.g., "20px monospace"
 * @param {STring} backgroundColor valid #rgb string, "#ff00cc"
 */
var Font = exports.Font = function(fontSettings, backgroundColor) {
    /**
     * @ignore
     */
   this.sampleSurface = new Surface([10,10]);
   this.sampleSurface.context.font = fontSettings;
   this.sampleSurface.context.textAlign = 'start';
   // http://diveintohtml5.org/canvas.html#text
   this.sampleSurface.context.textBaseline = 'bottom';
   this.backgroundColor = backgroundColor || false;
   return this;
};

/**
 * Returns a Surface with the given text on it.
 * @param {String} text the text to render
 * @param {String} color a valid #RGB String, "#ffcc00"
 * @returns {gamejs.Surface} Surface with the rendered text on it.
 */
Font.prototype.render = function(text, color) {
   var dims = this.size(text);
   var surface = new Surface(dims);
   var ctx = surface.context;
   ctx.save();
   if ( this.backgroundColor ) {
       ctx.fillStyle = this.backgroundColor;
       ctx.fillRect(0, 0, surface.rect.width, surface.rect.height);
   }
   ctx.font = this.sampleSurface.context.font;
   ctx.textBaseline = this.sampleSurface.context.textBaseline;
   ctx.textAlign = this.sampleSurface.context.textAlign;
   ctx.fillStyle = ctx.strokeStyle = color || "#000000";
   ctx.fillText(text, 0, surface.rect.height, surface.rect.width);
   ctx.restore();
   return surface;
};

/**
 * Determine the width and height of the given text if rendered
 * with this Font.
 * @param {String} text the text to measure
 * @returns {Array} the [width, height] of the text if rendered with this Font
 */
Font.prototype.size = function(text) {
   var metrics = this.sampleSurface.context.measureText(text);
   // FIXME measuretext is buggy, make extra wide
   return [metrics.width, this.fontHeight];
};

/**
 * Height of the font in pixels.
 */
objects.accessors(Font.prototype, {
   'fontHeight': {
      get: function() {
         // Returns an approximate line height of the text
         // »This version of the specification does not provide a way to obtain
         // the bounding box dimensions of the text.«
         // see http://www.whatwg.org/specs/web-apps/current-work/multipage/the-canvas-element.html#dom-context-2d-measuretext
         return this.sampleSurface.context.measureText('M').width * 1.5;
      }
   }

});

},{"../gamejs":37,"./utils/objects":59}],43:[function(require,module,exports){
/**
 * @fileoverview Make synchronous http requests to your game's serverside component.
 *
 * If you configure a ajax base URL you can make http requests to your
 * server using those functions.

 * The most high-level functions are `load()` and `save()` which take
 * and return a JavaScript object, which they will send to / recieve from
 * the server-side in JSON format.
 *
 * @example
 *
 *     <script>
 *     // Same Origin policy applies! You can only make requests
 *     // to the server from which the html page is served.
 *      var $g = {
 *         ajaxBaseHref: "http://the-same-server.com/ajax/"
 *      };
 *      </script>
 *      <script src="./public/gamejs-wrapped.js"></script>
 *      ....
 *      typeof gamejs.load('userdata/') === 'object'
 *      typeof gamejs.get('userdata/') === 'string'
 *      ...
 *
 */

/**
 * Response object returned by http functions `get` and `post`. This
 * class is not instantiable.
 *
 * @param{String} responseText
 * @param {String} responseXML
 * @param {Number} status
 * @param {String} statusText
 */
exports.Response = function() {
   /**
    * @param {String} header
    */
   this.getResponseHeader = function(header)  {
   };
   throw new Error('response class not instantiable');
};

/**
 * Make http request to server-side
 * @param {String} method http method
 * @param {String} url
 * @param {String|Object} data
 * @param {String|Object} type "Accept" header value
 * @return {Response} response
 */
var ajax = exports.ajax = function(method, url, data, type) {
   data = data || null;
   var response = new XMLHttpRequest();
   response.open(method, url, false);
   if (type) {
      response.setRequestHeader("Accept", type);
   }
   if (data instanceof Object) {
      data = JSON.stringify(data);
      response.setRequestHeader('Content-Type', 'application/json');
   }
   response.setRequestHeader('X-Requested-With', 'XMLHttpRequest');
   response.send(data);
   return response;
};

/**
 * Make http GET request to server-side
 * @param {String} url
 */
var get = exports.get = function(url) {
   return ajax('GET', url);
};

/**
 * Make http POST request to server-side
 * @param {String} url
 * @param {String|Object} data
 * @param {String|Object} type "Accept" header value
 * @returns {Response}
 */
var post = exports.post = function(url, data, type) {
   return ajax('POST', url, data, type);
};

function stringify(response) {
   // eval is evil
   return eval('(' + response.responseText + ')');
}

function ajaxBaseHref() {
    return (window.$g && window.$g.ajaxBaseHref) || './';
}

/**
 * Load an object from the server-side.
 * @param {String} url
 * @return {Object} the object loaded from the server
 */
exports.load = function(url) {
   return stringify(get(ajaxBaseHref() + url));
};

/**
 * Send an object to a server-side function.
 * @param {String} url
 * @param {String|Object} data
 * @param {String|Object} type "Accept" header value
 * @returns {Object} the response object
 */
exports.save = function(url, data, type) {
   return stringify(post(ajaxBaseHref() + url, {payload: data}, type));
};

},{}],44:[function(require,module,exports){
var gamejs = require('../gamejs');

/**
 * @fileoverview Load images as Surfaces.
 *
 * Sounds & Images are loaded relative to your game's html page
 * (the html which includes the GameJs code) or relative to the
 * property `window.$g.resourceBaseHref`
 * if it is set.
 *
 *
 */

var CACHE = {};

/**
 * need to export preloading status for require
 * @ignore
 */
var _PRELOADING = false;

/**
 * Load image and return it on a Surface.
 *
 * All images must be preloaded before they can be used.
 * @example

 *     gamejs.preload(["./images/ship.png", "./images/sunflower.png"]);
 *     // ...later...
 *     display.blit(gamejs.image.load('images/ship.png'))
 *
 * @param {String|dom.Image} uriOrImage resource uri for image
 * @returns {gamejs.Surface} surface with the image on it.
 */
exports.load = function(key) {
   var img;
   if (typeof key === 'string') {
      img = CACHE[key];
      if (!img) {
			throw new Error('Missing "' + key + '", gamejs.preload() all images before trying to load them.');
      }
   } else {
      img = key;
   }
   var canvas = document.createElement('canvas');
   // IEFIX missing html5 feature naturalWidth/Height
   canvas.width = img.naturalWidth || img.width;
   canvas.height = img.naturalHeight || img.height;
   var context = canvas.getContext('2d');
   context.drawImage(img, 0, 0);
   img.getSize = function() { return [img.naturalWidth, img.naturalHeight]; };
   var surface = new gamejs.Surface(img.getSize());
   // NOTE hack setting protected _canvas directly
   surface._canvas = canvas;
   surface._context = context;
   return surface;
};


/**
 * add all images on the currrent page into cache
 * @ignore
 */
exports.init = function() {
   return;
};

/**
 * preload the given img URIs
 * @returns {Function} which returns 0-1 for preload progress
 * @ignore
 */
exports.preload = function(imgIdents) {

   var countLoaded = 0;
   var countTotal = 0;

   function incrementLoaded() {
      countLoaded++;
      if (countLoaded == countTotal) {
         _PRELOADING = false;
      }
      if (countLoaded % 10 === 0) {
         gamejs.log('gamejs.image: preloaded  ' + countLoaded + ' of ' + countTotal);
      }
   }

   function getProgress() {
      return countTotal > 0 ? countLoaded / countTotal : 1;
   }

   function successHandler() {
      addToCache(this);
      incrementLoaded();
   }
   function errorHandler() {
      incrementLoaded();
      throw new Error('Error loading ' + this.src);
   }

   var key;
   for (key in imgIdents) {
      var lowerKey = key.toLowerCase();
      if (lowerKey.indexOf('.png') == -1 &&
            lowerKey.indexOf('.jpg') == -1 &&
            lowerKey.indexOf('.jpeg') == -1 &&
            lowerKey.indexOf('.svg') == -1 &&
            lowerKey.indexOf('.gif') == -1) {
         continue;
      }
      var img = new Image();
      img.addEventListener('load', successHandler, true);
      img.addEventListener('error', errorHandler, true);
      img.src = imgIdents[key];
      img.gamejsKey = key;
      countTotal++;
   }
   if (countTotal > 0) {
      _PRELOADING = true;
   }
   return getProgress;
};

/**
 * add the given <img> dom elements into the cache.
 * @private
 */
var addToCache = function(img) {
   CACHE[img.gamejsKey] = img;
   return;
};

},{"../gamejs":37}],45:[function(require,module,exports){
var gamejs = require('../gamejs');
var objects = require('./utils/objects');

/**
 * @fileoverview Image masks. Usefull for pixel perfect collision detection.
 */

/**
 * Creates an image mask from the given Surface. The alpha of each pixel is checked
 * to see if it is greater than the given threshold. If it is greater then
 * that pixel is set as non-colliding.
 *
 * @param {gamejs.Surface} surface
 * @param {Number} threshold 0 to 255. defaults to: 255, fully transparent
 */
exports.fromSurface = function(surface, threshold) {
   threshold = (threshold && (255 - threshold)) || 255;
   var imgData = surface.getImageData().data;
   var dims = surface.getSize();
   var mask = new Mask(dims);
   var i;
   for (i=0;i<imgData.length;i += 4) {
      // y: pixel # / width
      var y = parseInt((i / 4) / dims[0], 10);
      // x: pixel # % width
      var x = parseInt((i / 4) % dims[0], 10);
      var alpha = imgData[i+3];
      if (alpha >= threshold) {
         mask.setAt(x, y);
      }
   }
   return mask;
};

/**
 * Image Mask
 * @param {Array} dimensions [width, height]
 *
 */
var Mask = exports.Mask = function(dims) {
   /**
    * @ignore
    */
   this.width = dims[0];
   /**
    * @ignore
    */
   this.height = dims[1];
   /**
    * @ignore
    */
   this._bits = [];
   var i,j;
   for (i=0;i<this.width;i++) {
      this._bits[i] = [];
      for (j=0;j<this.height;j++) {
         this._bits[i][j] = false;
      }
   }
   return;
};

/**
 * @param {gamejs.mask.Mask} otherMask
 * @param {Array} offset [x,y]
 * @returns the overlapping rectangle or null if there is no overlap;
 */
Mask.prototype.overlapRect = function(otherMask, offset) {
   var arect = this.rect;
   var brect = otherMask.rect;
   if (offset) {
      brect.moveIp(offset);
   }
   // bounding box intersect
   if (!brect.collideRect(arect)) {
      return null;
   }
   var xStart = Math.max(arect.left, brect.left);
   var xEnd = Math.min(arect.right, brect.right);

   var yStart = Math.max(arect.top, brect.top);
   var yEnd = Math.min(arect.bottom, brect.bottom);

   return new gamejs.Rect([xStart, yStart], [xEnd - xStart, yEnd - yStart]);
};

/**
 *
 * @returns True if the otherMask overlaps with this map.
 * @param {Mask} otherMask
 * @param {Array} offset
 */
Mask.prototype.overlap = function(otherMask, offset) {
   var overlapRect = this.overlapRect(otherMask, offset);
   if (overlapRect === null) {
      return false;
   }

   var arect = this.rect;
   var brect = otherMask.rect;
   if (offset) {
      brect.moveIp(offset);
   }

   var count = 0;
   var x,y;
   for (y=overlapRect.top; y<=overlapRect.bottom; y++) {
      for (x=overlapRect.left; x<=overlapRect.right; x++) {
         if (this.getAt(x - arect.left, y - arect.top) &&
             otherMask.getAt(x - brect.left, y - brect.top)) {
             return true;
         }
      }
   }
   // NOTE this should not happen because either we bailed out
   // long ago because the rects do not overlap or there is an
   // overlap and we should not have gotten this far.
   // throw new Error("Maks.overlap: overlap detected but could not create mask for it.");
   return false;
};

/**
 * @param {gamejs.mask.Mask} otherMask
 * @param {Array} offset [x,y]
 * @returns the number of overlapping pixels
 */
Mask.prototype.overlapArea = function(otherMask, offset) {
   var overlapRect = this.overlapRect(otherMask, offset);
   if (overlapRect === null) {
      return 0;
   }

   var arect = this.rect;
   var brect = otherMask.rect;
   if (offset) {
      brect.moveIp(offset);
   }

   var count = 0;
   var x,y;
   for (y=overlapRect.top; y<=overlapRect.bottom; y++) {
      for (x=overlapRect.left; x<=overlapRect.right; x++) {
         if (this.getAt(x - arect.left, y - arect.top) &&
             otherMask.getAt(x - brect.left, y - brect.top)) {
             count++;
         }
      }
   }
   return count;
};

/**
 * @param {gamejs.mask.Mask} otherMask
 * @param {Array} offset [x,y]
 * @returns a mask of the overlapping pixels
 */
Mask.prototype.overlapMask = function(otherMask, offset) {
   var overlapRect = this.overlapRect(otherMask, offset);
   if (overlapRect === null) {
      return 0;
   }

   var arect = this.rect;
   var brect = otherMask.rect;
   if (offset) {
      brect.moveIp(offset);
   }

   var mask = new Mask([overlapRect.width, overlapRect.height]);
   var x,y;
   for (y=overlapRect.top; y<=overlapRect.bottom; y++) {
      for (x=overlapRect.left; x<=overlapRect.right; x++) {
         if (this.getAt(x - arect.left, y - arect.top) &&
             otherMask.getAt(x - brect.left, y - brect.top)) {
             mask.setAt(x, y);
         }
      }
   }
   return mask;
};

/**
 * Set bit at position.
 * @param {Number} x
 * @param {Number} y
 */
Mask.prototype.setAt = function(x, y) {
   this._bits[x][y] = true;
};

/**
 * Get bit at position.
 *
 * @param {Number} x
 * @param {Number} y
 */
Mask.prototype.getAt = function(x, y) {
   x = parseInt(x, 10);
   y = parseInt(y, 10);
   if (x < 0 || y < 0 || x >= this.width || y >= this.height) {
      return false;
   }
   return this._bits[x][y];
};


/**
 * Flip the bits in this map.
 */
Mask.prototype.invert = function() {
   this._bits = this._bits.map(function(row) {
      return row.map(function(b) {
         return !b;
      });
   });
};

/**
 * @returns {Array} the dimensions of the map
 */
Mask.prototype.getSize = function() {
   return [this.width, this.height];
};

objects.accessors(Mask.prototype, {
   /**
    * Rect of this Mask.
    */
   'rect': {
      get: function() {
         return new gamejs.Rect([0, 0], [this.width, this.height]);
      }
   },
   /**
    * @returns {Number} number of set pixels in this mask.
    */
   'length': {
      get: function() {
         var c = 0;
         this._bits.forEach(function(row) {
            row.forEach(function(b) {
               if (b) {
                  c++;
               }
            });
         });
         return c;
      }
   }
});

},{"../gamejs":37,"./utils/objects":59}],46:[function(require,module,exports){
var gamejs = require('../gamejs');

/**
 * @fileoverview Playing sounds with the html5 audio tag. Audio files must be preloaded
 * with the usual `gamejs.preload()` function. Ogg, wav and webm supported.
 *
 * Sounds & Images are loaded relative to './'.
 */

var CACHE = {};

/**
 * need to export preloading status for require
 * @ignore
 */
var _PRELOADING = false;

/**
 * @ignore
 */
var NUM_CHANNELS = 8;

/**
 * Sets the number of available channels for the mixer. The default value is 8.
 */
exports.setNumChannels = function(count) {
   NUM_CHANNELS = parseInt(count, 10) || NUM_CHANNELS;
};

exports.getNumChannels = function() {
   return NUM_CHANNELS;
};

/**
 * put all audios on page in cache
 * if same domain as current page, remove common href-prefix
 * @ignore
 */
exports.init = function() {
   var audios = Array.prototype.slice.call(document.getElementsByTagName("audio"), 0);
   addToCache(audios);
   return;
};

/**
 * Preload the audios into cache
 * @param {String[]} List of audio URIs to load
 * @returns {Function} which returns 0-1 for preload progress
 * @ignore
 */
exports.preload = function(audioUrls, showProgressOrImage) {
   var countTotal = 0;
   var countLoaded = 0;

   function incrementLoaded() {
      countLoaded++;
      if (countLoaded == countTotal) {
         _PRELOADING = false;
      }
   }

   function getProgress() {
      return countTotal > 0 ? countLoaded / countTotal : 1;
   }

   function successHandler() {
      addToCache(this);
      incrementLoaded();
   }
   function errorHandler() {
      incrementLoaded();
      throw new Error('Error loading ' + this.src);
   }

   for (var key in audioUrls) {
      if (key.indexOf('wav') == -1 && key.indexOf('ogg') == -1 && key.indexOf('webm') == -1) {
         continue;
      }
      countTotal++;
      var audio = new Audio();
      audio.addEventListener('canplay', successHandler, true);
      audio.addEventListener('error', errorHandler, true);
      audio.src = audioUrls[key];
      audio.gamejsKey = key;
      audio.load();
   }
   if (countTotal > 0) {
      _PRELOADING = true;
   }
   return getProgress;
};

/**
 * @ignore
 */
exports.isPreloading = function() {
   return _PRELOADING;
};

/**
 * @param {dom.ImgElement} audios the <audio> elements to put into cache
 * @ignore
 */
function addToCache(audios) {
   if (!(audios instanceof Array)) {
      audios = [audios];
   }

   var docLoc = document.location.href;
   audios.forEach(function(audio) {
      CACHE[audio.gamejsKey] = audio;
   });
   return;
}

/**
 * Sounds can be played back.
 * @constructor
 * @param {String|dom.AudioElement} uriOrAudio the uri of <audio> dom element
 *                of the sound
 */
exports.Sound = function Sound(uriOrAudio) {
   var cachedAudio;
   if (typeof uriOrAudio === 'string') {
      cachedAudio = CACHE[uriOrAudio];
   } else {
      cachedAudio = uriOrAudio;
   }
   if (!cachedAudio) {
      // TODO sync audio loading
      throw new Error('Missing "' + uriOrAudio + '", gamejs.preload() all audio files before loading');
   }

   var channels = [];
   var i = NUM_CHANNELS;
   while (i-->0) {
      var audio = new Audio();
      audio.preload = "auto";
      audio.loop = false;
      audio.src = cachedAudio.src;
      channels.push(audio);
   }
   /**
    * start the sound
    * @param {Boolean} loop whether the audio should loop for ever or not
    */
   this.play = function(loop) {
      channels.some(function(audio) {
         if (audio.ended || audio.paused) {
            audio.loop = !!loop;
            audio.play();
            return true;
         }
         return false;
      });
   };

   /**
    * Stop the sound.
    * This will stop the playback of this Sound on any active Channels.
    */
   this.stop = function() {
      channels.forEach(function(audio) {
         audio.pause();
         audio.currentTime = 0;
      });
   };

   /**
    * Set volume of this sound
    * @param {Number} value volume from 0 to 1
    */
   this.setVolume = function(value) {
      channels.forEach(function(audio) {
         audio.volume = value;
      });
   };

   /**
    * @returns {Number} the sound's volume from 0 to 1
    */
   this.getVolume = function() {
      return channels[0].volume;
   };

   /**
    * @returns {Number} Duration of this sound in seconds
    */
   this.getLength = function() {
      return channels[0].duration;
   };

   return this;
};

},{"../gamejs":37}],47:[function(require,module,exports){
/**
 * @fileoverview
 * A noise generator comparable to Perlin noise, which is useful
 * for generating procedural content.
 * @see gamejs/utils/prng
 */

// Ported to JS by by zz85 <https://github.com/zz85> from Stefan
// Gustavson's java implementation
// <http://staffwww.itn.liu.se/~stegu/simplexnoise/simplexnoise.pdf>
// Read Stefan's excellent paper for details on how this code works.
//
// Sean McCullough banksean@gmail.com

/**
 * This implementation provides 2D and 3D noise. You can optionally
 * pass a seedable pseudo-random number generator to its constructor. This
 * generator object is assumed to have a `random()` method; `Math` is used
 * per default.
 *
 * Also see `gamejs/utils/prng` for a seedable pseudo random number generator
 *
 * @param {Object} prng the random number generator to use; most provide `random()` method
 * @usage
 *  var simplex = new gamejs.noise.Simplex();
 *  simplex.get(x, y);
 *  // or for 3d noise
 *  simple.get(x, y, y);
 */
var Simplex = exports.Simplex = function(r) {
  if (r == undefined) {
    r = Math;
  }
  /** @ignore */
  this.grad3 = [[1,1,0],[-1,1,0],[1,-1,0],[-1,-1,0],
               [1,0,1],[-1,0,1],[1,0,-1],[-1,0,-1],
               [0,1,1],[0,-1,1],[0,1,-1],[0,-1,-1]];
  /** @ignore */
  this.p = [];
  var i;
  for (i=0; i<256; i++) {
   this.p[i] = Math.floor(r.random()*256);
  }
  // To remove the need for index wrapping, double the permutation table length
  /** @ignore */
  this.perm = [];
  for(i=0; i<512; i++) {
    this.perm[i]=this.p[i & 255];
  }

  // A lookup table to traverse the simplex around a given point in 4D.
  // Details can be found where this table is used, in the 4D noise method.
  /** @ignore */
  this.simplex = [
    [0,1,2,3],[0,1,3,2],[0,0,0,0],[0,2,3,1],[0,0,0,0],[0,0,0,0],[0,0,0,0],[1,2,3,0],
    [0,2,1,3],[0,0,0,0],[0,3,1,2],[0,3,2,1],[0,0,0,0],[0,0,0,0],[0,0,0,0],[1,3,2,0],
    [0,0,0,0],[0,0,0,0],[0,0,0,0],[0,0,0,0],[0,0,0,0],[0,0,0,0],[0,0,0,0],[0,0,0,0],
    [1,2,0,3],[0,0,0,0],[1,3,0,2],[0,0,0,0],[0,0,0,0],[0,0,0,0],[2,3,0,1],[2,3,1,0],
    [1,0,2,3],[1,0,3,2],[0,0,0,0],[0,0,0,0],[0,0,0,0],[2,0,3,1],[0,0,0,0],[2,1,3,0],
    [0,0,0,0],[0,0,0,0],[0,0,0,0],[0,0,0,0],[0,0,0,0],[0,0,0,0],[0,0,0,0],[0,0,0,0],
    [2,0,1,3],[0,0,0,0],[0,0,0,0],[0,0,0,0],[3,0,1,2],[3,0,2,1],[0,0,0,0],[3,1,2,0],
    [2,1,0,3],[0,0,0,0],[0,0,0,0],[0,0,0,0],[3,1,0,2],[0,0,0,0],[3,2,0,1],[3,2,1,0]];
};

/** @ignore */
Simplex.prototype.dot = function(g, x, y) {
   return g[0]*x + g[1]*y;
};

/**
 * @param {Number} x
 * @param {Number} y
 * @returns {Number} noise for given position, in range [-1, 1]
 */
Simplex.prototype.get = function(xin, yin) {
  var n0, n1, n2; // Noise contributions from the three corners
  // Skew the input space to determine which simplex cell we're in
  var F2 = 0.5*(Math.sqrt(3.0)-1.0);
  var s = (xin+yin)*F2; // Hairy factor for 2D
  var i = Math.floor(xin+s);
  var j = Math.floor(yin+s);
  var G2 = (3.0-Math.sqrt(3.0))/6.0;
  var t = (i+j)*G2;
  var X0 = i-t; // Unskew the cell origin back to (x,y) space
  var Y0 = j-t;
  var x0 = xin-X0; // The x,y distances from the cell origin
  var y0 = yin-Y0;
  // For the 2D case, the simplex shape is an equilateral triangle.
  // Determine which simplex we are in.
  var i1, j1; // Offsets for second (middle) corner of simplex in (i,j) coords
  if(x0>y0) {i1=1; j1=0;} // lower triangle, XY order: (0,0)->(1,0)->(1,1)
  else {i1=0; j1=1;} // upper triangle, YX order: (0,0)->(0,1)->(1,1)
  // A step of (1,0) in (i,j) means a step of (1-c,-c) in (x,y), and
  // a step of (0,1) in (i,j) means a step of (-c,1-c) in (x,y), where
  // c = (3-sqrt(3))/6
  var x1 = x0 - i1 + G2; // Offsets for middle corner in (x,y) unskewed coords
  var y1 = y0 - j1 + G2;
  var x2 = x0 - 1.0 + 2.0 * G2; // Offsets for last corner in (x,y) unskewed coords
  var y2 = y0 - 1.0 + 2.0 * G2;
  // Work out the hashed gradient indices of the three simplex corners
  var ii = i & 255;
  var jj = j & 255;
  var gi0 = this.perm[ii+this.perm[jj]] % 12;
  var gi1 = this.perm[ii+i1+this.perm[jj+j1]] % 12;
  var gi2 = this.perm[ii+1+this.perm[jj+1]] % 12;
  // Calculate the contribution from the three corners
  var t0 = 0.5 - x0*x0-y0*y0;
  if(t0<0) {
    n0 = 0.0;
  } else {
    t0 *= t0;
    n0 = t0 * t0 * this.dot(this.grad3[gi0], x0, y0); // (x,y) of grad3 used for 2D gradient
  }
  var t1 = 0.5 - x1*x1-y1*y1;
  if(t1<0) {
    n1 = 0.0;
  } else {
    t1 *= t1;
    n1 = t1 * t1 * this.dot(this.grad3[gi1], x1, y1);
  }
  var t2 = 0.5 - x2*x2-y2*y2;
  if(t2<0) {
    n2 = 0.0;
  } else {
    t2 *= t2;
    n2 = t2 * t2 * this.dot(this.grad3[gi2], x2, y2);
  }
  // Add contributions from each corner to get the final noise value.
  // The result is scaled to return values in the interval [-1,1].
  return 70.0 * (n0 + n1 + n2);
};


/**
 * @param {Number} x
 * @param {Number} y
 * @param {Number} y
 * @returns {Number} noise for given position, in range [-1, 1]
 */
Simplex.prototype.get3d = function(xin, yin, zin) {
  var n0, n1, n2, n3; // Noise contributions from the four corners
  // Skew the input space to determine which simplex cell we're in
  var F3 = 1.0/3.0;
  var s = (xin+yin+zin)*F3; // Very nice and simple skew factor for 3D
  var i = Math.floor(xin+s);
  var j = Math.floor(yin+s);
  var k = Math.floor(zin+s);
  var G3 = 1.0/6.0; // Very nice and simple unskew factor, too
  var t = (i+j+k)*G3;
  var X0 = i-t; // Unskew the cell origin back to (x,y,z) space
  var Y0 = j-t;
  var Z0 = k-t;
  var x0 = xin-X0; // The x,y,z distances from the cell origin
  var y0 = yin-Y0;
  var z0 = zin-Z0;
  // For the 3D case, the simplex shape is a slightly irregular tetrahedron.
  // Determine which simplex we are in.
  var i1, j1, k1; // Offsets for second corner of simplex in (i,j,k) coords
  var i2, j2, k2; // Offsets for third corner of simplex in (i,j,k) coords
  if(x0>=y0) {
    if(y0>=z0)
      { i1=1; j1=0; k1=0; i2=1; j2=1; k2=0; } // X Y Z order
      else if(x0>=z0) { i1=1; j1=0; k1=0; i2=1; j2=0; k2=1; } // X Z Y order
      else { i1=0; j1=0; k1=1; i2=1; j2=0; k2=1; } // Z X Y order
    }
  else { // x0<y0
    if(y0<z0) { i1=0; j1=0; k1=1; i2=0; j2=1; k2=1; } // Z Y X order
    else if(x0<z0) { i1=0; j1=1; k1=0; i2=0; j2=1; k2=1; } // Y Z X order
    else { i1=0; j1=1; k1=0; i2=1; j2=1; k2=0; } // Y X Z order
  }
  // A step of (1,0,0) in (i,j,k) means a step of (1-c,-c,-c) in (x,y,z),
  // a step of (0,1,0) in (i,j,k) means a step of (-c,1-c,-c) in (x,y,z), and
  // a step of (0,0,1) in (i,j,k) means a step of (-c,-c,1-c) in (x,y,z), where
  // c = 1/6.
  var x1 = x0 - i1 + G3; // Offsets for second corner in (x,y,z) coords
  var y1 = y0 - j1 + G3;
  var z1 = z0 - k1 + G3;
  var x2 = x0 - i2 + 2.0*G3; // Offsets for third corner in (x,y,z) coords
  var y2 = y0 - j2 + 2.0*G3;
  var z2 = z0 - k2 + 2.0*G3;
  var x3 = x0 - 1.0 + 3.0*G3; // Offsets for last corner in (x,y,z) coords
  var y3 = y0 - 1.0 + 3.0*G3;
  var z3 = z0 - 1.0 + 3.0*G3;
  // Work out the hashed gradient indices of the four simplex corners
  var ii = i & 255;
  var jj = j & 255;
  var kk = k & 255;
  var gi0 = this.perm[ii+this.perm[jj+this.perm[kk]]] % 12;
  var gi1 = this.perm[ii+i1+this.perm[jj+j1+this.perm[kk+k1]]] % 12;
  var gi2 = this.perm[ii+i2+this.perm[jj+j2+this.perm[kk+k2]]] % 12;
  var gi3 = this.perm[ii+1+this.perm[jj+1+this.perm[kk+1]]] % 12;
  // Calculate the contribution from the four corners
  var t0 = 0.6 - x0*x0 - y0*y0 - z0*z0;
  if(t0<0) {
    n0 = 0.0;
  } else {
    t0 *= t0;
    n0 = t0 * t0 * this.dot(this.grad3[gi0], x0, y0, z0);
  }
  var t1 = 0.6 - x1*x1 - y1*y1 - z1*z1;
  if(t1<0) {
    n1 = 0.0;
  } else {
    t1 *= t1;
    n1 = t1 * t1 * this.dot(this.grad3[gi1], x1, y1, z1);
  }
  var t2 = 0.6 - x2*x2 - y2*y2 - z2*z2;
  if(t2<0) {
    n2 = 0.0;
  } else {
    t2 *= t2;
    n2 = t2 * t2 * this.dot(this.grad3[gi2], x2, y2, z2);
  }
  var t3 = 0.6 - x3*x3 - y3*y3 - z3*z3;
  if(t3<0) {
    n3 = 0.0;
  } else {
    t3 *= t3;
    n3 = t3 * t3 * this.dot(this.grad3[gi3], x3, y3, z3);
  }
  // Add contributions from each corner to get the final noise value.
  // The result is scaled to stay just inside [-1,1]
  return 32.0*(n0 + n1 + n2 + n3);
};

},{}],48:[function(require,module,exports){
/**
 * @fileoverview
 * AStar Path finding algorithm
 *
 * Use the `findRoute(map, from, to, [timeout])` function to get the linked list
 * leading `from` a point `to` another on the given `map`.
 *
 * The map must implement interface `gamejs.pathfinding.Map`. This
 * class really holds an example implementation & data for you to study. If you
 * understand what this calls provides, you understand this module.
 *
 * Optionally, the search is cancelled after `timeout` in millseconds.
 *
 * If there is no route `null` is returned.
 *
 * @see http://eloquentjavascript.net/chapter7.html
 */
var BinaryHeap = require('../utils/binaryheap').BinaryHeap;

/**
 * helper function for A*
 */
function ReachedList(hashFn) {
   var list = {};

   this.store = function(point, route) {
      list[hashFn(point)] = route;
      return;
   };

   this.find = function(point) {
      return list[hashFn(point)];
   };
   return this;
}


/** A* search function.
 *
 * This function expects a `Map` implementation and the origin and destination
 * points given. If there is a path between the two it will return the optimal
 * path as a linked list. If there is no path it will return null.
 *
 * The linked list is in reverse order: the first item is the destination and
 * the path to the origin follows.
 *
 * @param {Map} map map instance, must follow interface defined in {Map}
 * @param {Array} origin
 * @param {Array} destination
 * @param {Number} timeout milliseconds after which search should be canceled
 * @returns {Object} the linked list leading from `to` to `from` (sic!).
 **/
exports.findRoute = function(map, from, to, timeout) {
   var open = new BinaryHeap(routeScore);
   var hashFn = typeof map.hash === 'function' ? map.hash : defaultHash;
   var reached = new ReachedList(hashFn);

   function routeScore(route) {
      if (route.score === undefined) {
         route.score = map.estimatedDistance(route.point, to) + route.length;
      }
      return route.score;
   }
   function addOpenRoute(route) {
      open.push(route);
      reached.store(route.point, route);
   }

   function processNewPoints(direction) {
      var known = reached.find(direction);
      var newLength = route.length + map.actualDistance(route.point, direction);
      if (!known || known.length > newLength){
         if (known) {
            open.remove(known);
         }
         addOpenRoute({
            point: direction,
            from: route,
            length: newLength
         });
      }
   }
   var startMs = Date.now();
   var route = null;
   addOpenRoute({
      point: from,
      from: null,
      length: 0
   });
   var equalsFn = typeof map.equals === 'function' ? map.equals : defaultEquals;
   while (open.size() > 0 && (!timeout || Date.now() - startMs < timeout)) {
      route = open.pop();
      if (equalsFn(to, route.point)) {
         return route;
      }
      map.adjacent(route.point).forEach(processNewPoints);
   } // end while
   return null;
};

var defaultEquals = function(a, b) {
   return a[0] === b[0] && a[1] === b[1];
};

var defaultHash = function(a) {
   return a[0] + '-' + a[1];
};

/**
 * This is the interface for a Map that can be passed to the `findRoute()`
 * function. `Map` is not instantiable - see the unit tests for an example
 * implementation of Map.
 */
var Map = exports.Map = function() {
   throw new Error('not instantiable, this is an interface');
};

/**
 * @param {Array} origin
 * @returns {Array} list of points accessible from given Point
 */
Map.prototype.adjacent = function(origin) {
};

/**
 * @param {Object} a one of the points ot test for equality
 * @param {Object} b ... the other point
 * @returns Wheter the two points are equal.
 */
Map.prototype.equals = defaultEquals;

/**
 * @param {Object} a point
 * @returns {String} hash for the point
 */
Map.prototype.hash = defaultHash;

/**
 * Estimated lower bound distance between two points.
 * @param {Object} pointA
 * @param {Object} pointB
 * @returns {Number} the estimated distance between two points
 */
Map.prototype.estimatedDistance = function(pointA, pointB) {
   return 1;
};

/**
 * Actual distance between two points.
 * @param {Object} pointA
 * @param {Object} pointB
 * @returns {Number} the actual distance between two points
 */
Map.prototype.actualDistance = function(pointA, pointB) {
   return 1;
};

},{"../utils/binaryheap":56}],49:[function(require,module,exports){
var gamejs = require('../gamejs');
var arrays = require('./utils/arrays');
var $o = require('./utils/objects');
var $v = require('./utils/vectors');

/**
 * @fileoverview Provides `Sprite` the basic building block for any game and
 * `SpriteGroups`, which are an efficient
 * way for doing collision detection between groups as well as drawing layered
 * groups of objects on the screen.
 *
 */

/**
 * Your visible game objects will typically subclass Sprite. By setting it's image
 * and rect attributes you can control its appeareance. Those attributes control
 * where and what `Sprite.draw(surface)` will blit on the the surface.
 *
 * Your subclass should overwrite `update(msDuration)` with its own implementation.
 * This function is called once every game tick, it is typically used to update
 * the status of that object.
 * @constructor
 */
var Sprite = exports.Sprite = function() {
   /** @ignore */
   this._groups = [];
   /** @ignore */
   this._alive = true;

   /**
    * Image to be rendered for this Sprite.
    * @type gamejs.Surface
    */
   this.image = null;
   /**
    * Rect describing the position of this sprite on the display.
    * @type gamejs.Rect
    */
   this.rect = null;

   /**
    * List of all groups that contain this sprite.
    */
   $o.accessor(this, 'groups', function() {
      return this._groups;
   });

   return this;
};

/**
 * Kill this sprite. This removes the sprite from all associated groups and
 * makes future calls to `Sprite.isDead()` return `true`
 */
Sprite.prototype.kill = function() {
   this._alive = false;
   this._groups.forEach(function(group) {
      group.remove(this);
   }, this);
   return;
};

/**
 * Remove the sprite from the passed groups
 * @param {Array|gamejs.sprite.Group} groups One or more `gamejs.Group`
 * instances
 */
Sprite.prototype.remove = function(groups) {
   if (!(groups instanceof Array)) {
      groups = [groups];
   }

   groups.forEach(function(group) {
      group.remove(this);
   }, this);
   return;
};

/**
 * Add the sprite to the passed groups
 * @param {Array|gamejs.sprite.Group} groups One or more `gamejs.sprite.Group`
 * instances
 */
Sprite.prototype.add = function(groups) {
   if (!(groups instanceof Array)) {
      groups = [groups];
   }

   groups.forEach(function(group) {
      group.add(this);
   }, this);
   return;
};


/**
 * Returns an array of all the Groups that contain this Sprite.
 * @returns {Array} an array of groups
 */
Sprite.prototype.groups = function() {
   return this._groups.slice(0);
};

/**
 * Draw this sprite onto the given surface. The position is defined by this
 * sprite's rect.
 * @param {gamejs.Surface} surface The surface to draw on
 */
Sprite.prototype.draw = function(surface) {
   surface.blit(this.image, this.rect);
   return;
};

/**
 * Update this sprite. You **should** override this method with your own to
 * update the position, status, etc.
 */
Sprite.prototype.update = function() {};

/**
 * @returns {Boolean} True if this sprite has had `Sprite.kill()` called on it
 * previously, otherwise false
 */
Sprite.prototype.isDead = function() {
   return !this._alive;
};

/**
 * Sprites are often grouped. That makes collision detection more efficient and
 * improves rendering performance. It also allows you to easly keep track of layers
 * of objects which are rendered to the screen in a particular order.
 *
 * `Group.update()` calls `update()` on all the contained sprites; the same is true for `draw()`.
 * @constructor
 */
var Group = exports.Group = function() {
   /** @ignore */
   this._sprites = [];


   if (arguments[0] instanceof Sprite ||
      (arguments[0] instanceof Array &&
       arguments[0].length &&
       arguments[0][0] instanceof Sprite
   )) {
      this.add(arguments[0]);
   }
   return this;
};

/**
 * Update all the sprites in this group. This is equivalent to calling the
 * update method on each sprite in this group.
 */
Group.prototype.update = function() {
   var updateArgs = arguments;

   this._sprites.forEach(function(sp) {
      sp.update.apply(sp, updateArgs);
   }, this);
   return;
};

/**
 * Add one or more sprites to this group
 * @param {Array|gamejs.sprite.Sprite} sprites One or more
 * `gamejs.sprite.Sprite` instances
 */
Group.prototype.add = function(sprites) {
   if (!(sprites instanceof Array)) {
      sprites = [sprites];
   }

   sprites.forEach(function(sprite) {
      this._sprites.push(sprite);
      sprite._groups.push(this);
   }, this);
   return;
};

/**
 * Remove one or more sprites from this group
 * @param {Array|gamejs.sprite.Sprite} sprites One or more
 * `gamejs.sprite.Sprite` instances
 */
Group.prototype.remove = function(sprites) {
   if (!(sprites instanceof Array)) {
      sprites = [sprites];
   }

   sprites.forEach(function(sp) {
      arrays.remove(sp, this._sprites);
      arrays.remove(this, sp._groups);
   }, this);
   return;
};

/**
 * Check for the existence of one or more sprites within a group
 * @param {Array|gamejs.sprite.Sprite} sprites One or more
 * `gamejs.sprite.Sprite` instances
 * @returns {Boolean} True if every sprite is in this group, false otherwise
 */
Group.prototype.has = function(sprites) {
   if (!(sprites instanceof Array)) {
      sprites = [sprites];
   }

   return sprites.every(function(sp) {
      return this._sprites.indexOf(sp) !== -1;
   }, this);
};

/**
 * Get the sprites in this group
 * @returns {Array} An array of `gamejs.sprite.Sprite` instances
 */
Group.prototype.sprites = function() {
   return this._sprites;
};

/**
 * Draw all the sprites in this group. This is equivalent to calling each
 * sprite's draw method.
 */
Group.prototype.draw = function() {
   var args = arguments;
   this._sprites.forEach(function(sprite) {
      sprite.draw.apply(sprite, args);
   }, this);
   return;
};

/**
 * Draw background (`source` argument) over each sprite in the group
 * on the `destination` surface.
 *
 * This can, for example, be used to clear the
 * display surface to a a static background image in all the places
 * occupied by the sprites of all group.
 *
 * @param {gamejs.Surface} destination the surface to draw on
 * @param {gamejs.Surface} source surface
 */
Group.prototype.clear = function(destination, source) {
   this._sprites.forEach(function(sprite) {
      destination.blit(source, sprite.rect);
   }, this);
};

/**
 * Remove all sprites from this group
 */
Group.prototype.empty = function() {
   this._sprites = [];
   return;
};

/**
 * @returns {Array} of sprites colliding with the point
 */
Group.prototype.collidePoint = function() {
   var args = Array.prototype.slice.apply(arguments);
   return this._sprites.filter(function(sprite) {
      return sprite.rect.collidePoint.apply(sprite.rect, args);
   }, this);
};

/**
 * Loop over each sprite in this group. This is a shortcut for
 * `group.sprites().forEach(...)`.
 */
Group.prototype.forEach = function(callback, thisArg) {
   return this._sprites.forEach(callback, thisArg);
};

/**
 * Check whether some sprite in this group passes a test. This is a shortcut
 * for `group.sprites().some(...)`.
 */
Group.prototype.some = function(callback, thisArg) {
   return this._sprites.some(callback, thisArg);
};

/**
 * Find sprites in a group that intersect another sprite
 * @param {gamejs.sprite.Sprite} sprite The sprite to check
 * @param {gamejs.sprite.Group} group The group to check
 * @param {Boolean} doKill If true, kill sprites in the group when collided
 * @param {function} collided Collision function to use, defaults to `gamejs.sprite.collideRect`
 * @returns {Array} An array of `gamejs.sprite.Sprite` instances that collided
 */
exports.spriteCollide = function(sprite, group, doKill, collided) {
   collided = collided || collideRect;
   doKill = doKill || false;

   var collidingSprites = [];
   group.sprites().forEach(function(groupSprite) {
      if (collided(sprite, groupSprite)) {
         if (doKill) {
            groupSprite.kill();
         }
         collidingSprites.push(groupSprite);
      }
   });
   return collidingSprites;
};

/**
 * Find all Sprites that collide between two Groups.
 *
 * @example
 * groupCollide(group1, group2).forEach(function (collision) {
 *    var group1Sprite = collision.a;
 *    var group2Sprite = collision.b;
 *    // Do processing here!
 * });
 *
 * @param {gamejs.sprite.Group} groupA First group to check
 * @param {gamejs.sprite.Group} groupB Second group to check
 * @param {Boolean} doKillA If true, kill sprites in the first group when
 * collided
 * @param {Boolean} doKillB If true, kill sprites in the second group when
 * collided
 * @param {function} collided Collision function to use, defaults to `gamejs.sprite.collideRect`
 * @returns {Array} A list of objects where properties 'a' and 'b' that
 * correspond with objects from the first and second groups
 */
exports.groupCollide = function(groupA, groupB, doKillA, doKillB, collided) {
   doKillA = doKillA || false;
   doKillB = doKillB || false;

   var collideList = [];
   var collideFn = collided || collideRect;
   groupA.sprites().forEach(function(groupSpriteA) {
      groupB.sprites().forEach(function(groupSpriteB) {
         if (collideFn(groupSpriteA, groupSpriteB)) {
            if (doKillA) {
               groupSpriteA.kill();
            }
            if (doKillB) {
               groupSpriteB.kill();
            }

            collideList.push({
               'a': groupSpriteA,
               'b': groupSpriteB
            });
         }
      });
   });

   return collideList;
};

/**
 * Check for collisions between two sprites using their rects.
 *
 * @param {gamejs.sprite.Sprite} spriteA First sprite to check
 * @param {gamejs.sprite.Sprite} spriteB Second sprite to check
 * @returns {Boolean} True if they collide, false otherwise
 */
var collideRect = exports.collideRect = function (spriteA, spriteB) {
   return spriteA.rect.collideRect(spriteB.rect);
};

/**
 * Collision detection between two sprites utilizing the optional `mask`
 * attribute on the sprites. Beware: expensive operation.
 *
 * @param {gamejs.sprite.Sprite} spriteA Sprite with 'mask' property set to a `gamejs.mask.Mask`
 * @param {gamejs.sprite.Sprite} spriteB Sprite with 'mask' property set to a `gamejs.mask.Mask`
 * @returns {Boolean} True if any mask pixels collide, false otherwise
 */
exports.collideMask = function(spriteA, spriteB) {
   if (!spriteA.mask || !spriteB.mask) {
      throw new Error("Both sprites must have 'mask' attribute set to an gamejs.mask.Mask");
   }
   var offset = [
      spriteB.rect.left - spriteA.rect.left,
      spriteB.rect.top - spriteA.rect.top
   ];
   return spriteA.mask.overlap(spriteB.mask, offset);
};

/**
 * Collision detection between two sprites using circles at centers.
 * There sprite property `radius` is used if present, otherwise derived from bounding rect.
 * @param {gamejs.sprite.Sprite} spriteA First sprite to check
 * @param {gamejs.sprite.Sprite} spriteB Second sprite to check
 * @returns {Boolean} True if they collide, false otherwise
 */
exports.collideCircle = function(spriteA, spriteB) {
   var rA = spriteA.radius || Math.max(spriteA.rect.width, spriteA.rect.height);
   var rB = spriteB.radius || Math.max(spriteB.rect.width, spriteB.rect.height);
   return $v.distance(spriteA.rect.center, spriteB.rect.center) <= rA + rB;
};

},{"../gamejs":37,"./utils/arrays":54,"./utils/objects":59,"./utils/vectors":62}],50:[function(require,module,exports){
var gamejs = require('../gamejs');
var accessors = require('./utils/objects').accessors;
/**
 * @fileoverview Fast pixel access.
 *
 * @example
 *
 *   // create array from display surface
 *   var srfArray = new SurfaceArray(display);
 *   // direct pixel access
 *   srfArray.set(50, 100, [255, 0, 0, 100]);
 *   console.log(srfArray.get(30, 50));
 *   // blit modified array back to display surface
 *   blitArray(display, srfArray);
 */

/**
 * Directly copy values from an array into a Surface.
 *
 * This is faster than blitting the `surface` property on a SurfaceArray
 *
 * The array must be the same dimensions as the Surface and will completely
 * replace all pixel values.
 * @param {gamejs.Surface} surface
 * @param {gamejs.surfacearray.SurfaceArray} surfaceArray
 */
exports.blitArray = function(surface, surfaceArray) {
   surface.context.putImageData(surfaceArray.imageData, 0, 0);
   return;
};

/**
 * The SurfaceArray can be constructed with a surface whose values
 * are then used to initialize the pixel array.
 *
 * The surface passed as argument is not modified by the SurfaceArray.
 *
 * If an array is used to construct SurfaceArray, the array must describe
 * the dimensions of the SurfaceArray [width, height].
 *
 * @param {gamejs.Surface|Array} surfaceOrDimensions
 * @see http://dev.w3.org/html5/2dcontext/#pixel-manipulation
 */
var SurfaceArray = exports.SurfaceArray = function(surfaceOrDimensions) {
   var size = null;
   var data = null;
   var imageData = null;

   /**
    * Set rgba value at position x, y.
    *
    * For performance reasons this function has only one signature
    * being Number, Number, Array[4].
    *
    * @param {Number} x x position of pixel
    * @param {Number} y y position of pixel
    * @param {Array} rgba [red, green, blue, alpha] values [255, 255, 255, 255] (alpha, the last argument defaults to 255)
    * @throws Error if x, y out of range
    */
   this.set = function(x, y, rgba) {
      var offset = (x * 4) + (y * size[0] * 4);
      /** faster without
      if (offset + 3 >= data.length || x < 0 || y < 0) {
         throw new Error('x, y out of range', x, y);
      }
      **/
      data[offset] = rgba[0];
      data[offset+1] = rgba[1];
      data[offset+2] = rgba[2];
      data[offset+3] = rgba[3] === undefined ? 255 : rgba[3];
      return;
   };

   /**
    * Get rgba value at position xy,
    * @param {Number} x
    * @param {Number} y
    * @returns {Array} [red, green, blue, alpha]
    */
   this.get = function(x, y) {
      var offset = (x * 4) + (y * size[0] * 4);
      return [
         data[offset],
         data[offset+1],
         data[offset+2],
         data[offset+3]
      ];
   };

   /**
    * a new gamejs.Surface on every access, representing
    * the current state of the SurfaceArray.
    * @type {gamejs.Surface}
    */
   // for jsdoc only
   this.surface = null;

   accessors(this, {
      surface: {
         get: function() {
            var s = new gamejs.Surface(size);
            s.context.putImageData(imageData, 0, 0);
            return s;
         }
      },
      imageData: {
         get: function() {
            return imageData;
         }
      }
   });

   this.getSize = function() {
      return size;
   };

   /**
    * constructor
    */
   if (surfaceOrDimensions instanceof Array) {
      size = surfaceOrDimensions;
      imageData = gamejs.display.getSurface().context.createImageData(size[0], size[1]);
      data = imageData.data;
   } else {
      size = surfaceOrDimensions.getSize();
      imageData = surfaceOrDimensions.getImageData(0, 0, size[0], size[1]);
      data = imageData.data;
   }
   return this;
};

},{"../gamejs":37,"./utils/objects":59}],51:[function(require,module,exports){
/**
 * @fileoverview
 * Only used by GameJs internally to provide a game loop.
 * @ignore
 */

var Callback = require('./callback').Callback;

var TIMER_LASTCALL = null;
var STARTTIME = null;

/** @ignore **/
var _CALLBACK = exports._CALLBACK = new Callback(function(){}, {});
// `window` is not accessible in webworker (would lead to TypeError)
// @@ this cross-browser fuckery has to go away ASAP.
var reqAnimationFrame = typeof(window) != 'undefined' ?
                        window.requestAnimationFrame ||
                        window.webkitRequestAnimationFrame ||
                        window.mozRequestAnimationFrame ||
                        window.oRequestAnimationFrame ||
                        window.msRequestAnimationFrame ||
                        null : null;

var reqAniFrameRecursive = function() {
   perInterval();
   reqAnimationFrame(reqAniFrameRecursive);
};

/**
 * @ignore
 */
exports.init = function() {
   STARTTIME = Date.now();

   if (reqAnimationFrame) {
      reqAnimationFrame(reqAniFrameRecursive);
   } else {
      setInterval(perInterval, 10);
   }
   return;
};

var perInterval = function() {
   var msNow = Date.now();
   exports._CALLBACK.trigger(msNow - (TIMER_LASTCALL || msNow));
   TIMER_LASTCALL = msNow;
   return;
};

},{"./callback":38}],52:[function(require,module,exports){
var gamejs = require('../gamejs');
var objects = require('./utils/objects');
var xml = require('./xml');
var base64 = require('./utils/base64');
var uri = require('./utils/uri');

/**
 * @fileoverview
 * This is a loader for the general purpose tile map editor "Tiled".
 *
 * This module can load all ".tmx" files even if additionally base64 encoded
 * (can be configured in Tiled).
 *
 * This module loads the whole map definition, including the TileSets with
 * all necessary images. For an example on how to render a map loaded with
 * this module, see `examples/tiledmap`.
 *
 * You will typically create a Map instance with `Map(url)` and deal
 * with the layers, tilesets, etc. through the Map instance
 * instead of loading & creating them yourself.
 *
 * Only orthogonol maps are supported (no isometric maps).
 *
 * @see http://www.mapeditor.org/
 * @see https://github.com/bjorn/tiled/wiki/TMX-Map-Format
 */

/**
 * My code is inspired by:
 *   * https://bitbucket.org/maikg/tiled2cocos/
 *   * https://github.com/obiot/melonJS/
 *
 */

/**
 * A Tiled Map holds all layers defined in the tmx file as well
 * as the necessary tiles to render the map.
 * @param {String} url Relative or absolute URL to the tmx file
 */
var Map = exports.Map = function(url) {

   url = uri.resolve(document.location.href, url);
   var xmlDoc = xml.Document.fromURL(url);
   var mapNode = xmlDoc.element('map');

   /**
    * Width of a single tile in pixels
    * @type Number
    */
   this.tileWidth = mapNode.attribute('tilewidth');
   /**
    * Height of a single tile in pixels
    * @type Number
    */
   this.tileHeight = mapNode.attribute('tileheight');
   /**
    * Width of the map in tiles
    * @type Number
    */
   this.width = mapNode.attribute('width');
   /**
    * Height of the map in tiles
    * @type Number
    */
   this.height = mapNode.attribute('height');

   var orientation = mapNode.attribute('orientation');
   if (orientation !== 'orthogonal') {
      throw new Error('only orthogonol maps supported');
   }

   /**
    * Custom properties of the map
    */
   this.properties = {};
   setProperties(this.properties, mapNode);

   /**
    * All tiles of this map.
    * @type TileSets
    */
   this.tiles = new TileSets(mapNode, url);
   this.layers = loadLayers(mapNode);
   return this;
};

/**
 * A Tile. Can not be instantiated. Get a Tile by calling `getTile(gid)`
 * on a `TileSets` instance.
 */
var Tile = exports.Tile = function() {
   throw new Error('Can not be instantiated.');
   /**
    * @type {gamejs.Surface} this tile's Surface
    */
   this.surface = null;
   /**
    * @type {Object} custom properties attach for this tile
    */
   this.properties = null;
   return;
};

/**
 * A TileSets instance holds all tilesets of a map. This class
 * makes it easy to get the image for a certain tile ID. You usually
 * don't care about in which specific TileSet an image is so this
 * class holds them all and deals with the lookup.
 *
 * You don't usually create a `TileSets` instance yourself, instead
 * it is automatically created and attached to a `Map`.
 */
var TileSets = exports.TileSets = function(mapNode, mapUrl) {
   var tileSets = [];

   /**
    * Retrieve the image for a tile ID (gid).
    *
    * @param {Number} gid global tile id to retrieve
    * @returns {gamejs.Surface} the Surface for the gid
    */
   this.getSurface = function(gid) {
      var tile = this.getTile(gid);
      return tile && tile.surface || null;
   };

   /**
    * @param {Number} gid global tile id
    * @returns {Object} the custom properties of this tile
    */
   this.getProperties = function(gid) {
      var tile = this.getTile(gid);
      return tile && tile.properties || {};
   };

   /**
    * @param {Number} gid global tile id
    * @returns {Object} the Tile object for this gid
    */
   this.getTile = function(gid) {
      var tile = null;
      tileSets.some(function(tileSet, idx) {
         if (tileSet.firstGid <= gid) {
            tile = tileSet.tiles[gid - tileSet.firstGid];
            return true;
         }
         return false;
      }, this);
      return tile;
   };

   var loadTileSet = function(tileSetNode) {
      var tiles = [];
      var tileWidth = tileSetNode.attribute('tilewidth');
      var tileHeight = tileSetNode.attribute('tileheight');
      var spacing = tileSetNode.attribute('spacing') || 0;
      // broken in tiled?
      var margin = 0;

      var imageNode = tileSetNode.element('image');
      var imageAtlasFile = imageNode.attribute('source');
      var imageUrl = uri.makeRelative(uri.resolve(mapUrl, imageAtlasFile));
      var atlas = gamejs.image.load(imageUrl);
      // FIXME set transparency if imageNode.attribute('trans') is set

      var tileNodes = tileSetNode.elements('tile');
      var dims = atlas.getSize();
      var imgSize = new gamejs.Rect([0,0], [tileWidth, tileHeight]);
      var idx = 0;
      var y = 0;
      while (y + tileHeight <= dims[1]) {
         x = 0;
         while (x + tileWidth <= dims[0]) {
            var tileImage = new gamejs.Surface(tileWidth, tileHeight);
            var rect = new gamejs.Rect([x, y], [tileWidth, tileHeight]);
            tileImage.blit(atlas, imgSize, rect);
            var tileProperties = {};
            tileNodes.some(function(tileNode) {
               if (tileNode.attribute('id') === idx) {
                  setProperties(tileProperties, tileNode);
                  return true;
               }
            }, this);
            tiles.push({
               surface: tileImage,
               properties: tileProperties
            });
            x += tileWidth + spacing;
            idx++;
         }
         y += tileHeight + spacing;
      }
      return tiles;
   };

   /**
    *
    * constructor
    **/
   mapNode.elements('tileset').forEach(function(tileSetNode) {
      var firstGid = tileSetNode.attribute('firstgid');
      var externalSource = tileSetNode.attribute('source');
      if (externalSource) {
         var tileSetDocument = xml.Document.fromURL(uri.resolve(mapUrl, externalSource));
         tileSetNode = tileSetDocument.element('tileset');
      }
      tileSets.push({
         tiles: loadTileSet(tileSetNode),
         firstGid: firstGid
      });
   });
   tileSets.reverse();

   return this;
};

/**
 * loadLayers
 */
var H_FLIP = 0x80000000;
var V_FLIP = 0x40000000;
var loadLayers = function(mapNode) {
   var layers = [];

   var getGids = function(layerNode) {
      var dataNode = layerNode.element('data');
      var encoding = dataNode.attribute('encoding');
      var compression = dataNode.attribute('compression');
      var data = "";
      dataNode.children().forEach(function(textNode) {
         data += textNode.value();
      });
      var byteData = [];
      if (encoding === 'base64') {
         if (compression) {
            throw new Error('Compression of map data unsupported');
         }
         byteData = base64.decodeAsArray(data, 4);
      } else if (encoding === 'csv') {
         data.trim().split('\n').forEach(function(row) {
            row.split(',', width).forEach(function(entry) {
               byteData.push(parseInt(entry, 10));
            });
         });
      } else {
         // FIXME individual XML tile elements
         throw new Error('individual tile format not supported');
      }
      return byteData;
   };

   var width = mapNode.attribute('width');
   var height = mapNode.attribute('height');
   mapNode.elements('layer').forEach(function(layerNode) {
      // create empty gid matrix
      var gidMatrix = [];
      var i = height;
      while (i-->0) {
         var j = width;
         gidMatrix[i] = [];
         while (j-->0) {
            gidMatrix[i][j] = 0;
         }
      }

      getGids(layerNode).forEach(function(gid, idx) {
         // FIXME flipX/Y currently ignored
         var flipX = gid & H_FLIP;
         var flipY = gid & V_FLIP;
         // clear flags
         gid &= ~(H_FLIP | V_FLIP);
         gidMatrix[parseInt(idx / width, 10)][parseInt(idx % width, 10)] = gid;
      });
      layers.push({
         gids: gidMatrix,
         opacity: layerNode.attribute('opacity'),
         visible: layerNode.attribute('visible'),
         properties: setProperties({}, layerNode)
      });
   });
   return layers;
};

/**
 * set generic <properties><property name="" value="">... on given object
 */
var setProperties = function(object, node) {
   var props = node.element('properties');
   if (!props) {
      return;
   }
   props.elements('property').forEach(function(propertyNode) {
      var name = propertyNode.attribute('name');
      var value = propertyNode.attribute('value');
      object[name] = value;
   });
   return object;
};

},{"../gamejs":37,"./utils/base64":55,"./utils/objects":59,"./utils/uri":61,"./xml":64}],53:[function(require,module,exports){
var Surface = require('../gamejs').Surface;
var matrix = require('./utils/matrix');
var math = require('./utils/math');
var vectors = require('./utils/vectors');

/**
 * @fileoverview Rotate and scale Surfaces.
 */

/**
 * Returns a new surface which holds the original surface rotate by angle degrees.
 * Unless rotating by 90 degree increments, the image will be padded larger to hold the new size.
 * @param {Surface} surface
 * @param {angel} angle Clockwise angle by which to rotate
 * @returns {Surface} new, rotated surface
 */
exports.rotate = function (surface, angle) {
   var origSize = surface.getSize();
   var radians = (angle * Math.PI / 180);
   var newSize = origSize;
   // find new bounding box
   if (angle % 360 !== 0) {
      var rect = surface.getRect();
      var points = [
         [-rect.width/2, rect.height/2],
         [rect.width/2, rect.height/2],
         [-rect.width/2, -rect.height/2],
         [rect.width/2, -rect.height/2]
      ];
      var rotPoints = points.map(function(p) {
         return vectors.rotate(p, radians);
      });
      var xs = rotPoints.map(function(p) { return p[0]; });
      var ys = rotPoints.map(function(p) { return p[1]; });
      var left = Math.min.apply(Math, xs);
      var right = Math.max.apply(Math, xs);
      var bottom = Math.min.apply(Math, ys);
      var top = Math.max.apply(Math, ys);
      newSize = [right-left, top-bottom];
   }
   var newSurface = new Surface(newSize);
   var oldMatrix = surface._matrix;
   surface._matrix = matrix.translate(surface._matrix, origSize[0]/2, origSize[1]/2);
   surface._matrix = matrix.rotate(surface._matrix, radians);
   surface._matrix = matrix.translate(surface._matrix, -origSize[0]/2, -origSize[1]/2);
   var offset = [(newSize[0] - origSize[0]) / 2, (newSize[1] - origSize[1]) / 2];
   newSurface.blit(surface, offset);
   surface._matrix = oldMatrix;
   return newSurface;
};

/**
 * Returns a new surface holding the scaled surface.
 * @param {Surface} surface
 * @param {Array} dimensions new [width, height] of surface after scaling
 * @returns {Surface} new, scaled surface
 */
exports.scale = function(surface, dims) {
   var width = dims[0];
   var height = dims[1];
   if (width <= 0 || height <= 0) {
      throw new Error('[gamejs.transform.scale] Invalid arguments for height and width', [width, height]);
   }
   var oldDims = surface.getSize();
   var ws = width / oldDims[0];
   var hs = height / oldDims[1];
   var newSurface = new Surface([width, height]);
   var originalMatrix = surface._matrix.slice(0);
   surface._matrix = matrix.scale(surface._matrix, [ws, hs]);
   newSurface.blit(surface);
   surface._matrix = originalMatrix;
   return newSurface;
};

/**
 * Flip a Surface either vertically, horizontally or both. This returns
 * a new Surface (i.e: nondestructive).
 * @param {gamejs.Surface} surface
 * @param {Boolean} flipHorizontal
 * @param {Boolean} flipVertical
 * @returns {Surface} new, flipped surface
 */
exports.flip = function(surface, flipHorizontal, flipVertical) {
   var dims = surface.getSize();
   var newSurface = new Surface(dims);
   var scaleX = 1;
   var scaleY = 1;
   var xPos = 0;
   var yPos = 0;
   if (flipHorizontal === true) {
      scaleX = -1;
      xPos = -dims[0];
   }
   if (flipVertical === true) {
      scaleY = -1;
      yPos = -dims[1];
   }
   newSurface.context.save();
   newSurface.context.scale(scaleX, scaleY);
   newSurface.context.drawImage(surface.canvas, xPos, yPos);
   newSurface.context.restore();
   return newSurface;
};

},{"../gamejs":37,"./utils/math":57,"./utils/matrix":58,"./utils/vectors":62}],54:[function(require,module,exports){
/**
 * @fileoverview Utility functions for working with Obiects
 * @param {Object} item
 * @param {Array} array
 * @param {Object} returns removed item or null
 */

exports.remove = function(item, array) {
   var index = array.indexOf(item);
   if (index !== -1) {
      return array.splice(array.indexOf(item), 1);
   }
   return null;
};

/**
 * Shuffles the array *in place*.
 * @see http://en.wikipedia.org/wiki/Fisher%E2%80%93Yates_shuffle
 */
exports.shuffle = function(array) {
    var len = array.length -1;
    for (i = len; i > 0; i--) {
        var idx = parseInt(Math.random() * (i + 1), 10);
        var item = array[i];
        array[i] = array[idx];
        array[idx] = item;
    }
    return array;
};

},{}],55:[function(require,module,exports){
/**
 * @fileoverview
 * Base64 encode / decode
 * @author http://www.webtoolkit.info
 */


var keyStr = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=";

/**
 * Decodes a base64 encoded string to a string.
 */
var decode = exports.decode = function(input) {
   var output = [], chr1, chr2, chr3, enc1, enc2, enc3, enc4, i = 0;
   input = input.replace(/[^A-Za-z0-9\+\/\=]/g, "");

   while (i < input.length) {
      enc1 = keyStr.indexOf(input.charAt(i++));
      enc2 = keyStr.indexOf(input.charAt(i++));
      enc3 = keyStr.indexOf(input.charAt(i++));
      enc4 = keyStr.indexOf(input.charAt(i++));

      chr1 = (enc1 << 2) | (enc2 >> 4);
      chr2 = ((enc2 & 15) << 4) | (enc3 >> 2);
      chr3 = ((enc3 & 3) << 6) | enc4;

      output.push(String.fromCharCode(chr1));

      if (enc3 != 64) {
         output.push(String.fromCharCode(chr2));
      }
      if (enc4 != 64) {
         output.push(String.fromCharCode(chr3));
      }
   }

   output = output.join('');
   return output;
};

/**
 * Decodes a base64 encoded string into a byte array
 * @param {String} input
 * @param {Array} bytes bytes per character, defaults to 1
 */
exports.decodeAsArray = function(input, bytes) {
   bytes = bytes || 1;
   var decoded = decode(input);
   var len = decoded.length / bytes;
   var array = [];
   var i,j;
   for (i=0; i< len; i++) {
      array[i] = 0;
      for (j = bytes - 1; j >=0; --j) {
         array[i] += decoded.charCodeAt((i * bytes) + j) << (j <<3 );
      }
   }
   return array;
}
;
},{}],56:[function(require,module,exports){
/**
 * Binary Heap
 *
 * @see http://eloquentjavascript.net/appendix2.html
 */
var BinaryHeap = exports.BinaryHeap = function(scoreFunction){
   /**
    * @ignore
    */
   this.content = [];
   /**
    * @ignore
    */
   this.scoreFunction = scoreFunction;
   return this;
};

/**
 * Add element to heap.
 * @param {Object} element
 */
BinaryHeap.prototype.push = function(element) {
   this.content.push(element);
   this.sinkDown(this.content.length - 1);
   return;
};

/**
 * Return first element from heap.
 * @param {Object} element
 * @returns {Object} element
 */
BinaryHeap.prototype.pop = function() {
   // Store the first element so we can return it later.
   var result = this.content[0];
   // Get the element at the end of the array.
   var end = this.content.pop();
   // If there are any elements left, put the end element at the
   // start, and let it bubble up.
   if (this.content.length > 0) {
      this.content[0] = end;
      this.bubbleUp(0);
   }
   return result;
};

/**
 * Remove the given element from the heap.
 * @param {Object} element
 * @throws {Error} if node not found
 */
BinaryHeap.prototype.remove = function(node) {
   // To remove a value, we must search through the array to find
   // it.
   var isFound = this.content.some(function(cNode, idx) {
      if (cNode == node) {
         var end = this.content.pop();
         if (idx != this.content.length) {
            this.content[idx] = end;
            if (this.scoreFunction(end) < this.scoreFunction(node)) {
               this.sinkDown(idx);
            } else {
               this.bubbleUp(idx);
            }
         }
         return true;
      }
      return false;
   }, this);
   if (!isFound) {
      //throw new Error("Node not found.");
   }
   return;
};

/**
 * Number of elements in heap.
 */
BinaryHeap.prototype.size = function() {
   return this.content.length;
};

/**
 * @ignore
 */
BinaryHeap.prototype.sinkDown = function(idx) {
   // Fetch the element that has to be sunk
   var element = this.content[idx];
   // When at 0, an element can not sink any further.
   while (idx > 0) {
      // Compute the parent element's index, and fetch it.
      var parentIdx = Math.floor((idx + 1) / 2) - 1;
      var parent = this.content[parentIdx];
      // Swap the elements if the parent is greater.
      if (this.scoreFunction(element) < this.scoreFunction(parent)) {
         this.content[parentIdx] = element;
         this.content[idx] = parent;
         // Update 'n' to continue at the new position.
         idx = parentIdx;
      // Found a parent that is less, no need to sink any further.
      } else {
         break;
      }
   }
   return;
};

/**
 * @ignore
 */
BinaryHeap.prototype.bubbleUp = function(idx) {
   // Look up the target element and its score.
   var length = this.content.length;
   var element = this.content[idx];
   var elemScore = this.scoreFunction(element);

   while(true) {
      // Compute the indices of the child elements.
      var child2Idx = (idx + 1) * 2;
      var child1Idx= child2Idx - 1;
      // This is used to store the new position of the element,
      // if any.
      var swapIdx = null;
      // If the first child exists (is inside the array)...
      if (child1Idx < length) {
         // Look it up and compute its score.
         var child1 = this.content[child1Idx];
         var child1Score = this.scoreFunction(child1);
         // If the score is less than our element's, we need to swap.
         if (child1Score < elemScore) {
            swapIdx = child1Idx;
         }
      }
      // Do the same checks for the other child.
      if (child2Idx < length) {
         var child2 = this.content[child2Idx];
         var child2Score = this.scoreFunction(child2);
         if (child2Score < (swapIdx === null ? elemScore : child1Score)) {
            swapIdx = child2Idx;
         }
      }

      // If the element needs to be moved, swap it, and continue.
      if (swapIdx !== null) {
         this.content[idx] = this.content[swapIdx];
         this.content[swapIdx] = element;
         idx = swapIdx;
      // Otherwise, we are done.
      } else {
         break;
      }
   }
   return;
};

},{}],57:[function(require,module,exports){
/**
 *
 * absolute angle to relative angle, in degrees
 * @param {Number} absolute angle in degrees
 * @returns {Number} relative angle in degrees
 */
exports.normaliseDegrees=function(degrees){
    degrees=degrees % 360;
    if(degrees<0) {
        degrees+=360;
    }
    return degrees;
};

/**
 *
 * absolute angle to relative angle, in radians
 * @param {Number} absolute angle in radians
 * @returns {Number} relative angle in radians
 */
exports.normaliseRadians=function(radians){
    radians=radians % (2*Math.PI);
    if(radians<0) {
        radians+=(2*Math.PI);
    }
    return radians;
};

/**
 *
 * convert radians to degrees
 * @param {Number} radians
 * @returns {Number} degrees
 */
exports.degrees=function(radians) {
    return radians*(180/Math.PI);
};

/**
 *
 * convert degrees to radians
 * @param {Number} degrees
 * @returns {Number} radians
 */
exports.radians=function(degrees) {
    return degrees*(Math.PI/180);
};

/**
 * @returns the center of multipled 2d points
 * @param {Array} first point
 * @param {Array} second point
 * @param {Array} ...
 */
exports.centroid = function() {
   var args = Array.prototype.slice.apply(arguments, [0]);
   var c = [0,0];
   args.forEach(function(p) {
      c[0] += parseInt(p[0], 10);
      c[1] += parseInt(p[1], 10);
   });
   var len = args.length;
   return [
      c[0] / len,
      c[1] / len
   ];
};

},{}],58:[function(require,module,exports){
/**
 * @fileoverview Matrix manipulation, used by GameJs itself. You
 * probably do not need this unless you manipulate a Context's transformation
 * matrix yourself.
 */

// correct way to do scale, rotate, translate
// *  gamejs.utils.matrix will be used in gamejs.transforms, modifing the surfaces.matrix
// * this matrix must be applied to the context in Surface.draw()

/**
 * @returns {Array} [1, 0, 0, 1, 0, 0]
 */
var identiy = exports.identity = function () {
   return [1, 0, 0, 1, 0, 0];
};

/**
 * @param {Array} matrix
 * @param {Array} matrix
 * @returns {Array} matrix sum
 */
var add = exports.add = function(m1, m2) {
   return [
      m1[0] + m2[0],
      m1[1] + m2[1],
      m1[2] + m2[2],
      m1[3] + m2[3],
      m1[4] + m2[4],
      m1[5] + m2[5],
      m1[6] + m2[6]
   ];
};

/**
 * @param {Array} matrix A
 * @param {Array} matrix B
 * @returns {Array} matrix product
 */
var multiply = exports.multiply = function(m1, m2) {
   return [
      m1[0] * m2[0] + m1[2] * m2[1],
      m1[1] * m2[0] + m1[3] * m2[1],
      m1[0] * m2[2] + m1[2] * m2[3],
      m1[1] * m2[2] + m1[3] * m2[3],
      m1[0] * m2[4] + m1[2] * m2[5] + m1[4],
      m1[1] * m2[4] + m1[3] * m2[5] + m1[5]
   ];
};

/**
 * @param {Array} matrix
 * @param {Number} dx
 * @param {Number} dy
 * @returns {Array} translated matrix
 */
var translate = exports.translate = function(m1, dx, dy) {
   return multiply(m1, [1, 0, 0, 1, dx, dy]);
};

/**
 * @param {Array} matrix
 * @param {Number} angle in radians
 * @returns {Array} rotated matrix
 */
var rotate = exports.rotate = function(m1, angle) {
   // radians
   var sin = Math.sin(angle);
   var cos = Math.cos(angle);
   return multiply(m1, [cos, sin, -sin, cos, 0, 0]);
};

/**
 * @param {Array} matrix
 * @returns {Number} rotation in radians
 */
var rotation = exports.rotation = function(m1) {
      return Math.atan2(m1[1], m1[0]);
};

/**
 * @param {Array} matrix
 * @param {Array} vector [a, b]
 * @returns {Array} scaled matrix
 */
var scale = exports.scale = function(m1, svec) {
   var sx = svec[0];
   var sy = svec[1];
   return multiply(m1, [sx, 0, 0, sy, 0, 0]);
};

},{}],59:[function(require,module,exports){
/**
 * @fileoverview Utility functions for working with Objects
 */

/**
 * Put a prototype into the prototype chain of another prototype.
 * @param {Object} subClass
 * @param {Object} superClass
 */
exports.extend = function(subClass, superClass) {
   if (subClass === undefined) {
      throw new Error('unknown subClass');
   }
   if (superClass === undefined) {
      throw new Error('unknown superClass');
   }
   // new Function() is evil
   var f = new Function();
   f.prototype = superClass.prototype;

   subClass.prototype = new f();
   subClass.prototype.constructor = subClass;
   subClass.superClass = superClass.prototype;
   subClass.superConstructor = superClass;
   return;
};

/**
 * Creates a new object as the as the keywise union of the provided objects.
 * Whenever a key exists in a later object that already existed in an earlier
 * object, the according value of the earlier object takes precedence.
 * @param {Object} obj... The objects to merge
 */
exports.merge = function() {
   var result = {};
   var i, property;
      for (i = arguments.length; i > 0; --i) {
         var obj = arguments[i - 1];
         for (property in obj) {
            result[property] = obj[property];
         }
      }
   return result;
};

/**
 * fallback for Object.keys
 * @param {Object} obj
 * @returns {Array} list of own properties
 * @see https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Object/keys
 */
var keys = exports.keys = function(obj) {
   if (Object.keys) {
      return Object.keys(obj);
   }

   var ret=[],p;
   for (p in obj) {
      if(Object.prototype.hasOwnProperty.call(obj, p)) {
         ret.push(p);
      }
   }
   return ret;
};

/**
 * Create object accessors
 * @param {Object} object The object on which to define the property
 * @param {String} name name of the property
 * @param {Function} get
 * @param {Function} set
 * @see https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Object/defineProperty
 */
var accessor = exports.accessor = function(object, name, get, set) {
   // ECMA5
   if (Object.defineProperty !== undefined) {
      Object.defineProperty(object, name, {
         get: get,
         set: set
      });
   // non-standard
   } else if (Object.prototype.__defineGetter__ !== undefined) {
      object.__defineGetter__(name, get);
      if (set) {
         object.__defineSetter__(name, set);
      }
   }
	return;
};

/**
 * @param {Object} object The object on which to define or modify properties.
 * @param {Object} props An object whose own enumerable properties constitute descriptors for the properties to be defined or modified.
 * @see https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Object/defineProperties
 */
exports.accessors = function(object, props) {
   keys(props).forEach(function(propKey) {
      accessor(object, propKey, props[propKey].get, props[propKey].set);
   });
   return;
};

},{}],60:[function(require,module,exports){
/**
 * @fileoverview A seedable random-number generator.
 *
 * A generator is initialized by GameJs and can be used with the
 * static functions (choose, integer, vector,...).
 *
 * You can re-initialize this generator with a different seed by
 * calling `gamejs.utils.prng.init(seed)` after which the static
 * functions in this module will use the new seed.
 *
 * @usage
 *  var prng = require('gamejs/utils/prng');
 *  prng.random(); // 0.6765871671959758
 *  prng.integer(2, 10); // 5
 *  prng.choose([1,2,3,4,5]); // 3
 */
// From http://baagoe.com/en/RandomMusings/javascript/
// Johannes Baagøe <baagoe@baagoe.com>, 2010
// API modified by Simon Oberhammer <simon@nekapuzer.at>, 2012
// discussion of the used algorithms <http://baagoe.org/en/w/index.php/Better_random_numbers_for_javascript>


/* @ignore */
var Mash = function Mash() {
  var n = 0xefc8249d;
  this.hash = function(data) {
    data = data.toString();
    var i;
    for (i = 0; i < data.length; i++) {
      n += data.charCodeAt(i);
      var h = 0.02519603282416938 * n;
      n = h >>> 0;
      h -= n;
      h *= n;
      n = h >>> 0;
      h -= n;
      n += h * 0x100000000; // 2^32
    }
    return (n >>> 0) * 2.3283064365386963e-10; // 2^-32
  };

  this.version = 'Mash 0.9';
  return this;
};

/**
 * A seedable pseudo-random number generator.
 * @param {Number|String} seed the seed for generating the numbers
 *
 * @usage
 *  var prng = require('gamejs/utils/prng');
 *  var seed = 'gamejs';
 *  var alea = new prng.Alea(seed);
 *  alea.random(); // 0.6765871671959758
 *  alea.random(); // 0.15881546027958393
 *
 *  // generator with the same seed will generate the same sequence
 *  // of numbers:
 *  var aleaTwo = new prng.Alea(seed);
 *  aleaTwo.random(); // 0.6765871671959758
 *  aleaTwo.random(); // 0.15881546027958393
 */
var Alea = exports.Alea = function Alea() {
   var args = Array.prototype.slice.call(arguments);
   var s0 = 0;
   var s1 = 0;
   var s2 = 0;
   var c = 1;
   if (args.length == 0 || !args[0]) {
     args = [Date.now()];
   }
   var mash = new Mash();
   s0 = mash.hash(' ');
   s1 = mash.hash(' ');
   s2 = mash.hash(' ');

   var i;
   for (i = 0; i < args.length; i++) {
     s0 -= mash.hash(args[i]);
     if (s0 < 0) {
       s0 += 1;
     }
     s1 -= mash.hash(args[i]);
     if (s1 < 0) {
       s1 += 1;
     }
     s2 -= mash.hash(args[i]);
     if (s2 < 0) {
       s2 += 1;
     }
   }
   mash = null;

   /**
    * @returns {Number} the next random number as determined by the seed
    */
   this.random = function() {
     var t = 2091639 * s0 + c * 2.3283064365386963e-10; // 2^-32
     s0 = s1;
     s1 = s2;
     s2 = t - (c = t | 0);
     return s2;
   };
   return this;
};

// alea instance per gamejs instance
var alea = null;

/**
 * @param {Number} min
 * @param {Number} max
 * @returns {Number} random integer between min and max
 */
var integer = exports.integer = function(min, max){
    return min + parseInt(alea.random() * (max-min+1), 10);
};

/**
 * @param {Array} minVector 2 integers, the minimum vector
 * @param {Array} maxVector 2 integers, the maximum vector
 * @returns {Array} a random vector [min[0]<=x<=max[0], min[1]<=y<=max[1]]
 */
exports.vector = function(min, max){
    return [integer(min[0], max[0]), integer(min[1], max[1])];
};

/**
 * @param {Array} items
 * @returns {Object} random item from items list
 */
exports.choose = function(items){
    return items[integer(0, items.length-1)];
};

/**
 * @returns {Number} next random float between 0 and 1
 */
exports.random = function() {
  return alea.random();
};

/*
 * Re-initialize the per instance random number generator used
 * in the static functions on this module (e.g. vector())
 * @param {Number|String} seed
 */
exports.init = function(seed) {
  alea = new Alea(seed);
};
},{}],61:[function(require,module,exports){
/**
 * @fileoverview Utilies for URI handling.
 *
 */

var URI_REGEX = new RegExp(
    '^' +
    '(?:' +
      '([^:/?#.]+)' +                     // scheme - ignore special characters
                                          // used by other URL parts such as :,
                                          // ?, /, #, and .
    ':)?' +
    '(?://' +
      '(?:([^/?#]*)@)?' +                 // userInfo
      '([\\w\\d\\-\\u0100-\\uffff.%]*)' + // domain - restrict to letters,
                                          // digits, dashes, dots, percent
                                          // escapes, and unicode characters.
      '(?::([0-9]+))?' +                  // port
    ')?' +
    '([^?#]+)?' +                         // path
    '(?:\\?([^#]*))?' +                   // query
    '(?:#(.*))?' +                        // fragment
    '$');

/**
 * Resolve path against URI.
 *
 * @param {String} uri
 * @param {String} path to resolve
 */
var resolve = exports.resolve = function(uri, path) {
   var m = match(uri);
   var n = match(path);
   var host = '';
   if(m[1] && m[3]) host = m[1] + '://' + m[3];
   if (n[1]) {
      return path;
   }
   if (m[4]) {
      host = host + ":" + m[4];
   }
   var absolutePath = m[5];
   if (path.charAt(0) !== '/') {
      var lastSlashIndex = absolutePath.lastIndexOf('/');
      absolutePath = absolutePath.substr(0, lastSlashIndex + 1) + path;
   } else {
      absolutePath = path;
   }
   return host + removeDotSegments(absolutePath);

};

/**
 * Try to match an URI against a regex returning the following
 * capture groups:
 *     $1 = http              scheme
 *     $2 = <undefined>       userInfo -\
 *     $3 = www.ics.uci.edu   domain     | authority
 *     $4 = <undefined>       port     -/
 *     $5 = /pub/ietf/uri/    path
 *     $6 = <undefined>       query without ?
 *     $7 = Related           fragment without #
 *
 * @param {String} uri
 */
var match = exports.match = function(uri) {
   return uri.match(URI_REGEX);
};

/**
 * Make an absolute URI relative to document.location.href
 * @param {String} uri
 * @returns The relative URI or the unchanged URI if it's not
 * possible to make it relative to the path of document.location.href.
 */
var makeRelative = exports.makeRelative = function(uri) {
   var docLocPath = resolve(document.location.href, './');
   if (uri.indexOf(docLocPath) == 0) {
      uri = './' + uri.substring(docLocPath.length);
   }
   return uri;
};

/**
 * Removes dot segments in given path component
 */
var removeDotSegments = function(path) {
   if (path == '..' || path == '.') {
      return '';
   }
   var leadingSlash = path.indexOf('/') > -1;

   var segments = path.split('/');
   var out = [];

   var pos;
   for (pos = 0; pos < segments.length; ) {
      var segment = segments[pos++];

      if (segment == '.') {
         if (leadingSlash && pos == segments.length) {
            out.push('');
         }
      } else if (segment == '..') {
         if (out.length > 1 || out.length == 1 && out[0] != '') {
            out.pop();
         }
         if (leadingSlash && pos == segments.length) {
            out.push('');
         }
      } else {
         out.push(segment);
         leadingSlash = true;
      }
   }
   return out.join('/');
};

},{}],62:[function(require,module,exports){
var math=require('./math');

/**
 * @param {Array} origin point [b0, b1]
 * @param {Array} target point [b0, b1]
 * @returns {Number} distance between two points
 */
exports.distance = function(a, b) {
   return len(subtract(a, b));
};

/**
 * subtracts vectors [a0, a1] - [a0, a1]
 * @param {Array} a
 * @param {Array} b
 * @returns {Array} vector
 */
var subtract = exports.subtract = function(a, b) {
   return [a[0] - b[0], a[1] - b[1]];
};

/**
 * adds vectors [a0, a1] - [a0, a1]
 * @param {Array} a vector
 * @param {Array} b vector
 * @returns {Array} vector
 */
var add = exports.add = function(a, b) {
   return [a[0] + b[0], a[1] + b[1]];
};

/**
 * multiply vector with scalar or other vector
 * @param {Array} vector [v0, v1]
 * @param {Number|Array} vector or number
 * @returns {Number|Array} result
 */
var multiply = exports.multiply = function(a, s) {
   if (typeof s === 'number') {
      return [a[0] * s, a[1] * s];
   }

   return [a[0] * s[0], a[1] * s[1]];
};

/**
 * @param {Array} a vector
 * @param {Number} s
 */
exports.divide = function(a, s) {
   if (typeof s === 'number') {
      return [a[0] / s, a[1] / s];
   }
   throw new Error('only divide by scalar supported');
};

/**
 * @param {Array} vector [v0, v1]
 * @returns {Number} length of vector
 */
var len = exports.len = function(v) {
   return Math.sqrt(v[0]*v[0] + v[1]*v[1]);
};

/**
 *
 * normalize vector to unit vector
 * @param {Array} vector [v0, v1]
 * @returns {Array} unit vector [v0, v1]
 */
var unit = exports.unit = function(v) {
   var l = len(v);
   if(l) {
      return [v[0] / l, v[1] / l];
   }
   return [0, 0];
};

/**
 *
 * rotate vector
 * @param {Array} vector [v0, v1]
 * @param {Number} angle to rotate vector by, radians. can be negative
 * @returns {Array} rotated vector [v0, v1]
 */
exports.rotate=function(v, angle){
   angle=math.normaliseRadians(angle);
   return [v[0]* Math.cos(angle)-v[1]*Math.sin(angle),
           v[0]* Math.sin(angle)+v[1]*Math.cos(angle)];

};

/**
 *
 * calculate vector dot product
 * @param {Array} vector [v0, v1]
 * @param {Array} vector [v0, v1]
 * @returns {Number} dot product of v1 and v2
 */
var dot = exports.dot=function(v1, v2){
   return (v1[0] * v2[0]) + (v1[1] * v2[1]);
};

/**
 *
 * calculate angle between vectors
 * @param {Array} vector [v0, v1]
 * @param {Array} vector [v0, v1]
 * @returns {Number} angle between v1 and v2 in radians
 */
exports.angle=function(v1, v2){
   var perpDot = v1[0] * v2[1] - v1[1] * v2[0];
   return Math.atan2(perpDot, dot(v1,v2));
};

/**
 * @returns {Array} vector with max length as specified.
 */
exports.truncate = function(v, maxLength) {
   if (len(v) > maxLength) {
      return multiply(unit(v), maxLength);
   }
   return v;
};

},{"./math":57}],63:[function(require,module,exports){
var gamejs = require('../gamejs');
var uri = require('./utils/uri');
var Callback = require('./callback').Callback;

/** ignore **/
var _EVENTS = exports._EVENTS = {
   RESULT: 1001,
   ALIVE: 1002,
   LOG: 1004
};

/**
 * @fileoverview
 * Workers are useful to relieve your GameJs application from code which
 * might take long to run. Either expensive algorithms, which might get called
 * every now and then (e.g., path-finding) or another logic being run continously
 * within the rendering loop (e.g., physics engine).
 *
 * A Worker is like a seperate GameJs application being executed - another `main.js`
 * with its own `gamejs.ready()`. The Worker's most important feature is that
 * code executing within it does not block the rendering code. The Worker's
 * greatest limitation is that you can only communicate with it through text
 * messages.
 *
 * See the `examples/workers` directory for a running example.
 *
 * @example
 *  // Create a worker with the main module "./test"
 *  var fooWorker = new Worker('./test');
 *  // Send a message to your worker.
 *  // The Message doesn't have to be a string but it must be `JSON.stringify()`-able
 *  fooWorker.post("foobar");
 *
 *  fooWorker.onEvent(function(event) {
 *      if(event.data.timestamp > ...)
 *  });
 *
 *  // within the worker: you can send
 *  // send results back to the main application
 *  // by posting them:s
 *  gamejs.worker.post({
 *     name: "zarzar",
 *     timestamp: 12232435234
 *  });
 *
 */

/**
 * true if this GameJs instance is being executed within a WebWorker
 * @type Boolean
 */
var inWorker = exports.inWorker = (this.importScripts !== undefined);

/**
 * executed in scope of worker
 * @ignore
 */
exports._ready = function() {
   self.onmessage = function(event) {
      gamejs.event._triggerCallback(event.data);
   };
   self.postMessage({
     type: _EVENTS.ALIVE
   });
};

/**
 * Send an event back to the main script.
 * @param {Object} data to be sent back to main script
 */
exports.post = function(data) {
  if (inWorker) {
    self.postMessage({
       type: _EVENTS.RESULT,
       data: data
    });
  } else {
    throw new Error('gamejs.postMessage only available in a gamejs/worker module');
  }
};

/**
 * Send message to main context for logging
 * @ignore
 **/
exports._logMessage = function() {
   self.postMessage({
      type: _EVENTS.LOG,
      arguments: Array.prototype.slice.apply(arguments)
   });
};


/**
  * executed in scope of worker before user's main module
  * @ignore
  */
var workerPrefix = function workerPrefix() {
   __scripts.forEach(function(script) {
      try {
         importScripts(script);
      } catch (e) {
         // can't help the worker
      }
   });
};

/**
 * Setup a worker which has `require()` defined
 * @ignore
 **/
var create = function(workerModuleId) {
   var moduleRoot = uri.resolve(document.location.href, window.require.getModuleRoot());
   var initialScripts = [];
   Array.prototype.slice.apply(document.getElementsByTagName('script'), [0]).forEach(function(script) {
      if (script.src) {
         initialScripts.push(script.src);
      }
   });

   var URL = window.URL || window.webkitURL;
   var prefixString = workerPrefix.toString();
   // don't be afraid...
   prefixString = prefixString.substring(prefixString.indexOf("{") + 1, prefixString.lastIndexOf("}"));
   var blob = new Blob([
      'var __scripts = ["' + initialScripts.join('","') + '"];',
      prefixString,
      'self.require.setModuleRoot("' + moduleRoot + '");',
      'self.require.run("'+ workerModuleId +'");'
   ], {type: 'application\/javascript'});

   var blobURL = URL.createObjectURL(blob);
   return new Worker(blobURL);
};

/**
 * The `Worker` constructor takes only one argument: a module id. This module
 * will be executed inside the newly created Worker. It is effectively the
 * main module of the Worker.
 *
 * Inside a Worker, you can use `require()` to import other scripts or
 * GameJs modules.
 *
 * **Note:** A Worker does not have access to the browser's `document`. So
 * a lot of GameJs modules - everything related to drawing to the canvas -
 * do not work in the Worker.
 *
 * You can use `gamejs.time.*`, `gamejs.utils.*`, `gamejs.event.*` and probably others
 * (as well as any module you write yourself for this purpose, of course).
 *
 * @param {String} moduleId The Worker's main module id. The main module will be executed in the worker
 */
exports.Worker = function(moduleId) {
   // FIXME id should be unchangeable
   /**
    * Unique id of this worker
    * @property {Number}
    */
   var id = this.id = guid(moduleId);
   var worker = create(moduleId);
   var deadQueue = [];
   var alive = false;
   var self  = this;
   var _CALLBACK = new Callback(function() {}, {});
   var _ERROR_CALLBACK = new Callback(function() {}, {});

   worker.onmessage = function(event) {
      if (event.data.type === _EVENTS.ALIVE) {
         // if worker says he is alive -> send him the event queue so far
         alive = true;
         deadQueue.forEach(function(data) {
            self.post(data);
         });
      } else if (event.data.type === _EVENTS.LOG) {
         gamejs.log.apply(null, [id].concat(event.data.arguments));
      } else {
         _CALLBACK.trigger(event.data.data);
      }
   };
   worker.onerror = function(event) {
      gamejs.error('Error in worker "' + id + '" line ' + event.lineno + ': ', event.message);
      _ERROR_CALLBACK.trigger({
         data: event.data,
         worker: self,
         event: event
      });
   };

   /**
    *
    */
   this.onEvent = function(fn, scope) {
      _CALLBACK = new Callback(fn, scope);
   };

   this.onError = function(fn, scope) {
      _ERROR_CALLBACK = new Callback(fn, scope);
   };

   /**
    * Send a message to the worker
    *
    * @param {Object} data Payload object which gets sent to the Worker
    */
   this.post = function(data) {
      if (alive) {
         worker.postMessage(data);
      } else {
         deadQueue.push(data);
      }
   };
   return this;
};

/**
 * not a real GUID
 * @ignore
 */
function guid(moduleId) {
   var S4 = function() {
      return (((1+Math.random())*0x10000)|0).toString(16).substring(1);
   };
   return moduleId + '@' + (S4()+S4());
}
},{"../gamejs":37,"./callback":38,"./utils/uri":61}],64:[function(require,module,exports){
/**
 * @fileoverview
 *
 * Provides facilities for parsing an xml String.
 * 
 * You will typically get a `gamejs.xml.Document` instance
 * by loading the data with one of the two static 
 * `Document.fromString(string)` or `Document.fromUrl(url)`.

 * Querying for `elements(name)` or `children()` will return a
 * new `gamejs.xml.Document` matching your result (or null).
 *
 * Use `attributes(name)` and `value()` to get the data stored
 * in the XML Document.
 */

/**
 * XMLParser
 */
var Parser = exports.Parser = function() {

   var xmlDoc = null;
   var parser = new DOMParser();
   
   this.parseFromString = function(xmlString) {
      xmlDoc = parser.parseFromString(xmlString, 'text/xml');
      return xmlDoc;
   };
   
   return this;
};

/**
 * Instantiate with the static functions `Document.fromString()` and `fromURL()`.
 */
var Document = exports.Document = function(xmlDocument) {   
   if (!xmlDocument || (!xmlDocument instanceof XMLDocument) ) {
      throw new Error('Need a valid xmlDocument.');
   }
   /** @ignore **/
   this._xmlDocument = xmlDocument;
   return this;
};

/**
 * Returns the first element in the current document whose tag-name matches
 * the given 'name'.
 * @returns gamejs.xml.Document
 */
Document.prototype.element = function(name) {
   var elem = this._xmlDocument.getElementsByTagName(name)[0];
   return elem && new Document(elem) || null;
};

/**
 * Returns all elements in the current document whose tag-name matches
 * the given 'name'.
 * @returns an Array of gamejs.xml.Document
 */
Document.prototype.elements = function(name) {
   var elems = this._xmlDocument.getElementsByTagName(name);
   return Array.prototype.slice.apply(elems, [0]).map(function(elem) {
      return new Document(elem);
   });
};

/**
 * Returns the attribute value of this document.
 *
 * @returns String
 */
Document.prototype.attribute = function(name) {
   var attributeValue = this._xmlDocument.getAttribute(name);
   attributeValue = attributeValue ? attributeValue.trim() : null;
   if (attributeValue === null) {
      return null;
   }
   if (attributeValue.toLowerCase() === 'true') {
      return true;
   }
   if (attributeValue.toLowerCase() === 'false') {
      return false;
   }
   var attributeIntValue = parseInt(attributeValue, 10);
   var attributeFloatValue = parseFloat(attributeValue, 10);
   if (!isNaN(attributeIntValue)) {
      if (attributeFloatValue !== attributeIntValue) {
         return attributeFloatValue;
      }
      return attributeIntValue;
   }
   return attributeValue;
};

/**
 * Returns the nodevalue of the current xml document
 * @returns String
 */
Document.prototype.value = function() {
   return this._xmlDocument.nodeValue;
};

/**
 * Returns all children of this xml document
 * @returns Array of gamejs.xml.Document
 */
Document.prototype.children = function() {
   return Array.prototype.slice.apply(this._xmlDocument.childNodes, [0]).map(function(cNode) {
      return new Document(cNode);
   });
};

/**
 * @returns gamejs.xml.Document
 */
Document.fromString = function(xmlString) {
   var parser = new DOMParser();
   var xmlDoc = parser.parseFromString(xmlString, 'text/xml');
   return new Document(xmlDoc);
};

/**
 * @returns gamejs.xml.Document
 */
Document.fromURL = function(url) {
   var response = new XMLHttpRequest();
   response.open('GET', url, false);
   response.setRequestHeader('X-Requested-With', 'XMLHttpRequest');
   response.setRequestHeader('Content-Type', 'text/xml');
   response.overrideMimeType('text/xml');
   response.send();
   return new Document(response.responseXML);
};

},{}]},{},[24]);
